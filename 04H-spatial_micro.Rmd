# Spatial Analysis - Micro Samples

```{r load_data_spatial, eval=FALSE}
load("data/micro/sample_metadata.Rdata")
load("data/micro/counts.Rdata")
load("data/micro/seq_stats.Rdata")
load("data/data_colors.Rdata")
```

Amalia's comment: Code from Inaki, adapted by Antton and Carlotta. I tried to adapt it for Deliverable 6.3, not everything works yet. 


## Functions
### spatial_cryosections
```{r spatial_cryosections_fun, warning = FALSE, comments = "", message = FALSE}
spatial_cryosections <- function(cryosection_list, metadata_df, comm_clr) {
  cryosection_dfs <- list()
  mantel_results <- list()
  mantelcor_results <- list()
  decay_dfs <- list()
  distance_decay_plots <- list()
  structure_results <- list()

  for (cryosection in cryosection_list) {
    # Filter metadata for this section
    metadata_data <- metadata_df %>%
      filter(cryosection == !!cryosection, !is.na(.data$Xcoord), !is.na(.data$Ycoord))

    # Filter community data
    comm_data <- comm_clr %>%
      data.frame() %>%
      rownames_to_column(var = "microsample") %>%
      filter(microsample %in% metadata_data$microsample) %>%
      column_to_rownames(var = "microsample")

    cryosection_dfs[[cryosection]] <- list(
      comm_clr = comm_data,
      metadata = metadata_data
    )

    # Mantel correlogram
    mantel <- vegan::mantel(
      dist(comm_data),
      dist(metadata_data[, c("Xcoord", "Ycoord")]),
      permutations = 999
    )
    mantel_results[[cryosection]] <- mantel

    # Mantel correlogram
    correlog <- vegan::mantel.correlog(
      D.eco = dist(comm_data),
      D.geo = dist(metadata_data[, c("Xcoord", "Ycoord")]),
      nperm = 999
    )
    mantelcor_results[[cryosection]] <- correlog

    # Distance decay
    toplot <- data.frame(
      spat_dist = as.numeric(dist(metadata_data[, c("Xcoord", "Ycoord")])),
      comm_dist = as.numeric(dist(comm_data))
    )
    decay_dfs[[cryosection]] <- toplot

    # Plot
    p <- ggplot(toplot, aes(x = spat_dist, y = comm_dist)) +
      # geom_point() +
      geom_smooth() +
      xlab("Spatial distance (μm)") +
      ylab("Aitchison \ndistance") +
      theme_minimal() + 
      custom_ggplot_theme +
      # ggtitle(paste("Distance Decay -", cryosection))
      ggtitle(paste(cryosection))
    distance_decay_plots[[cryosection]] <- p

    # Print summary
    # print(paste("Summary for", cryosection))
    # print(summary(lm(comm_dist ~ spat_dist, data = toplot)))

    #### Complex spatial structures
    # set.seed(111)
    # spat_SWNs<-listw.candidates(data.frame(metadata_data[,c("Xcoord","Ycoord")]),
    # nb = c("gab"),
    # weights = c("fdown", "fup"),
    # y_fdown = c(2,5), y_fup = c(0.1,0.5))
    # W_sel <- listw.select(comm_data, spat_SWNs, MEM.autocor = "positive",
    # p.adjust = T, method="FWD")
    # structure_results[[cryosection]] <- W_sel
  }
  return(list(
    cryosection_dfs = cryosection_dfs,
    mantel_results = mantel_results,
    mantelcor_results = mantelcor_results,
    decay_dfs = decay_dfs,
    distance_decay_plots = distance_decay_plots,
    structure_results = structure_results
  ))
}
```



### Additive diversity partitioning 
```{r functions, warning=FALSE, comments="", message=FALSE, fig.height=6, fig.width=7}

# Function to calculate hierarchical additive partitioning
hier_adipart <- function(comm, hier, nsim = 999) {
  comm_bin <- (as.matrix(comm) > 0) * 1
  alpha_obs <- mean(rowSums(comm_bin))

  get_level_richness <- function(fac) {
    tapply(seq_len(nrow(comm_bin)), fac, function(idx) {
      sum(colSums(comm_bin[idx, , drop = FALSE]) > 0)
    }) |> mean()
  }

  level_names <- names(hier)
  level_rich  <- sapply(hier, get_level_richness)
  gamma_obs   <- sum(colSums(comm_bin) > 0)

  # exactly L betas
  betas <- c(level_rich[1] - alpha_obs, diff(level_rich))
  names(betas) <- paste0("beta (", level_names, ")")
  observed <- c(alpha = alpha_obs, betas, gamma = gamma_obs)

  stat_fun <- function(x) {
    x <- (x > 0) * 1
    alpha <- mean(rowSums(x))
    lvl <- sapply(hier, function(fac) {
      tapply(seq_len(nrow(x)), fac, function(idx)
        sum(colSums(x[idx, , drop = FALSE]) > 0)) |> mean()
    })
    gamma <- sum(colSums(x) > 0)
    betas <- c(lvl[1] - alpha, diff(lvl))     # ✅ no gamma - last_level
    names(betas) <- paste0("beta (", level_names, ")")
    c(alpha = alpha, betas, gamma = gamma)
  }

  sim <- oecosimu(comm_bin, stat_fun, method = "r2dtable", nsimul = nsim)

  tibble::tibble(
    component = names(observed),
    observed  = as.numeric(observed),
    expected  = as.numeric(sim$oecosimu$mean),
    pval      = as.numeric(sim$oecosimu$pval)
  )
}




plot_hier_adipart <- function(res, title = NULL) {
  p_to_stars <- function(p) case_when(
    p <= 0.001 ~ "***",
    p <= 0.01  ~ "**",
    p <= 0.05  ~ "*",
    TRUE      ~ ""
  )
  
  res_long <- res %>%
    pivot_longer(c(observed, expected), names_to = "type", values_to = "value") %>%
    mutate(
    component = factor(
      component,
      levels = c("alpha",
                 "beta (cryosection)",
                 "beta (animal)",
                 "beta (treatment)",
                 "gamma")
    )
  )
  
  ggplot(res_long, aes(x = component, y = value, fill = type)) +
    geom_col(position = position_dodge(width = 0.7), width = 0.6, color = "black") +
    geom_text(data = res, aes(x = component,
                              y = pmax(observed, expected) * 1.05,
                              label = p_to_stars(pval)),
              inherit.aes = FALSE, vjust = 0) +
    labs(x = NULL, y = "Richness", fill = NULL, title = title) +
    theme_minimal(base_size = 11) +
    theme(axis.text.x = element_text(angle = 15, hjust = 1),
          legend.position = "top")
}


```


## Load data

```{r data_spatial, warning = FALSE, comments = "", message = FALSE}
metadata <- plot_data_stats %>%
  filter(
    treatment == "TM3",
    age_category == "a",
    type_simple %in% c("P"),
    filter_status %in% c("Retained by filtering"),
    !is.na(Xcoord))

comm_data <- genome_counts_filt_30_zerosrem %>%
  select(genome, metadata$microsample) %>%
  t() %>%
  data.frame() %>%
  row_to_names(row_number = 1) %>%
  mutate(across(everything(), as.numeric))

# table(rowSums(comm_data) > 0)
# all(metadata$microsample == rownames(comm_data))
# table(is.na(comm_data))
# table(metadata$section, metadata$cryosection)


comm_ca <- comm_data[, colSums(comm_data) > 0]

metadata_ca <- metadata
table(metadata$section, metadata$cryosection)
table(metadata$section, metadata$animal)
```

#### Transform the data for posterior multivariate analyses

```{r data_spatial_clr, comment="", message=FALSE, warning=FALSE}
# Store original dimensions
original_rows <- nrow(comm_ca)
original_cols <- ncol(comm_ca)
  
comm_ca_zeroRepl <- cmultRepl(comm_ca, method = "GBM", output = "prop", z.warning = 0.95, z.delete = TRUE)

# Print removed rows and columns
removed_rows <- original_rows - nrow(comm_ca_zeroRepl)
removed_cols <- original_cols - ncol(comm_ca_zeroRepl)
cat("Rows (samples) removed:", removed_rows, "\n")
cat("Columns (taxa) removed:", removed_cols, "\n")
  

metadata_ca_clr <- metadata_ca[metadata_ca$microsample %in% rownames(comm_ca_zeroRepl), ]

clr_transform <- function(x) {
  log(x) - mean(log(x), na.rm = TRUE)
}
comm_ca_clr <- data.frame(t(apply(comm_ca_zeroRepl, 1, clr_transform)))
```


```{r plot_spatial_hier_ca, warning=FALSE, comments="", message=FALSE, fig.height=7, fig.width=7}
# Ensure hierarchy variables are factors, in order: cryosection (lowest), animal, treatment (highest)
hier_ca <- metadata_ca %>%
  transmute(
    cryosection = factor(cryosection),
    animal      = factor(animal),
    treatment   = factor(treatment)
  )
```


```{r plot_spatial_hier_adipart_ca, warning=FALSE, comments="", message=FALSE, fig.height=6, fig.width=7}

# Suppose comm_ca is your samples x genomes matrix
# and hier_ca is your data frame with cryosection, animal, treatment (in order lowest → highest)
res_ca <- hier_adipart(comm_ca, hier_ca, nsim = 999)

print(res_ca)

plot_hier_adipart(res_ca, title = "Caecum") + 
  custom_ggplot_theme

```



##### Ceacum Cryosection 
```{r cryosection_ca, warning = FALSE, comments = "", message = FALSE}
cryosections = metadata %>%
  distinct(cryosection) %>%
  pull(cryosection)

results_ca <- spatial_cryosections(
  cryosection_list = cryosections,
  metadata_df = metadata_ca_clr,
  comm_clr = comm_ca_clr
)
```

###### Mantel test
```{r caecum_spatial_mantel, comment="", message=FALSE, warning=FALSE}
results_ca$mantel_results
# results_ca$mantel_results$G121eI104C$statistic
# results_ca$mantel_results$G121eI104C$signif
# p < 0.05 → Statistically significant correlation between two distance matrices
# p > 0.05 → No significant correlation between two distance matrices
```


###### Mantel Correlogram Stat
```{r caecum_spatial_mantelcor, comment="", message=FALSE, warning=FALSE}
results_ca$mantelcor_results
```

###### Mantel Correlogram Plot
```{r caecum_spatial_mantelcor_plot, comment="", message=FALSE, warning=FALSE}
mantel_ca_grob <- ggplot(
  data.frame(results_ca$mantelcor_results$M041aI101A$mantel.res) %>%
    mutate(sign_label = ifelse(`Pr.Mantel.` <= 0.05, "Significant", "Not significant")) %>%
    filter(!is.na(Mantel.cor)),
  aes(x = class.index, y = Mantel.cor)
) +
  geom_point(aes(fill = sign_label), shape = 23, size = 3) +
  geom_line() +
  scale_fill_manual(values = c("Significant" = "black", "Not significant" = "white")) +
  labs(
    title = "M041aI101A",
    x = "Distance Class Index",
    y = "Mantel Correlation",
    color = "Significance"
  ) +
  geom_hline(yintercept = 0, color = "red") +
  theme_minimal()
  custom_ggplot_theme +
  theme(legend.position = "none")

mantel_ca_grob
```

######  Distance Decay Stat
```{r caecum_spatial_decay, comment="", message=FALSE, warning=FALSE}
aovperm(lmperm(comm_dist ~ spat_dist, data = results_ca$decay_dfs$M041aI101A), np = 10000)
# p < 0.05 → Significant correlation: Spatial distance influences microbial composition.
# p > 0.05 → No significant relationship: Microbial communities do not change with distance.
```

######  Distance Decay Plot

```{r plot_spatial_decay_ca_list, comment="", message=FALSE, warning=FALSE}
results_ca$distance_decay_plots
```

```{r plot_spatial_decay_ca_combined, comment="", message=FALSE, warning=FALSE, fig.height=6, fig.width=10}
results_ca$distance_decay_plots$M041aI101A + mantel_ca_grob

```

## Extended RLQ analysis
On cryosections with a signal

```{r load_data_rlqESLTP, comment="", message=FALSE, warning=FALSE}
source("data/JEC_1743_sm_apps5.txt")
```

```{r prepare_data_rlqESLTP, comment="", message=FALSE, warning=FALSE}
# comm_co_G121eO301A <- results_co$cryosection_dfs[[cryosection]]$comm_clr
# metadata_co_G121eO301A <- results_co$cryosection_dfs[[cryosection]]$metadata

selected_cryosection = "M041aI101A"

comm_ca_cryosection <- comm_data[metadata$cryosection == selected_cryosection, ]
comm_ca_cryosection <- comm_ca_cryosection[, colSums(comm_ca_cryosection) > 0]


metadata_ca_cryosection <- metadata[metadata$cryosection == selected_cryosection, ]


comm_ca_cryosection <- comm_ca_cryosection %>%
  as.data.frame() %>%
  rownames_to_column(var = "microsample") %>%
  bind_cols(metadata_ca_cryosection) %>%
  select(contains("bin_"))


comp <- decostand(comm_ca_cryosection, MARGIN = 1, method = "hellinger") # Standardize composition by rows
colnames(comp) <- gsub("\\.", ":", names(comp))
env <- data.frame(
  log_seq_counts = log(metadata_ca_cryosection$total_sequences_after_trim),
  div = rowSums(comp > 0)
) # Environmental matrix

genome_gifts <- genome_gifts[rownames(genome_gifts) %in% colnames(comp), ]
genome_funct <- genome_gifts %>%
  data.frame() %>%
  rownames_to_column(var = "id") %>% # Preserve row names as a column
  pivot_longer(-id, names_to = "column", values_to = "value") %>% # Reshape to long format
  mutate(group = substr(column, 1, 3)) %>% # Extract the first 3 characters of column names
  group_by(id, group) %>% # Group by row (id) and prefix
  summarise(mean_value = mean(value, na.rm = TRUE), .groups = "drop") %>% # Calculate rowMeans for each group
  pivot_wider(names_from = group, values_from = mean_value) %>% # Reshape back to wide format
  column_to_rownames(var = "id")
genome_funct <- genome_funct[, -c(19:21)]

phy <- genome_tree # Phylogenetic tree constructed with Phylomatic V3 + Phylocom

phy <- drop.tip(phy, setdiff(phy$tip.label, rownames(genome_funct)))
spa <- metadata_ca_cryosection[, c("Xcoord", "Ycoord")] # Matrix of X Y spatial coordinates
comp <- comp[, match(phy$tip.label, colnames(comp))]
genome_funct <- genome_funct[match(phy$tip.label, rownames(genome_funct)), ]

mean(phy$tip.label == colnames(comp))

# Change the phylogenetic tree (an object of the class "phylo") into an object of the class "phylog", used by ade4
phylog <- newick2phylog(write.tree(phy)) # => "phylog" class
colnames(comp) <- gsub(":", "_", colnames(comp))
rownames(genome_funct) <- gsub(":", "_", rownames(genome_funct))
```

####### Correspondence analysis of the composition matrix 
```{r correspondence_rlqESLTP, comment="", message=FALSE, warning=FALSE}
coacomp <- dudi.coa(comp, scan = FALSE, nf = 108)
summary(coacomp)
```

###### Spatial analysis 

###### Gabriel graph

```{r gabriel_graph, comment="", message=FALSE, warning=FALSE}
# Create the Gabriel graph
nb1 <- graph2nb(gabrielneigh(as.matrix(spa)), sym = T)
nb1

# Spatial autocorrelation in diversity and sequence count distribution
sp.correlogram(nb1, log(env$div), order = 8, method = "I")
sp.correlogram(nb1, env$log_seq_counts, order = 8, method = "I")

lw1 <- nb2listw(nb1) # gives a neighbours list with spatial weights (i.e. matrix W)
lw1
```



```{r gabriel_graph_plot, comment="", message=FALSE, warning=FALSE}
par(mfrow = c(1, 1))
plot(nb1, spa, pch = 21, bg = "red")
title(main = "Gabriel Graph")
class(nb1)

# [1] "nb"
# This is the Gabriel graph -the graph that in this case defines which points
# are connected

# The matrix of spatial variables is obtained as the eigenvectors of a
# neighbour matrix. This matrix is analysed by principal component analysis.
nb1.neigh <- nb2neig(nb1)
vecspa <- scores.neig(nb1.neigh)
pcaspa <- dudi.pca(vecspa, coacomp$lw, scan = FALSE, nf = ncol(vecspa))
summary(pcaspa)
```

###### PCA analysis of the env matrix
```{r env_pca, comment="", message=FALSE, warning=FALSE}
pcaenv <- dudi.pca(env, row.w = coacomp$lw, scannf = FALSE, nf = 2)
summary(pcaenv)
```

###### The distances between species based on their biological traits, analyzed by PCoA.
I will set these eval=FALSE as I get an error and I do not have time to troubleshoot yet.
```{r distances_traits, comment="", message=FALSE, warning=FALSE, eval=FALSE}
# Distance matrices for traits separately
listdis <- ldist.ktab(ktab.list.df(list(genome_funct)), c("Q"), scan = FALSE)
# choose 1

# Distance matrix for traits together
disT <- dist.ktab(ktab.list.df(list(genome_funct)), c("Q"), scan = FALSE)
# choose 1
pcotraits <- dudi.pco(disT, coacomp$cw, full = TRUE)

summary(pcotraits)

# n_dis <- attr(disT, "Size") %||% nrow(as.matrix(disT))
# length(coacomp$cw); length(coacomp$lw); n_dis
# summary(coacomp$cw); summary(coacomp$lw)

```

###### The distances between species based on their phylogenetic relatedness, analysed by PCoA.

```{r distances_phylogeny, comment="", message=FALSE, warning=FALSE, eval=FALSE}
# Trying to make the genome names match
# Clean tree names
rownames(phylog$Wdist) <- sub("^X", "", rownames(phylog$Wdist))
colnames(phylog$Wdist) <- sub("^X", "", colnames(phylog$Wdist))

# Filter comp to taxa that are in the tree
comp <- comp[names(comp) %in% rownames(phylog$Wdist)]

# Ensure comp is ordered to match tree
comp <- comp[rownames(phylog$Wdist)]

length(comp)
nrow(phylog$Wdist)

# Check alignment
setdiff(names(comp), rownames(phylog$Wdist))
setdiff(rownames(phylog$Wdist), names(comp))


length(comp)                          # number of taxa used
nrow(phylog$Wdist)                    # same number of taxa
length(coacomp$cw)                    # weight vector length

## Actual code
pcophy <- dudi.pco(as.dist(as.matrix(phylog$Wdist)[names(comp), names(comp)]), coacomp$cw, full = TRUE)
summary(pcophy)

## 11. Tests for phylogenetic signals in traits
## *******************************************
# Function rtest.decdiv() in appendix S5, Pavoine et al., 2011. [1]
# All traits together
phystot <- rtest.decdiv(phylog, rep(1, 108), as.dist(as.matrix(disT)[names(phylog$leaves), names(phylog$leaves)]),
  nrep = 99, vranking = "droot", optiontest = "less", ties.method = "average", option = 3
)
phystot

# All traits independently
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D01)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D02)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D03)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D05)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D06)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D07)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D08)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D09)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B01)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B02)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B03)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B06)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B07)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B08)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B09)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)
rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B10)[
  names(phylog$leaves),
  names(phylog$leaves)
]),
nrep = 99, vranking = "droot", optiontest = "less",
ties.method = "average", option = 3
)

## Update the PCOA of traits to remove traits without phylogenetic signal
# Distance matrix for traits together
disT <- dist.ktab(ktab.list.df(list(genome_funct[, -c(4, 8, 13)])), c("Q"), scan = FALSE)
# choose 1
pcotraits <- dudi.pco(disT, coacomp$cw, full = TRUE)
summary(pcotraits)
```


###### Extended RLQ analysis

```{r extended_rlq, comment="", message=FALSE, warning=FALSE, eval=FALSE}
rlqmix <- rlqESLTP(pcaenv, pcaspa, coacomp, pcotraits, pcophy, scan = F, nf = 2)
barplot(rlqmix$eig)
rlqmix$eig[1] / sum(rlqmix$eig)
# [1] 0.73
rlqmix$eig[2] / sum(rlqmix$eig)
# [1] 0.12
```


**1st axis**
```{r plot_spatial_rlq_axis1_spa_phy, comment="", message=FALSE, warning=FALSE, eval=FALSE}
plot(rlqmix, xy = spa, ax = 1, wh = "S")
plot(rlqmix, phy = phylog, ax = 1, wh = "P")
```






```{r plot_spatial_rlq_axis1_traits, comment="", message=FALSE, warning=FALSE, eval=FALSE}
plot(rlqmix, traits = genome_funct[, -c(4, 8, 13)], ax = 1, type = "Q", wh = "T")

GIFT_db %>%
  distinct(Code_function, Function)%>%
  filter(Code_function %in% c("D02", "B07", "D03", "D09", "D07", "D08"))

```


```{r plot_spatial_rlq_axis1_env, comment="", message=FALSE, warning=FALSE, eval=FALSE}
plot(rlqmix, env = pcaenv$tab, ax = 1, type = "Q", wh = "E")
```



```{r plot_spatial_rlq_svalue, warning=FALSE, comments="", message=FALSE, fig.height=11, fig.width=8, eval=FALSE}
s.value(metadata_ca_cryosection[, c("Xcoord", "Ycoord")],
  rlqmix$lR[, 1],
  sub = "Patterns in S and E",
  csub = 1.5,
  include.origin = F,
  csize = 0.8
)


```



```{r plot_spatial_rlq_env_wide, warning=FALSE, comments="", message=FALSE, fig.height=5, fig.width=12, eval=FALSE}
plot(rlqmix, env = pcaenv$tab, ax = 1, type = "Q", wh = "E")
```

```{r plot_spatial_rlq_dotchart, warning=FALSE, comments="", message=FALSE, fig.height=12, fig.width=12, eval=FALSE}
dotchart.phylog(phylog, rlqmix$lQ[names(phylog$leaves), 1],
  cleav = 0, cdot = 1,
  scaling = F, yjoi = 0, cex.axis = 1.5, sub = "patterns in T and P", csub = 0
)
```


