[["index.html", "3D’omics | Histomonas Turkeys Work in progress 1 Introduction 1.1 Prepare the R environment 1.2 Helper Functions 1.3 Notes:", " 3D’omics | Histomonas Turkeys Work in progress Amalia Bogri1 Jorge Langa2 Antton Alberdi3 2025-11-17 1 Introduction This webbook contains all the code used for the analyses of for Deliverable 6.3 for the Histomonas trials on turkeys. 1.1 Prepare the R environment 1.1.1 Environment To reproduce all the analyses locally, clone this repository in your computer using: RStudio &gt; New Project &gt; Version Control &gt; Git And indicating the following git repository: https://github.com/3d-omics/ANMI024_Histomonas_Turkeys_Macro_and_Micro.git Once the R project has been created, follow the instructions and code chunks shown in this webbook. 1.1.2 Libraries The following R packages are required for the data analysis. # Base library(R.utils) library(knitr) library(devtools) library(tinytable) library(broom) library(broom.mixed) library(rairtable) library(jsonlite) # For tree handling library(ape) library(phyloseq) library(phytools) # For plotting library(ggplot2) library(ggrepel) library(ggpubr) library(ggnewscale) library(gridExtra) library(ggtreeExtra) library(ggtree) library(ggh4x) library(jpeg) library(patchwork) # For statistics library(spaa) library(vegan) library(Rtsne) library(geiger) library(hilldiv2) library(distillR) library(lme4) library(Hmsc) library(psych) # For compositional analyses library(zCompositions) library(compositions) library(ALDEx2) library(ANCOMBC) library(microbiome) library(ggcorrplot) library(propr) library(MASS) # for Negative Binomial Fit library(ggVennDiagram) library(janitor) library(permuco) library(magick) library(ade4) library(spdep) library(Hmisc) library(reshape2) # Tidyverse libraries (load dplyr last to avoid conflicts) library(tidyverse) library(dplyr) # Explicitly load dplyr last 1.2 Helper Functions 1.2.1 Alpha Diversity Calculation Function to estimate the genomes’ alpha diversity measurements from genome counts. calculate_alpha_diversity &lt;- function(input_data, dataset_name) { # Step 1: Transform the input data (remove rownames if needed) input_data_matrix &lt;- input_data %&gt;% column_to_rownames(var = &quot;genome&quot;) #%&gt;% # mutate_at(vars(-genome), ~ . / sum(.)) # No reason to do this closure to 1. Results are the same if you do it or not. # Step 2: Calculate richness (q = 0) richness &lt;- hilldiv(input_data_matrix, q = 0) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(richness = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 3: Calculate neutral diversity (q = 1) neutral &lt;- hilldiv(input_data_matrix, q = 1) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(neutral = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 4: Calculate phylogenetic diversity (q = 1, with genome tree) phylogenetic &lt;- hilldiv(input_data_matrix, q = 1, tree = genome_tree) %&gt;% t() %&gt;% as.data.frame() %&gt;% rename(phylogenetic = 1) %&gt;% rownames_to_column(var = &quot;microsample&quot;) # Step 5: Merge all diversity metrics alpha_diversity &lt;- richness %&gt;% full_join(neutral, by = &quot;microsample&quot;) %&gt;% full_join(phylogenetic, by = &quot;microsample&quot;) # %&gt;% # left_join(sample_metadata, by = &quot;microsample&quot;) %&gt;% # left_join(final_combined_stats, by = &quot;microsample&quot;) %&gt;% # Return the alpha_diversity data frame return(alpha_diversity) } 1.2.2 Remove samples or taxa # Input: A wide df with samples as rows and taxa as columns # Result: Remove taxa that are in too few samples, or samples that have too few taxa remove_samples_or_taxa &lt;- function(df, min_samples_per_taxon, min_taxa_per_sample){ # Store &amp; print original df dimensions original_rows &lt;- nrow(df) original_cols &lt;- ncol(df) cat(&quot;Initial df: Rows (samples):&quot;, original_rows, &quot;, Columns (taxa):&quot;, original_cols, &quot;\\n&quot;) # Remove taxa that are in less than x samples df &lt;- df %&gt;% select(where(~ sum(. != 0) &gt; min_samples_per_taxon)) # Remove samples that contain less than x taxa df &lt;- df %&gt;% filter(rowSums(. != 0) &gt; min_taxa_per_sample) df &lt; df %&gt;% select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) removed_rows &lt;- original_rows - nrow(df) removed_cols &lt;- original_cols - ncol(df) cat(&quot;Removed: Rows (samples):&quot;, removed_rows, &quot;, Columns (taxa):&quot;, removed_cols, &quot;\\n&quot;) cat(&quot;Resulting df: Rows (samples):&quot;, nrow(df), &quot;, Columns (taxa):&quot;, ncol(df), &quot;\\n&quot;) return(df) } 1.2.3 clr_function clr_transform &lt;- function(x) { log(x) - mean(log(x), na.rm = TRUE) } 1.2.4 perform_pca perform_pca &lt;- function(df, zero_method = &quot;GBM&quot;, z_delete = TRUE) { # Store original dimensions original_rows &lt;- nrow(df) original_cols &lt;- ncol(df) # 1. Zero replacement if (any(df == 0)) { # I think cmultRepl already does that print(&quot;Zeros found&quot;) df &lt;- cmultRepl(df, method = zero_method, output = &quot;prop&quot;, z.warning = 0.8, z.delete = z_delete ) df &lt;- df * 100 } # Print removed rows and columns removed_rows &lt;- original_rows - nrow(df) removed_cols &lt;- original_cols - ncol(df) cat(&quot;Rows (samples) removed after zero replacement:&quot;, removed_rows, &quot;\\n&quot;) cat(&quot;Columns (taxa) removed after zero replacement:&quot;, removed_cols, &quot;\\n&quot;) # Geometric mean function geometric_mean &lt;- function(x) { # Use log to avoid underflow exp(mean(log(x), na.rm = TRUE)) } # 2. Calculate geometric mean of the parts (taxa) of the data set. taxa_geometric_means &lt;- apply(df, 2, geometric_mean) # 3. Center data df_centered &lt;- sweep(df, 2, taxa_geometric_means, FUN = &quot;/&quot;) df_centered &lt;- as.matrix(df_centered) # Compute the Variation Matrix variation_matrix &lt;- outer( 1:ncol(df_centered), 1:ncol(df_centered), Vectorize(function(i, j) var(log(df_centered[, i] / df_centered[, j]), na.rm = TRUE)) ) # Calculate Total Variance D &lt;- ncol(df_centered) # Number of taxa (columns) totvar &lt;- (1 / (2 * D)) * sum(variation_matrix, na.rm = TRUE) # 4. Scale data power_exponent &lt;- 1 / sqrt(totvar) df_scaled &lt;- df_centered^power_exponent # CLR transform data df_clr &lt;- as.data.frame(t(apply(df_scaled, 1, clr_transform))) df_clr_dist &lt;- as.data.frame(t(apply(df, 1, clr_transform))) # Perform PCA on zero replaced, centered, scaled, and CLR transformed df pca_result &lt;- prcomp(df_clr, center = FALSE, scale. = FALSE) return(list( df_clr = df_clr, df_clr_dist = df_clr_dist, pca_result = pca_result )) } 1.2.5 plot_pca # Use the &#39;pca_result&#39; df produced from &#39;perform_pca&#39; function to make the PCA plot plot_pca &lt;- function(df, samples_color_metadata, samples_shape_metadata, samples_color_value, loadings_color_metadata, loadings_color_value, loadings_taxon_level, sample_metadata, genome_metadata, order_colors, custom_ggplot_theme, scaling_factor_value = 1.5, loadings_number = 10, show_labels = FALSE, add_arrows = FALSE, add_centroids = FALSE) { # Extract scores from PCA results scores &lt;- rownames_to_column(as.data.frame(df$x), var = &quot;microsample&quot;) scores &lt;- left_join(scores, sample_metadata, by = join_by(microsample == microsample)) # Calculate limits for x and y axes x_limit &lt;- max(abs(scores$PC1)) y_limit &lt;- max(abs(scores$PC2)) # Calculate variance explained by each PC (principal component) &amp; create labels for plot variance_explained &lt;- (df$sdev^2) / sum(df$sdev^2) * 100 pc1_label &lt;- paste0(&quot;PC1: &quot;, round(variance_explained[1], 2), &quot;% variance explained&quot;) pc2_label &lt;- paste0(&quot;PC2: &quot;, round(variance_explained[2], 2), &quot;% variance explained&quot;) # Set a scaling factor for loadings (arrows) scaling_factor &lt;- scaling_factor_value # Extract and scale the loadings loadings &lt;- df$rotation[, 1:2] %&gt;% as.data.frame() %&gt;% mutate(genome = rownames(.)) %&gt;% mutate(PC1 = PC1 * scaling_factor, PC2 = PC2 * scaling_factor) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% mutate(abs_loading = sqrt(PC1^2 + PC2^2)) %&gt;% arrange(desc(abs_loading)) %&gt;% slice_max(order_by = abs_loading, n = loadings_number) %&gt;% mutate(order_color = order_colors[order]) # Create ggplot p &lt;- ggplot() + # Plot the samples (points) geom_point(data = scores, aes(x = PC1, y = PC2, fill = .data[[samples_color_metadata]], shape = .data[[samples_shape_metadata]]), #.data[[]] tells ggplot2 to look up the column dynamically. size = 2.5, alpha = 0.8, color = &quot;black&quot;, stroke = 0.3) + scale_fill_manual(values = samples_color_value) + scale_shape_manual(values = c(21, 24, 23, 22, 25)) + new_scale_color() + # new_scale_fill() ? # Plot the loadings (taxa, i.e. arrows) geom_segment(data = loadings, aes(x = 0, y = 0, xend = PC1, yend = PC2, color = .data[[loadings_color_metadata]]), arrow = arrow(length = unit(0.2, &quot;cm&quot;)), size = 0.7, alpha = 0.9) + scale_color_manual(name = &quot;Classification&quot;, values = loadings_color_value) + geom_text_repel(data = loadings, aes(x = PC1, y = PC2, label = .data[[loadings_taxon_level]]), color = &quot;black&quot;, size = 3, vjust = -0.5, alpha=0.7, max.overlaps = 20) + labs(title = &quot;PCA Ordination Plot&quot;, x = pc1_label, y = pc2_label) + scale_x_continuous(limits = c(-x_limit, x_limit)) + scale_y_continuous(limits = c(-y_limit, y_limit)) + geom_hline(yintercept = 0, color = &quot;darkgrey&quot;) + geom_vline(xintercept = 0, color = &quot;darkgrey&quot;) + theme_minimal() + custom_ggplot_theme + # coord_fixed(ratio = 1) + guides(fill = guide_legend(override.aes = list(shape = 21, color = &quot;black&quot;))) # to print the legend for colour correctly! # ADD text to points if (show_labels) { p &lt;- p + geom_text( data = scores, aes(x = PC1, y = PC2, label = animal), position = position_nudge(y = -0.02), size = 3.5, alpha = 0.7 ) } if (add_arrows) { # Prepare arrow data arrows_df &lt;- scores %&gt;% arrange(treatment, age) %&gt;% group_by(treatment) %&gt;% mutate( PC1_next = lead(PC1), PC2_next = lead(PC2) ) %&gt;% filter(!is.na(PC1_next)) # Add arrows to the plot p &lt;- p + geom_segment( data = arrows_df, aes( x = PC1, y = PC2, xend = PC1_next, yend = PC2_next, color = treatment ), arrow = arrow(length = unit(0.15, &quot;cm&quot;)), linewidth = 0.6, alpha = 0.8, inherit.aes = FALSE ) } if (add_centroids) { # Compute centroids per treatment × age centroids &lt;- scores %&gt;% group_by(.data[[samples_color_metadata]], .data[[samples_shape_metadata]]) %&gt;% summarise( PC1 = mean(PC1), PC2 = mean(PC2), .groups = &quot;drop&quot; ) %&gt;% rename( color_group = 1, shape_group = 2 ) %&gt;% arrange(color_group, shape_group) centroid_arrows &lt;- centroids %&gt;% group_by(color_group) %&gt;% mutate( PC1_next = lead(PC1), PC2_next = lead(PC2) ) %&gt;% filter(!is.na(PC1_next)) # Add new color scale so centroids use treatment palette again p &lt;- p + new_scale_color() + new_scale_fill() + geom_segment( data = centroid_arrows, aes( x = PC1, y = PC2, xend = PC1_next, yend = PC2_next, color = color_group ), arrow = arrow(length = unit(0.25, &quot;cm&quot;), type = &quot;closed&quot;), linewidth = 1.2, alpha = 0.7, inherit.aes = FALSE ) + geom_point( data = centroids, aes( x = PC1, y = PC2, shape = factor(shape_group), color = color_group, fill = color_group ), size = 4.5, stroke = 1, alpha = 0.5, fill = &quot;white&quot;, inherit.aes = FALSE ) + geom_text( data = centroids, aes( x = PC1, y = PC2, label = shape_group, color = color_group ), size = 3.3, vjust = -1.2, fontface = &quot;bold&quot;, inherit.aes = FALSE ) + scale_color_manual(values = samples_color_value) + scale_fill_manual(values = samples_color_value) } return(p) } 1.3 Notes: 1.3.1 Installation of modules Most of the modules can be downloaded from CRAN with ‘install.packages(’XXX’, dependencies = TRUE)‘. Four modules are from Bioconductor. Install with: ’install.packages(’BiocManager’, dependencies = TRUE) BiocManager::install(c(“phyloseq”, “ggtreeExtra”,“ggtree”,“ANCOMBC”))’ Two modules are from Antton’s github. Install with: ‘install.packages(’remotes’, dependencies = TRUE) remotes::install_github(‘anttonalberdi/hilldiv2’) remotes::install_github(‘anttonalberdi/distillR’)’ # if (!require(“BiocManager”, quietly = TRUE)) # install.packages(“BiocManager”) # BiocManager::install(“ALDEx2”) # remotes::install_github(‘tpq/propr’) 1.3.2 Airtable access: Currently the metadata is loaded from the 3D’omics airtable. In order to access it you need your own API key (from Antton). set_airtable_api_key(‘XXXXX’, install = TRUE) University of Copenhagen, amalia.bogri@sund.ku.dk↩︎ University of Copenhagen, jorge.langa@sund.ku.dk↩︎ University of Copenhagen, antton.alberdi@sund.ku.dk↩︎ "],["mag-catalogue.html", "2 MAG Catalogue 2.1 Dereplicated genomes 2.2 Genome (MAGs) tree 2.3 Genome (MAGs) taxonomy 2.4 Genome (MAGs) quality 2.5 Merged Genome (MAGs) taxonomy &amp; quality 2.6 Factoring of taxonomic levels 2.7 Genome (MAGs) functional annotations 2.8 Bacterial phyla color scheme data 2.9 Save working objects 2.10 Validation", " 2 MAG Catalogue Relevant metadata of genomes are fetched and merged into one genome metadata object for downstream analyses. Location on ERDA: ID: glS5qQbDc2 Path: 3D-omics/references/REF0029-m_mg_hybrid/ Access: read genome_taxonomy: https://sid.erda.dk/share_redirect/glS5qQbDc2/gtdbtk.summary.tsv genome_quality: https://sid.erda.dk/share_redirect/glS5qQbDc2/checkm2.quality_report.tsv genome_tree: https://sid.erda.dk/share_redirect/glS5qQbDc2/gtdbtk.backbone.bac120.classify.tree genome_annotations: https://sid.erda.dk/share_redirect/glS5qQbDc2/dram.annotations.tsv.gz The number of genomes in these files should match the number of genomes in the count tables, after accounting for the appropriate dereplication at species level. 2.1 Dereplicated genomes Bins were initially dereplicated at 99%, and annotations generated for all resulting MAGs. A second dereplication was performed at 95% to yield species-representative genomes. This analysis is performed on the 95% subset. This is how to extract the names of the genomes that remain in the 95% dereplication: 1. Download the file from ERDA: 3D-omics/references/REF0029-m_mg_hybrid/drep.0.95.fa.gz 2. Save it in a directory, and navigate into the directory from the command line. 3. Execute the 3 commands: gunzip drep.0.95.fa.gz grep “^&gt;” drep.0.95.fa | sed ‘s/&gt;//’ &gt; genome_names.tsv cut -d’@’ -f1 genome_names.tsv | sort -u &gt; unique_genome_names.tsv Load the list of dereplicated genome names selected_genomes &lt;- read_tsv(&quot;data/MAG_catalogue/unique_genome_names.tsv&quot;, col_names = &quot;genomes&quot;) %&gt;% pull(genomes) The dereplication yielded 527 species-representative genomes. 2.2 Genome (MAGs) tree This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. Note that the archaeal tree is only generated if any archaeans are detected among the genomes. Load and prune the phylogenetic tree to include only selected genomes genome_tree &lt;- read.tree(&quot;data/MAG_catalogue/gtdbtk.backbone.bac120.classify.tree&quot;) # remove single quotes in MAG names genome_tree$tip.label &lt;- str_replace_all(genome_tree$tip.label, &quot;&#39;&quot;, &quot;&quot;) # There is a genome present in the selected genomes but absent in the tree. This causes the keep.tree to crash. missing_genomes &lt;- setdiff(selected_genomes, genome_tree$tip.label) missing_genomes # The missing genome (from the tree): MPB:bin_000147 # In the selected_genomes list, select only genomes present in the tree selected_genomes &lt;- selected_genomes[selected_genomes %in% genome_tree$tip.label] # Then, in the tree, select only the selected_genomes at 95% dereplication genome_tree &lt;- keep.tip(genome_tree, tip = selected_genomes) 2.3 Genome (MAGs) taxonomy This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses. Load and process genome taxonomy data genome_taxonomy &lt;- read_tsv(&quot;data/MAG_catalogue/gtdbtk.summary.tsv&quot;, show_col_types = FALSE) %&gt;% # rename first column rename(genome = user_genome) %&gt;% # remove .fa from the end of each genome name mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% # select the species-representative genomes filter(genome %in% selected_genomes) %&gt;% # separate column &#39;classification&#39; into columns for the different taxonomic levels separate(classification, c(&quot;domain&quot;, &quot;phylum&quot;, &quot;class&quot;, &quot;order&quot;, &quot;family&quot;, &quot;genus&quot;, &quot;species&quot;), sep = &quot;;&quot;) %&gt;% # remove redundant letters before taxon names mutate(across(domain:species, ~ str_sub(., 4))) %&gt;% # select the relevant taxonomic columns select(genome, domain, phylum, class, order, family, genus, species) %&gt;% mutate( species = if_else( is.na(species) | species == &quot;&quot;, paste0(&quot;unclassified_&quot;, genus), species ) ) %&gt;% mutate( species = if_else( is.na(species) | species == &quot;unclassified_&quot;, paste0(&quot;unclassified_&quot;, family), species ) ) %&gt;% mutate( genus = if_else( is.na(genus) | genus == &quot;&quot;, paste0(&quot;unclassified_&quot;, family), genus ) ) 2.4 Genome (MAGs) quality Quality properties of the genomes. Load and process genome quality metrics genome_quality &lt;- read_tsv(&quot;data/MAG_catalogue/checkm2.quality_report.tsv&quot;, show_col_types = FALSE) %&gt;% # rename first column rename(genome = 1) %&gt;% # remove .fa from the end of each genome name mutate(genome = str_replace_all(genome, &quot;\\\\.fa&quot;, &quot;&quot;)) %&gt;% # select the species-representative genomes filter(genome %in% selected_genomes) %&gt;% # select relevant columns and rename select(genome, Completeness, Contamination, Coding_Density, Genome_Size, Contig_N50) %&gt;% rename(completeness = Completeness, contamination = Contamination, coding_density = Coding_Density, length = Genome_Size, N50_length = Contig_N50) %&gt;% mutate(circularity = N50_length/length) %&gt;% mutate(circularity = ifelse(circularity &gt;= 1, &quot;1&quot;, &quot;0&quot;)) %&gt;% # update completeness and contamination for genomes with circularity of 1 mutate(completeness = ifelse(circularity == &quot;1&quot;, 100, completeness), contamination = ifelse(circularity == &quot;1&quot;, 0, contamination)) %&gt;% # estimate ratio of: genome length / median bacterial genome length mutate(length_ratio = length/median(length, na.rm = TRUE)) # How many genomes are circularised? sum(genome_quality$circularity == 1) 2.5 Merged Genome (MAGs) taxonomy &amp; quality Merge taxonomy, length and quality information. Combine taxonomy and quality data into a single metadata object # combine taxonomy &amp; quality into one df genome_metadata &lt;- genome_taxonomy %&gt;% left_join(genome_quality, by = join_by(genome == genome)) # replace - with _ in the order names genome_metadata$order &lt;- gsub(&quot;-&quot;, &quot;_&quot;, genome_metadata$order) # order the genome metadata rows based on the order of the tree genome_metadata &lt;- genome_metadata[match(genome_tree$tip.label, genome_metadata$genome), ] 2.6 Factoring of taxonomic levels Create metadata summaries for phylum and order levels phylum_metadata &lt;- genome_metadata %&gt;% group_by(phylum) %&gt;% summarize( # Count the microsamples `number_of_genera` = n_distinct(genus), # Collect unique values separated by commas genus = paste(unique(genus), collapse = &quot;, &quot;), phylum = paste(unique(phylum), collapse = &quot;, &quot;), .groups = &quot;drop&quot;) %&gt;% select(phylum, number_of_genera, genus) %&gt;% # Preserve original order arrange(match(phylum, unique(genome_metadata$phylum))) order_metadata &lt;- genome_metadata %&gt;% group_by(order) %&gt;% summarize( # Count the microsamples `number_of_genera` = n_distinct(genus), # Collect unique values separated by commas genus = paste(unique(genus), collapse = &quot;, &quot;), phylum = paste(unique(phylum), collapse = &quot;, &quot;), class = paste(unique(class), collapse = &quot;, &quot;), # Ensure the dataframe is ungrouped .groups = &quot;drop&quot;) %&gt;% select(phylum, class, order, number_of_genera, genus) %&gt;% # Preserve original order arrange(match(order, unique(genome_metadata$order))) phylum_level_vector &lt;- as.character(unique(phylum_metadata$phylum)) order_level_vector &lt;- as.character(unique(order_metadata$order)) 2.7 Genome (MAGs) functional annotations This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR. Load functional annotations from DRAM genome_annotations &lt;- read_tsv(&quot;data/MAG_catalogue/dram.annotations.tsv.gz&quot;, show_col_types = FALSE) %&gt;% rename(gene = 1, genome = 2) %&gt;% filter(genome %in% selected_genomes) 2.7.1 Distil functional annotations Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses. Distill functional annotations into GIFT data genome_gifts &lt;- distill(genome_annotations, GIFT_db, genomecol = 2, annotcol = c(9, 10, 19)) 2.8 Bacterial phyla color scheme data 2.8.1 Define color schemes for phyla and orders phylum_colors &lt;- c(Actinomycetota = &quot;#346254&quot;, Bacillota = &quot;#4a6ab7&quot;, Bacillota_A = &quot;#8c1c47&quot;, Bacillota_B = &quot;#644ca3&quot;, Bacteroidota = &quot;#9c8464&quot;, Pseudomonadota = &quot;#c49d4b&quot;, Verrucomicrobiota = &quot;#462410&quot;, Cyanobacteriota = &quot;#b45f06&quot;) order_colors &lt;- c(Mycobacteriales = &quot;#79b1a3&quot;, Coriobacteriales = &quot;#498a77&quot;, Acholeplasmatales = &quot;#cfe2f3&quot;, CAJFEE01 = &quot;#a0c5e8&quot;, Erysipelotrichales = &quot;#7acef4&quot;, Haloplasmatales = &quot;#70c2e5&quot;, Lactobacillales = &quot;#6390fb&quot;, ML615J_28 = &quot;#70c9de&quot;, RF39 = &quot;#5c7fba&quot;, Staphylococcales = &quot;#70a8dc&quot;, Christensenellales = &quot;#f58262&quot;, Clostridiales = &quot;#cf4a82&quot;, Lachnospirales = &quot;#e15f7d&quot;, Monoglobales = &quot;#e18299&quot;, Oscillospirales = &quot;#ba2760&quot;, Peptostreptococcales = &quot;#e35d51&quot;, TANB77 = &quot;#ef3d26&quot;, UBA1381 = &quot;#be5643&quot;, UBA1212 = &quot;#cc0100&quot;, Peptococcales = &quot;#d9d2e9&quot;, UBA4068 = &quot;#b4a7d6&quot;, Bacteroidales = &quot;#e3c7a0&quot;, Enterobacterales = &quot;#ffcc62&quot;, Verrucomicrobiales = &quot;#823f1d&quot;, Gastranaerophilales = &quot;#bf9001&quot; ) 2.8.2 Define plotting settings Create custom ggplot theme for consistent plotting custom_ggplot_theme &lt;- theme( strip.text.y.left = element_text(angle = 0), strip.text.y.right = element_text(angle = 0), axis.text = element_text(size = 10), axis.title = element_text(size = 12, face = &quot;bold&quot;), strip.background = element_rect(fill = &quot;#dde3e9&quot;, color = &quot;white&quot;, size = 0.8), # Custom facet strip background strip.text = element_text(size = 8, face = &quot;bold&quot;, color = &quot;black&quot;), # Custom facet text strip.placement = &quot;outside&quot;, # Place strip outside the panel grid panel.spacing = unit(0.1, &quot;lines&quot;), # Adjust space between panels panel.grid.major = element_line(color = &quot;#dde3e9&quot;), # Customize major grid lines panel.grid.minor = element_blank(), # Remove minor grid lines panel.background = element_rect(fill = &quot;white&quot;), # Change panel background color plot.margin = unit(c(1, 1, 1, 1), &quot;cm&quot;) # Adjust plot margins to ensure content fits ) 2.8.3 Define treatment color schemes # Bright colors (opaque) treatment_colours_bright &lt;- c( TM1 = &quot;#4059AE&quot;, TM2 = &quot;#6A9AC3&quot;, TM3 = &quot;#97D8C4&quot;, TM4 = &quot;#F3B942&quot;, TM0 = &quot;grey&quot; ) # Pastel / transparent (for fill, with ~50% opacity) treatment_colours_pastel &lt;- paste0(treatment_colours_bright, &quot;50&quot;) 2.9 Save working objects In the last step, the objects that are needed for downstream analyses are stored in an R object. Save MAG catalogue data and color schemes save( genome_tree, genome_metadata, phylum_metadata, order_metadata, genome_gifts, file = &quot;data/MAG_catalogue/data.Rdata&quot; ) save( phylum_colors, order_colors, treatment_colours_bright, treatment_colours_pastel, custom_ggplot_theme, file = &quot;data/data_colors.Rdata&quot; ) 2.10 Validation Validate MAG catalogue data # Check dimensions of genome_metadata cat(&quot;Genome metadata dimensions:\\n&quot;) print(dim(genome_metadata)) cat(&quot;\\nNumber of genomes:&quot;, nrow(genome_metadata), &quot;\\n&quot;) cat(&quot;Number of columns:&quot;, ncol(genome_metadata), &quot;\\n\\n&quot;) # Check column names cat(&quot;Column names:\\n&quot;) print(colnames(genome_metadata)) cat(&quot;\\n&quot;) # Display top 10 rows cat(&quot;Top 10 rows of genome_metadata:\\n&quot;) knitr::kable(head(genome_metadata, 10)) cat(&quot;\\n&quot;) # Count circularized genomes circularized_count &lt;- sum(genome_quality$circularity == &quot;1&quot;) cat(&quot;Number of circularized genomes:&quot;, circularized_count, &quot;\\n\\n&quot;) # Count phyla and orders cat(&quot;Number of unique phyla:&quot;, length(phylum_level_vector), &quot;\\n&quot;) cat(&quot;Number of unique orders:&quot;, length(order_level_vector), &quot;\\n\\n&quot;) # Summary of phyla cat(&quot;Phyla summary:\\n&quot;) knitr::kable(table(genome_metadata$phylum)) cat(&quot;\\n&quot;) # Summary of orders cat(&quot;Number of genomes per order (top 10):\\n&quot;) order_counts &lt;- table(genome_metadata$order) knitr::kable(head(sort(order_counts, decreasing = TRUE), 10)) "],["micro-sample-metadata.html", "3 Micro-sample Metadata 3.1 Load and process micro-sample metadata from Airtable 3.2 Save working objects 3.3 Validation", " 3 Micro-sample Metadata Import sample metadata from the Airtable. Get base ID from Airtable browser URL. Eventually we should download these data. 3.1 Load and process micro-sample metadata from Airtable sample_metadata &lt;- airtable(&quot;4-MSE-Info&quot;, &quot;appKakM1bnKSekwuW&quot;) %&gt;% # select fields to extract read_airtable(., fields = c( &quot;ID&quot;, &quot;LabBatch_text&quot;, &quot;IntestinalSection&quot;, &quot;SampleType&quot;, &quot;Xcoord&quot;, &quot;Ycoord&quot;, &quot;SizeApprox&quot;, &quot;cryosection_text&quot;, &quot;buffer_text&quot;, &quot;Collection_Success&quot;, &quot;Collection_attempts&quot;, &quot;UsedCycles&quot;, &quot;animal_temp&quot;, &quot;Protocol_text&quot;, &quot;Collection_method_text&quot;, &quot;Treatment_from_Sample&quot;, &quot;SeriesDayCount_from_Sample&quot; ), id_to_col = TRUE) %&gt;% # select relevant batches filter(LabBatch_text %in% c(&quot;MSEB0042&quot;, &quot;MSEB0043&quot;, &quot;MSEB0044&quot;, &quot;MSEB0045&quot;, &quot;MSEB0046&quot;, &quot;MSEB0047&quot;, &quot;MSEB0048&quot;, &quot;MSEB0049&quot;, &quot;MSEB0050&quot;, &quot;MSEB0051&quot;, &quot;MSEB0052&quot;, &quot;MSEB0053&quot;, &quot;MSEB0054&quot;, &quot;MSEB0055&quot;)) %&gt;% # rename columns rename( batch = LabBatch_text, microsample = ID, section = IntestinalSection, type = SampleType, cryosection = cryosection_text, buffer = buffer_text, collection = Collection_Success, collection_attempts = Collection_attempts, cycles = UsedCycles, animal = animal_temp, size = SizeApprox, protocol = Protocol_text, collection_method = Collection_method_text, treatment = Treatment_from_Sample, day = SeriesDayCount_from_Sample ) %&gt;% # select relevant columns select( microsample, section, type, batch, cryosection, buffer, Xcoord, Ycoord, size, collection, collection_attempts, cycles, animal, protocol, collection_method, treatment, day ) %&gt;% # unnest columns that appeared as a list unnest(c(section, Xcoord, Ycoord, size, collection, cycles, collection_method, treatment, day)) %&gt;% # create new column with simplified type by taking first letter # P = Positive, N = Negative collection/reaction/membrane, C = Control Human mutate(type_simple = substr(type, 1, 1)) %&gt;% mutate(age = factor(day, levels = c(0, 7, 9, 12, 14, 21))) %&gt;% mutate(age_category = case_when( age == 0 ~ &quot;a&quot;, age == 7 ~ &quot;b&quot;, age %in% c(9, 12, 14) ~ &quot;c&quot;, age == 21 ~ &quot;d&quot;, TRUE ~ NA_character_ # Handles any unexpected values )) %&gt;% mutate( treatment_expl = case_when( treatment == &quot;TM1&quot; ~ &quot;VaccinatedCloacal&amp;Histomonas&quot;, treatment == &quot;TM2&quot; ~ &quot;VaccinatedOral&amp;Histomonas&quot;, treatment == &quot;TM3&quot; ~ &quot;OnlyHistomonas&quot;, treatment == &quot;TM4&quot; ~ &quot;ControlGroup&quot;, treatment == &quot;TM0&quot; ~ &quot;LabControl&quot;) ) %&gt;% # order df by microsample arrange(microsample) 3.2 Save working objects Save micro-sample metadata save( sample_metadata, file = &quot;data/micro/sample_metadata.Rdata&quot; ) 3.3 Validation Validate micro-sample metadata # Check dimensions cat(&quot;Sample metadata dimensions:\\n&quot;) print(dim(sample_metadata)) cat(&quot;\\nNumber of samples:&quot;, nrow(sample_metadata), &quot;\\n&quot;) cat(&quot;Number of columns:&quot;, ncol(sample_metadata), &quot;\\n\\n&quot;) # Check column names cat(&quot;Column names:\\n&quot;) print(colnames(sample_metadata)) cat(&quot;\\n&quot;) # Display top 10 rows cat(&quot;Top 10 rows of sample_metadata:\\n&quot;) knitr::kable(head(sample_metadata, 10)) cat(&quot;\\n&quot;) # Summary statistics for each column cat(&quot;Summary of unique values per column:\\n&quot;) for (col in colnames(sample_metadata)) { if (is.factor(sample_metadata[[col]]) || is.character(sample_metadata[[col]])) { cat(&quot;\\n&quot;, col, &quot;:\\n&quot;) knitr::kable(table(sample_metadata[[col]], useNA = &quot;ifany&quot;)) } else if (is.numeric(sample_metadata[[col]])) { cat(&quot;\\n&quot;, col, &quot;:\\n&quot;) cat(&quot; Min:&quot;, min(sample_metadata[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Max:&quot;, max(sample_metadata[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Mean:&quot;, mean(sample_metadata[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Unique values:&quot;, length(unique(sample_metadata[[col]])), &quot;\\n&quot;) } } cat(&quot;\\n&quot;) # Visualizations # Animals per batch cat(&quot;Animals per batch:\\n&quot;) animals_per_batch &lt;- sample_metadata %&gt;% group_by(batch) %&gt;% summarise(n_animals = n_distinct(animal), .groups = &quot;drop&quot;) knitr::kable(animals_per_batch) cat(&quot;\\n&quot;) # Animals per treatment cat(&quot;Animals per treatment:\\n&quot;) animals_per_treatment &lt;- sample_metadata %&gt;% group_by(treatment) %&gt;% summarise(n_animals = n_distinct(animal), .groups = &quot;drop&quot;) knitr::kable(animals_per_treatment) cat(&quot;\\n&quot;) # Treatment per day cat(&quot;Samples per treatment and day:\\n&quot;) treatment_per_day &lt;- sample_metadata %&gt;% group_by(treatment, day) %&gt;% summarise(n_samples = n(), .groups = &quot;drop&quot;) knitr::kable(treatment_per_day) cat(&quot;\\n&quot;) # Type validation: Check that &quot;NegativeCollection&quot; or &quot;NegativeReaction&quot; have NA for Xcoord, Ycoord, collection, and size cat(&quot;Type validation:\\n&quot;) negative_types &lt;- c(&quot;NegativeCollection&quot;, &quot;NegativeReaction&quot;) positive_types &lt;- c(&quot;NegativeMembrane&quot;, &quot;Positive&quot;) # Check negative types should have NA for coordinates, collection, and size negative_samples &lt;- sample_metadata %&gt;% filter(type %in% negative_types) if (nrow(negative_samples) &gt; 0) { cat(&quot;\\nChecking negative types (should have NA for Xcoord, Ycoord, collection, size):\\n&quot;) problems_negative &lt;- negative_samples %&gt;% filter(!is.na(Xcoord) | !is.na(Ycoord) | !is.na(collection) | !is.na(size)) if (nrow(problems_negative) &gt; 0) { cat(&quot;WARNING: Found&quot;, nrow(problems_negative), &quot;negative samples with non-NA values:\\n&quot;) knitr::kable(problems_negative %&gt;% select(microsample, batch, animal, type, Xcoord, Ycoord, collection, size)) } else { cat(&quot;OK: All negative types have NA for Xcoord, Ycoord, collection, and size\\n&quot;) } } # Check positive types should have values for coordinates, collection, and size positive_samples &lt;- sample_metadata %&gt;% filter(type %in% positive_types) if (nrow(positive_samples) &gt; 0) { cat(&quot;\\nChecking positive types (should have values for Xcoord, Ycoord, collection, size):\\n&quot;) problems_positive &lt;- positive_samples %&gt;% filter(is.na(Xcoord) | is.na(Ycoord) | is.na(collection) | is.na(size)) if (nrow(problems_positive) &gt; 0) { cat(&quot;WARNING: Found&quot;, nrow(problems_positive), &quot;positive samples with NA values:\\n&quot;) knitr::kable(problems_positive %&gt;% select(microsample, batch, animal, cryosection, type, Xcoord, Ycoord, collection, size)) } else { cat(&quot;OK: All positive types have values for Xcoord, Ycoord, collection, and size\\n&quot;) } } "],["micro-sample-counts.html", "4 Micro-sample Counts 4.1 Load required data 4.2 Bacterial reads (counts) 4.3 Genome covered bases 4.4 Filter and normalise data 4.5 Alpha diversity calculations 4.6 Save working objects 4.7 Validation", " 4 Micro-sample Counts This document contains the number of sequencing reads from each sample that have been mapped to each MAG. Note that these are raw data that need to be further processed before running any statistics on them. Location on ERDA: Batches MSEB0042-MSEB0045 ID: XXX Path: 3D-omics/processed_data/MSEB42-45-mg_quant/results/ Access: read Need updating! read_counts: https://sid.erda.dk/share_redirect/XXX/results/quantify/coverm/genome.count.REF0029-m_mg_hybrid-drep.0.95.tsv.gz genome_covered_bases: https://sid.erda.dk/share_redirect/XXX/results/quantify/coverm/genome.covered_bases.REF0029-m_mg_hybrid-drep.0.95.tsv.gz 4.1 Load required data Load genome metadata and sample metadata load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) 4.2 Bacterial reads (counts) Load read counts from mapping results read_counts_df &lt;- read_tsv( &quot;data/micro/MSEB0042_59/genome.count.REF0029-m_mg_hybrid-drep.0.95.tsv.gz&quot;, show_col_types = FALSE) %&gt;% # rename first column to &#39;genome&#39; rename(genome = 1) %&gt;% # pivot to a long 2-column table (columns: data, counts) pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% # make new column (&#39;sample&#39;) from column &#39;data&#39;, by keeping the first 7 characters - i.e. remove the .lib1 ending mutate(sample = substr(data, 1, 7)) %&gt;% # filter to only keep microsamples starting from M (so, remove the &#39;undetermined&#39; ) filter(grepl(&quot;^M&quot;, sample)) %&gt;% # sum counts from same genome-sample group (i.e. for MSEB0009 &amp; MSEB0010) group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% # make table wide again (i.e. columns become sample) pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) %&gt;% # sort genomes based on the order of the genome metadata df arrange(match(genome,genome_metadata$genome)) %&gt;% # Keep only the microsamples present in the metadata df as these data also include swine samples select(genome, all_of(sample_metadata$microsample)) Check reads mapping to the missing genome (MPB:bin_000147) read_counts_df %&gt;% filter(genome == &quot;MPB:bin_000147&quot;) %&gt;% select(where(is.numeric)) %&gt;% # keep only numeric columns sum() # 10567 reads in total map to the missing (in the tree) genome. So I will ignore it. Remove the missing genome from read counts read_counts &lt;- read_counts_df %&gt;% filter(genome != &quot;MPB:bin_000147&quot;) 4.3 Genome covered bases This is the document containing the number of nucleotide bases that have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. Load genome covered bases data genome_covered_bases &lt;- read_tsv(&quot;data/micro/MSEB0042_59/genome.covered_bases.REF0029-m_mg_hybrid-drep.0.95.tsv.gz&quot;, show_col_types = FALSE) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) %&gt;% arrange(match(genome, read_counts$genome)) %&gt;% # Keep only the microsamples present in the metadata df as these data also include swine samples select(genome, all_of(sample_metadata$microsample)) genome_covered_bases &lt;- genome_covered_bases %&gt;% filter(genome != &quot;MPB:bin_000147&quot;) 4.4 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. Calculate genome coverage by dividing covered bases by genome length genome_coverage &lt;- genome_covered_bases %&gt;% mutate(across(where(is.numeric), ~ . / genome_metadata$length)) 4.4.1 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. Apply 30% coverage filter to remove low-coverage genomes min_coverage &lt;- 0.3 read_counts_filt_30 &lt;- genome_coverage %&gt;% # turn entries of &lt;0.3 to 0, keep the rest to 1 mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% # to all columns except first (genomes), multiply read_counts with the number (0 or 1) mutate(across(-1, ~ . * read_counts[[cur_column()]])) 4.4.2 Generate genome count table Read counts are transformed into genome counts using genome-length and read-length information. Explanation: Read counts are influenced by sequencing depth and genome size. Larger genomes will naturally attract more reads than smaller ones, even if their actual abundance is the same. By normalizing read counts to genome size, genome counts provide a size-independent estimate of how many genome copies (or organisms carrying that genome) are present in a sample. Convert read counts to genome counts by normalizing for genome length readlength &lt;- 150 # change if sequencing read length is different # Reads without low-coverage filtering: genome_counts &lt;- read_counts %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) #Reads after filtering the low-coverage reads: genome_counts_filt_30 &lt;- read_counts_filt_30 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) Identify samples retained vs excluded by the 30% coverage filtering # Find which samples are retained vs excluded by the 30% coverage filtering genome_counts_filt_30_zerosrem &lt;- genome_counts_filt_30 %&gt;% # select columns that are not all zeros select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) %&gt;% filter(rowSums(select(., where(is.numeric)) != 0) &gt; 0) # Vector of retained sample names retained_samples_filt_30 &lt;- colnames(genome_counts_filt_30_zerosrem)[-1] 4.4.3 Generate length-corrected read count tables Create length-corrected read count tables c_read_counts &lt;- read_counts %&gt;% mutate(across(where(is.numeric), ~ round(. / genome_metadata$length_ratio))) c_read_counts_filt_30 &lt;- read_counts_filt_30 %&gt;% mutate(across(where(is.numeric), ~ round(. / genome_metadata$length_ratio))) 4.5 Alpha diversity calculations Estimate the alpha diversity on the unfiltered and the coverage-filtered counts. Calculate alpha diversity for unfiltered and filtered data # Load genome tree for phylogenetic diversity calculation load(&quot;data/MAG_catalogue/data.Rdata&quot;) # Calculate alpha diversity for unfiltered data alpha_div_unfiltered &lt;- calculate_alpha_diversity( input_data = genome_counts, dataset_name = &quot;unfiltered&quot;) %&gt;% mutate(filter_level = &quot;unfiltered&quot;) # Calculate alpha diversity for filtered data alpha_div_filtered_30 &lt;- calculate_alpha_diversity( input_data = genome_counts_filt_30, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_30&quot;) Combine alpha diversity metrics with metadata # Combine unfiltered and filtered alpha diversity # Note: final_combined_stats will be joined later in 01Bc when creating plot_data_stats alpha_diversity &lt;- bind_rows(alpha_div_unfiltered, alpha_div_filtered_30) %&gt;% left_join(sample_metadata, by = &quot;microsample&quot;) %&gt;% mutate(filter_level = factor(filter_level, levels = c(&quot;unfiltered&quot;,&quot;filtered_30&quot;))) 4.6 Save working objects Save micro-sample count data # Save counts-related objects to separate file save( read_counts, read_counts_filt_30, genome_coverage, genome_counts, genome_counts_filt_30, genome_counts_filt_30_zerosrem, retained_samples_filt_30, c_read_counts, c_read_counts_filt_30, alpha_div_unfiltered, alpha_div_filtered_30, alpha_diversity, file = &quot;data/micro/counts.Rdata&quot; ) 4.7 Validation Validate micro-sample counts data # Check dimensions match between read_counts and sample_metadata cat(&quot;Read counts dimensions:\\n&quot;) print(dim(read_counts)) cat(&quot;\\nSample metadata dimensions:\\n&quot;) print(dim(sample_metadata)) cat(&quot;\\n&quot;) # Check that sample columns in read_counts match sample_metadata cat(&quot;Checking sample alignment:\\n&quot;) samples_in_counts &lt;- colnames(read_counts)[-1] # exclude &#39;genome&#39; column samples_in_metadata &lt;- sample_metadata$microsample missing_in_counts &lt;- setdiff(samples_in_metadata, samples_in_counts) missing_in_metadata &lt;- setdiff(samples_in_counts, samples_in_metadata) if (length(missing_in_counts) &gt; 0) { cat(&quot;WARNING: Samples in metadata but not in counts:&quot;, length(missing_in_counts), &quot;\\n&quot;) knitr::kable(data.frame(missing_samples = head(missing_in_counts, 10))) } else { cat(&quot;OK: All metadata samples present in counts\\n&quot;) } if (length(missing_in_metadata) &gt; 0) { cat(&quot;WARNING: Samples in counts but not in metadata:&quot;, length(missing_in_metadata), &quot;\\n&quot;) knitr::kable(data.frame(missing_samples = head(missing_in_metadata, 10))) } else { cat(&quot;OK: All count samples present in metadata\\n&quot;) } cat(&quot;\\n&quot;) # Check filtering results cat(&quot;Filtering statistics:\\n&quot;) cat(&quot;Number of samples before filtering:&quot;, ncol(read_counts) - 1, &quot;\\n&quot;) cat(&quot;Number of samples after filtering (retained):&quot;, length(retained_samples_filt_30), &quot;\\n&quot;) cat(&quot;Number of samples excluded by filtering:&quot;, (ncol(read_counts) - 1) - length(retained_samples_filt_30), &quot;\\n\\n&quot;) # Coverage statistics cat(&quot;Coverage statistics:\\n&quot;) coverage_values &lt;- as.vector(as.matrix(genome_coverage[, -1])) coverage_values &lt;- coverage_values[!is.na(coverage_values) &amp; coverage_values &gt; 0] cat(&quot; Mean coverage:&quot;, mean(coverage_values), &quot;\\n&quot;) cat(&quot; Median coverage:&quot;, median(coverage_values), &quot;\\n&quot;) cat(&quot; Min coverage:&quot;, min(coverage_values), &quot;\\n&quot;) cat(&quot; Max coverage:&quot;, max(coverage_values), &quot;\\n&quot;) cat(&quot; Number of genome-sample pairs with &gt;30% coverage:&quot;, sum(coverage_values &gt; 0.3), &quot;\\n&quot;) cat(&quot; Number of genome-sample pairs with &lt;=30% coverage:&quot;, sum(coverage_values &lt;= 0.3 &amp; coverage_values &gt; 0), &quot;\\n\\n&quot;) # Check genome counts cat(&quot;Genome counts summary:\\n&quot;) cat(&quot; Number of genomes:&quot;, nrow(genome_counts), &quot;\\n&quot;) cat(&quot; Mean genomes per sample (unfiltered):&quot;, mean(colSums(genome_counts[, -1] &gt; 0, na.rm = TRUE)), &quot;\\n&quot;) cat(&quot; Mean genomes per sample (filtered):&quot;, mean(colSums(genome_counts_filt_30[, -1] &gt; 0, na.rm = TRUE)), &quot;\\n&quot;) "],["micro-sample-sequencing-statistics.html", "5 Micro-sample Sequencing Statistics 5.1 Load required data 5.2 FastP sequencing statistics 5.3 Non-bacterial mapped reads: human, chicken, swine, turkey, histomonas 5.4 Bacterial mapped reads 5.5 Alternative way to estimate bacterial read counts (from count table) 5.6 Sanity checks 5.7 Combine relevant sequencing statistics 5.8 Create plot_data_stats 5.9 Save working objects 5.10 Validation", " 5 Micro-sample Sequencing Statistics Batches MSEB0042-MSEB0045 ID: XXX Path: 3D-omics/processed_data/MSEB42-45-mg_quant/results/ Access: read Download preprocess_data.zip &amp; place in appropriate directory. 5.1 Load required data Load sample metadata, read counts, and genome metadata load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/counts.Rdata&quot;) load(&quot;data/MAG_catalogue/data.Rdata&quot;) 5.2 FastP sequencing statistics Get the multiqc_fastp.txt: FastP results, including QC. Packed in JSON format. (Does not contain gc and % unique content for before trimming.) Load and process FastP sequencing statistics fastp_seq_stats &lt;- read_tsv(&quot;data/micro/MSEB0042_59/preprocess_data/multiqc_fastp.txt&quot;, col_select = c(&quot;Sample&quot;, &quot;summary&quot;, &quot;duplication&quot;, &quot;filtering_result&quot;, &quot;adapter_cutting&quot;), show_col_types = FALSE) %&gt;% mutate(Sample = str_extract(Sample, &quot;M\\\\d+&quot;)) %&gt;% mutate(duplication = as.numeric(gsub(&quot;.*:\\\\s*([0-9\\\\.]+).*&quot;, &quot;\\\\1&quot;, duplication))) %&gt;% rename(microsample = Sample) %&gt;% # Keep only microsamples present in the sample_metadata filter(microsample %in% sample_metadata$microsample) %&gt;% mutate( summary_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, summary), total_sequences_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$total_reads), total_bases_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$total_bases), percent_gc_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$gc_content), total_sequences_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$total_reads), total_bases_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$total_bases), percent_gc_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$gc_content) ) %&gt;% mutate( adaptor_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, adapter_cutting), adapter_trimmed_reads = map_dbl(adaptor_clean, ~ fromJSON(.)$adapter_trimmed_reads), adapter_trimmed_bases = map_dbl(adaptor_clean, ~ fromJSON(.)$adapter_trimmed_bases) ) %&gt;% mutate( filtering_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, filtering_result), passed_filter_reads = map_dbl(filtering_clean, ~ fromJSON(.)$passed_filter_reads), low_quality_reads = map_dbl(filtering_clean, ~ fromJSON(.)$low_quality_reads), too_many_N_reads = map_dbl(filtering_clean, ~ fromJSON(.)$too_many_N_reads), too_short_reads = map_dbl(filtering_clean, ~ fromJSON(.)$too_short_reads) ) %&gt;% select(-summary_clean,-summary, -adaptor_clean, -filtering_result, -filtering_clean) %&gt;% filter(grepl(&quot;^M&quot;, microsample)) %&gt;% group_by(microsample) %&gt;% summarise( total_sequences_before_trim = sum(total_sequences_before_trim, na.rm = TRUE), total_bases_before_trim = sum(total_bases_before_trim, na.rm = TRUE), total_sequences_after_trim = sum(total_sequences_after_trim, na.rm = TRUE), total_bases_after_trim = sum(total_bases_after_trim, na.rm = TRUE), percent_gc_before_trim = mean(percent_gc_before_trim, na.rm = TRUE)*100, percent_gc_after_trim = mean(percent_gc_after_trim, na.rm = TRUE), duplication = mean(duplication, na.rm = TRUE)*100, adapter_trimmed_reads = sum(adapter_trimmed_reads, na.rm = TRUE), adapter_trimmed_bases = sum(adapter_trimmed_bases, na.rm = TRUE), passed_filter_reads = sum(passed_filter_reads, na.rm = TRUE), low_quality_reads = sum(low_quality_reads, na.rm = TRUE), too_many_N_reads = sum(too_many_N_reads, na.rm = TRUE), too_short_reads = sum(too_short_reads, na.rm = TRUE) ) 5.3 Non-bacterial mapped reads: human, chicken, swine, turkey, histomonas Get the multiqc_samtools_stats.txt. This is calculated on the trimmed reads. The reads are mapped to these references: 1. turkey (Turkey_5.1), 2. histomonas (Hmelea), 3. chicken (GRCg7b), 4. human (GRCh38), and 5. swine (Sscrofa11.1)) sequentially. To find the number of reads mapped to each reference you have to either - estimate number from the columns: reads_mapped + (reads_mapped - reads_mapped_and_paired) OR - subtract the number of reads that entered the analysis (e.g. column ‘total_passed’ of human - from column ‘total_passed’ of chicken = reads mapped to human). If you try both, these numbers should be equal. Load and process non-bacterial mapping statistics stats_non_bacteria_mapping &lt;- read_tsv(&quot;data/micro/MSEB0042_59/preprocess_data/multiqc_samtools_stats.txt&quot;, show_col_types = FALSE) %&gt;% # make new columns mutate(reference = case_when( # for type of reference based on reference code grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, grepl(&quot;Sscrofa11.1&quot;, Sample, ignore.case = TRUE) ~ &quot;swine&quot;, grepl(&quot;Hmelea&quot;, Sample, ignore.case = TRUE) ~ &quot;histomonas&quot;, grepl(&quot;Turkey_5.1&quot;, Sample, ignore.case = TRUE) ~ &quot;turkey&quot;, TRUE ~ NA_character_), # for microsample names microsample = str_extract(Sample, &quot;M\\\\d+&quot;), # for number of reads as input to each reference mapping chicken_total_passed = ifelse(reference == &quot;chicken&quot;, raw_total_sequences, NA_real_), human_total_passed = ifelse(reference == &quot;human&quot;, raw_total_sequences, NA_real_), swine_total_passed = ifelse(reference == &quot;swine&quot;, raw_total_sequences, NA_real_), turkey_total_passed = ifelse(reference == &quot;turkey&quot;, raw_total_sequences, NA_real_), histomonas_total_passed = ifelse(reference == &quot;histomonas&quot;, raw_total_sequences, NA_real_), # for number of reads that mapped to each reference chicken_total_mapped = ifelse(reference == &quot;chicken&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), human_total_mapped = ifelse(reference == &quot;human&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), swine_total_mapped = ifelse(reference == &quot;swine&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), turkey_total_mapped = ifelse(reference == &quot;turkey&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), histomonas_total_mapped = ifelse(reference == &quot;histomonas&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), # for unmapped reads after mapping to all three references swine_unmapped = ifelse(reference == &quot;swine&quot;, swine_total_passed - swine_total_mapped, NA_real_)) %&gt;% # select relevant columns select(microsample, chicken_total_passed, human_total_passed, swine_total_passed, turkey_total_passed, histomonas_total_passed, chicken_total_mapped, human_total_mapped, swine_total_mapped, turkey_total_mapped, histomonas_total_mapped, swine_unmapped) %&gt;% # Keep only microsamples present in the sample_metadata filter(microsample %in% sample_metadata$microsample) %&gt;% # sum reads for same microsample for each reference group_by(microsample) %&gt;% summarise(across( starts_with(&quot;turkey_&quot;) | starts_with(&quot;histomonas_&quot;) | starts_with(&quot;chicken_&quot;) | starts_with(&quot;human_&quot;) | starts_with(&quot;swine_&quot;), sum, na.rm = TRUE)) %&gt;% # keep microsamples starting with M (i.e., remove &#39;NA&#39; or &#39;undetermined&#39;) filter(grepl(&quot;^M&quot;, microsample)) 5.4 Bacterial mapped reads Download quantify.zip &amp; place in appropriate directory. Get the multiqc_samtools_stats.txt. This is calculated on the trimmed reads after filtering for turkey, histomonas, human, chicken, and pig reads. ‘Unmapped reads’ are trimmed reads that did not map to the turkey, histomonas, human, chicken, and swine references, or to the bacterial MAG catalogue. Load and process bacterial mapping statistics stats_bacteria_mapping &lt;- read_tsv(&quot;data/micro/MSEB0042_59/quantify/multiqc_samtools_stats.txt&quot;, show_col_types = FALSE) %&gt;% # select only the dereplicated to 95% (as the file includes also the 98% and 99%) filter(str_detect(Sample, &quot;drep\\\\.0\\\\.95&quot;)) %&gt;% # make new columns mutate( microsample = str_extract(Sample, &quot;M\\\\d+&quot;), bacteria_total_passed = raw_total_sequences, bacteria_total_mapped = reads_mapped, unmapped = reads_unmapped ) %&gt;% # Keep only microsamples present in the sample_metadata filter(microsample %in% sample_metadata$microsample) %&gt;% # sum reads of the same microsample because some samples were sequence multiple times group_by(microsample) %&gt;% summarise( bacteria_total_passed = sum(bacteria_total_passed, na.rm = TRUE), bacteria_total_mapped = sum(bacteria_total_mapped, na.rm = TRUE), unmapped = sum(unmapped, na.rm = TRUE) ) %&gt;% # select relevant columns select(microsample, bacteria_total_passed, bacteria_total_mapped, unmapped) %&gt;% # keep microsamples starting with M (i.e., remove &#39;NA&#39; or &#39;undetermined&#39;) filter(grepl(&quot;^M&quot;, microsample)) 5.5 Alternative way to estimate bacterial read counts (from count table) Calculate bacterial read counts from count table # Need to reload read_counts_df for this calculation read_counts_df &lt;- read_tsv( &quot;data/micro/MSEB0042_59/genome.count.REF0029-m_mg_hybrid-drep.0.95.tsv.gz&quot;, show_col_types = FALSE) %&gt;% rename(genome = 1) %&gt;% pivot_longer(!genome, names_to = &quot;data&quot;, values_to = &quot;counts&quot;) %&gt;% mutate(sample = substr(data, 1, 7)) %&gt;% filter(grepl(&quot;^M&quot;, sample)) %&gt;% group_by(genome, sample) %&gt;% summarise(counts = sum(counts), .groups = &quot;drop&quot;) %&gt;% pivot_wider(names_from = &quot;sample&quot;, values_from = &quot;counts&quot;) %&gt;% arrange(match(genome,genome_metadata$genome)) %&gt;% select(genome, all_of(sample_metadata$microsample)) # Use the read_counts_df, i.e. before I remove the 1 taxon that is missing from the tree. stats_bacteria_mapping_alternative &lt;- read_counts_df %&gt;% # Move genome names to rownames column_to_rownames(var = &quot;genome&quot;) %&gt;% # Transpose the data t() %&gt;% # Convert back to a data frame as.data.frame() %&gt;% # Move sample names into a column rownames_to_column(var = &quot;microsample&quot;) %&gt;% # sum the counts of all genomes in each sample (i.e., sum of each row) mutate(bacteria_total_read_counts = rowSums(select(., -microsample))) %&gt;% # select to show only the total_counts column select(microsample, bacteria_total_read_counts) %&gt;% # select only microsamples starting with &#39;M&#39; (i.e. not &#39;NA&#39; or &#39;Undetermined&#39;) filter(grepl(&quot;^M&quot;, microsample)) 5.6 Sanity checks Check if the two methods of counting bacterial reads agree: Compare bacterial mapping methods comparison_bacteria_mapping &lt;- stats_bacteria_mapping_alternative %&gt;% # Join on &#39;microsample&#39; inner_join(stats_bacteria_mapping, by = &quot;microsample&quot;) %&gt;% # Compare the two columns mutate(same_counts = bacteria_total_read_counts == bacteria_total_mapped) # Check if all values are the same # TRUE if all are the same, FALSE otherwise all(comparison_bacteria_mapping$same_counts) # Filter &amp; show rows where the counts between the two columns differ comparison_bacteria_mapping %&gt;% filter(!same_counts) %&gt;% mutate(difference = bacteria_total_read_counts- bacteria_total_mapped) %&gt;% select(microsample, bacteria_total_read_counts, bacteria_total_mapped, difference) Only 2 reads difference in sample M304439. Check if the output of swine (unmapped reads from swine mapping) and the input to bacteria (available reads that will map to MAG catalogue) is the same for all samples: Compare bacteria input with swine unmapped reads comparison_bacteria_input &lt;- stats_bacteria_mapping %&gt;% # Align rows by microsample inner_join(stats_non_bacteria_mapping, by = &quot;microsample&quot;) %&gt;% # Compare the two columns mutate(same_counts = bacteria_total_passed == swine_unmapped) # Check if all values are the same # TRUE if all are the same, FALSE otherwise all(comparison_bacteria_input$same_counts) # Filter &amp; show rows where the counts between the two columns differ comparison_bacteria_input %&gt;% filter(!same_counts) %&gt;% select(microsample, bacteria_total_passed, swine_unmapped) We find that everything is fine, no rows differ. 5.7 Combine relevant sequencing statistics Combine all sequencing statistics into a single dataframe stats_combined &lt;- reduce(list(fastp_seq_stats, stats_non_bacteria_mapping, stats_bacteria_mapping, stats_bacteria_mapping_alternative), full_join, by = &quot;microsample&quot;) %&gt;% filter(grepl(&quot;^M&quot;, microsample)) %&gt;% mutate(removed_sequences_after_trim = total_sequences_before_trim - total_sequences_after_trim) # estimate some percentages for easier plotting. final_combined_stats &lt;- stats_combined %&gt;% mutate( trimmed_reads_percentage = ((total_sequences_before_trim-total_sequences_after_trim)/total_sequences_before_trim)*100, human_percentage = (human_total_mapped/total_sequences_after_trim)*100, chicken_percentage = (chicken_total_mapped/total_sequences_after_trim)*100, swine_percentage = (swine_total_mapped/total_sequences_after_trim)*100, turkey_percentage = (turkey_total_mapped/total_sequences_after_trim)*100, histomonas_percentage = round((histomonas_total_mapped/total_sequences_after_trim)*100, 7), bacteria_percentage = (bacteria_total_mapped/total_sequences_after_trim)*100, unmapped_percentage = (unmapped/total_sequences_after_trim)*100, bacteria_percentage_enriched = (bacteria_total_mapped/(bacteria_total_mapped+unmapped)*100), adapter_contamination_pct = (adapter_trimmed_bases / total_bases_before_trim)*100, histomonas_over_bacteria = round((histomonas_total_mapped/bacteria_total_mapped),7), bacteria_over_turkey = (bacteria_total_mapped/turkey_total_mapped), unique_pct = 100-duplication ) %&gt;% # Keep only microsamples present in the sample_metadata filter(microsample %in% sample_metadata$microsample) Add filter_status column # Load retained_samples_filt_30 from counts data load(&quot;data/micro/counts.Rdata&quot;) # Add filter_status column to indicate which samples were retained by filtering final_combined_stats &lt;- final_combined_stats %&gt;% mutate(filter_status = if_else( microsample %in% retained_samples_filt_30, &quot;Retained by filtering&quot;, &quot;Excluded from filtering&quot; )) 5.8 Create plot_data_stats Combine sequencing statistics with sample metadata and alpha diversity for plotting. Create plot_data_stats with sequencing stats, metadata, and alpha diversity # Load alpha diversity data (already loaded in load_data chunk) # Combine sequencing stats with sample metadata and alpha diversity plot_data_stats &lt;- final_combined_stats %&gt;% left_join(alpha_div_filtered_30, by = join_by(microsample == microsample)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) 5.9 Save working objects Save sequencing statistics data # Save seq stats-related objects to separate file save( final_combined_stats, plot_data_stats, file = &quot;data/micro/seq_stats.Rdata&quot; ) 5.10 Validation Validate sequencing statistics # Check dimensions cat(&quot;Final combined stats dimensions:\\n&quot;) print(dim(final_combined_stats)) cat(&quot;\\nNumber of samples:&quot;, nrow(final_combined_stats), &quot;\\n\\n&quot;) # Check that sanity checks pass cat(&quot;Sanity check results:\\n&quot;) cat(&quot;Bacterial mapping methods agree:&quot;, all(comparison_bacteria_mapping$same_counts), &quot;\\n&quot;) if (!all(comparison_bacteria_mapping$same_counts)) { cat(&quot; Number of samples with differences:&quot;, sum(!comparison_bacteria_mapping$same_counts), &quot;\\n&quot;) knitr::kable(comparison_bacteria_mapping %&gt;% filter(!same_counts) %&gt;% mutate(difference = bacteria_total_read_counts - bacteria_total_mapped) %&gt;% select(microsample, bacteria_total_read_counts, bacteria_total_mapped, difference)) } cat(&quot;\\n&quot;) cat(&quot;Bacteria input matches swine unmapped:&quot;, all(comparison_bacteria_input$same_counts), &quot;\\n&quot;) if (!all(comparison_bacteria_input$same_counts)) { cat(&quot; Number of samples with differences:&quot;, sum(!comparison_bacteria_input$same_counts), &quot;\\n&quot;) knitr::kable(comparison_bacteria_input %&gt;% filter(!same_counts) %&gt;% select(microsample, bacteria_total_passed, swine_unmapped)) } cat(&quot;\\n&quot;) # Verify percentages sum correctly (should be close to 100% for read composition) cat(&quot;Percentage validation:\\n&quot;) # Check that percentages for read composition make sense sample_check &lt;- final_combined_stats %&gt;% mutate( total_pct_check = human_percentage + chicken_percentage + swine_percentage + turkey_percentage + histomonas_percentage + bacteria_percentage + unmapped_percentage ) %&gt;% select(microsample, total_sequences_after_trim, total_pct_check, human_percentage, chicken_percentage, swine_percentage, turkey_percentage, histomonas_percentage, bacteria_percentage, unmapped_percentage) cat(&quot;Mean total percentage (should be ~100):&quot;, mean(sample_check$total_pct_check, na.rm = TRUE), &quot;\\n&quot;) cat(&quot;Range of total percentage:&quot;, range(sample_check$total_pct_check, na.rm = TRUE), &quot;\\n\\n&quot;) # Check for anomalies cat(&quot;Anomaly checks:\\n&quot;) # Samples with very low bacterial percentage low_bacteria &lt;- final_combined_stats %&gt;% filter(bacteria_percentage &lt; 1) %&gt;% select(microsample, bacteria_percentage, total_sequences_after_trim) if (nrow(low_bacteria) &gt; 0) { cat(&quot;Samples with &lt;1% bacterial reads:&quot;, nrow(low_bacteria), &quot;\\n&quot;) knitr::kable(head(low_bacteria, 10)) } else { cat(&quot;OK: No samples with &lt;1% bacterial reads\\n&quot;) } cat(&quot;\\n&quot;) # Samples with very high unmapped percentage high_unmapped &lt;- final_combined_stats %&gt;% filter(unmapped_percentage &gt; 50) %&gt;% select(microsample, unmapped_percentage, total_sequences_after_trim) if (nrow(high_unmapped) &gt; 0) { cat(&quot;Samples with &gt;50% unmapped reads:&quot;, nrow(high_unmapped), &quot;\\n&quot;) knitr::kable(head(high_unmapped, 10)) } else { cat(&quot;OK: No samples with &gt;50% unmapped reads\\n&quot;) } cat(&quot;\\n&quot;) # Summary statistics cat(&quot;Summary statistics:\\n&quot;) cat(&quot; Mean bacterial percentage:&quot;, mean(final_combined_stats$bacteria_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean unmapped percentage:&quot;, mean(final_combined_stats$unmapped_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean histomonas percentage:&quot;, mean(final_combined_stats$histomonas_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean turkey percentage:&quot;, mean(final_combined_stats$turkey_percentage, na.rm = TRUE), &quot;%\\n&quot;) "],["macro-sample-metadata.html", "6 Macro-sample Metadata 6.1 Save working objects 6.2 Validation", " 6 Macro-sample Metadata Load and process macro-sample metadata from Airtable sample_metadata_macro &lt;- airtable(&quot;5-SE-Info&quot;, &quot;apphvsV2YKhTCMKGS&quot;) %&gt;% # select columns to extract read_airtable(., fields = c( &quot;ID&quot;, &quot;LabBatch_text&quot;, &quot;ExperimentalUnitIndexedLibrary&quot;, &quot;SampleTypeIndexedLibrary&quot;, &quot;TreatmentIndexedLibrary&quot;, &quot;AgeIndexedLibrary&quot;), id_to_col = TRUE) %&gt;% # rename columns rename( batch = &quot;LabBatch_text&quot;, sample = &quot;ID&quot;, animal = &quot;ExperimentalUnitIndexedLibrary&quot;, tissue = &quot;SampleTypeIndexedLibrary&quot;, treatment = &quot;TreatmentIndexedLibrary&quot;, age = &quot;AgeIndexedLibrary&quot; #Days Post Infection ) %&gt;% # select relevant batches filter(batch == &quot;S3B014&quot;) %&gt;% # select relevant columns select(sample, batch, animal, tissue, treatment, age) %&gt;% # un-nest columns that appeared as a list unnest(c(sample, batch, animal, tissue, treatment, age)) %&gt;% # order the column &#39;size&#39; - for plotting in correct order later mutate(age = factor(age, levels = c(0, 7, 9, 12, 14, 21))) %&gt;% mutate(age_category = case_when( age == 0 ~ &quot;a&quot;, age == 7 ~ &quot;b&quot;, age %in% c(9, 12, 14) ~ &quot;c&quot;, age == 21 ~ &quot;d&quot;, TRUE ~ NA_character_ # Handles any unexpected values )) %&gt;% mutate( treatment_expl = case_when( treatment == &quot;TM1&quot; ~ &quot;VaccinatedCloacal&amp;Histomonas&quot;, treatment == &quot;TM2&quot; ~ &quot;VaccinatedOral&amp;Histomonas&quot;, treatment == &quot;TM3&quot; ~ &quot;OnlyHistomonas&quot;, treatment == &quot;TM4&quot; ~ &quot;ControlGroup&quot;, treatment == &quot;TM0&quot; ~ &quot;LabControl&quot;) ) %&gt;% mutate( type_simple = case_when( treatment == &quot;TM0&quot; ~ &quot;N&quot;, treatment %in% c(&quot;TM1&quot;, &quot;TM2&quot;,&quot;TM3&quot;, &quot;TM4&quot;) ~ &quot;P&quot; )) %&gt;% # order df by sample arrange(sample) 6.1 Save working objects Save macro-sample metadata save( sample_metadata_macro, file = &quot;data/macro/sample_metadata.Rdata&quot; ) 6.2 Validation Validate macro-sample metadata # Check dimensions cat(&quot;Sample metadata dimensions:\\n&quot;) print(dim(sample_metadata_macro)) cat(&quot;\\nNumber of samples:&quot;, nrow(sample_metadata_macro), &quot;\\n&quot;) cat(&quot;Number of columns:&quot;, ncol(sample_metadata_macro), &quot;\\n\\n&quot;) # Check column names cat(&quot;Column names:\\n&quot;) print(colnames(sample_metadata_macro)) cat(&quot;\\n&quot;) # Display top 10 rows cat(&quot;Top 10 rows of sample_metadata_macro:\\n&quot;) knitr::kable(head(sample_metadata_macro, 10)) cat(&quot;\\n&quot;) # Summary statistics for each column cat(&quot;Summary of unique values per column:\\n&quot;) for (col in colnames(sample_metadata_macro)) { if (is.factor(sample_metadata_macro[[col]]) || is.character(sample_metadata_macro[[col]])) { cat(&quot;\\n&quot;, col, &quot;:\\n&quot;) knitr::kable(table(sample_metadata_macro[[col]], useNA = &quot;ifany&quot;)) } else if (is.numeric(sample_metadata_macro[[col]])) { cat(&quot;\\n&quot;, col, &quot;:\\n&quot;) cat(&quot; Min:&quot;, min(sample_metadata_macro[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Max:&quot;, max(sample_metadata_macro[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Mean:&quot;, mean(sample_metadata_macro[[col]], na.rm = TRUE), &quot;\\n&quot;) cat(&quot; Unique values:&quot;, length(unique(sample_metadata_macro[[col]])), &quot;\\n&quot;) } } cat(&quot;\\n&quot;) # Visualizations # Animals per batch cat(&quot;Animals per batch:\\n&quot;) animals_per_batch &lt;- sample_metadata_macro %&gt;% group_by(batch) %&gt;% summarise(n_animals = n_distinct(animal), .groups = &quot;drop&quot;) knitr::kable(animals_per_batch) cat(&quot;\\n&quot;) # Animals per treatment cat(&quot;Animals per treatment:\\n&quot;) animals_per_treatment &lt;- sample_metadata_macro %&gt;% group_by(treatment) %&gt;% summarise(n_animals = n_distinct(animal), .groups = &quot;drop&quot;) knitr::kable(animals_per_treatment) cat(&quot;\\n&quot;) # Treatment per day cat(&quot;Samples per treatment and day:\\n&quot;) treatment_per_day &lt;- sample_metadata_macro %&gt;% group_by(treatment, age) %&gt;% summarise( n_samples = n(), animals = paste(animal, collapse = &quot;, &quot;), day_codes = paste(age_category, collapse = &quot;, &quot;), .groups = &quot;drop&quot; ) knitr::kable(treatment_per_day) cat(&quot;\\n&quot;) # Treatment per day cat(&quot;Samples per treatment and day:\\n&quot;) treatment_per_day &lt;- sample_metadata_macro %&gt;% group_by(treatment, age_category) %&gt;% summarise( n_samples = n(), animals = paste(animal, collapse = &quot;, &quot;), .groups = &quot;drop&quot; ) knitr::kable(treatment_per_day) cat(&quot;\\n&quot;) # Tissue distribution cat(&quot;Samples per tissue type:\\n&quot;) tissue_dist &lt;- sample_metadata_macro %&gt;% group_by(tissue) %&gt;% summarise(n_samples = n(), .groups = &quot;drop&quot;) knitr::kable(tissue_dist) cat(&quot;\\n&quot;) "],["macro-sample-counts.html", "7 Macro-sample Counts 7.1 Load required data 7.2 Bacterial reads (counts) 7.3 Genome covered bases 7.4 Filter and normalise data 7.5 Alpha diversity calculations 7.6 Save working objects 7.7 Validation", " 7 Macro-sample Counts This document contains the number of sequencing reads from each sample that have been mapped to each MAG. Note that these are raw data that need to be further processed before running any statistics on them. Location on ERDA: m_mg_quant ID: XXX Path: 3D-omics/processed_data/m_mg_quant/results/ Access: read Find in coverm: genome.count.REF0029-m_mg_hybrid-drep.0.95.tsv.gz and genome.covered_bases.REF0029-m_mg_hybrid-drep.0.95.tsv.gz 7.1 Load required data Load genome metadata and sample metadata load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/macro/sample_metadata.Rdata&quot;) 7.2 Bacterial reads (counts) Load read counts from mapping results read_counts_macro &lt;- read_tsv(&quot;data/macro/genome.count.REF0029-m_mg_hybrid-drep.0.95.tsv.gz&quot;) %&gt;% #simplify column names rename_all(~ str_remove_all(., &quot;.lib1&quot;)) %&gt;% # rename first column to &#39;genome&#39; rename(genome = 1) %&gt;% select(all_of(c(&quot;genome&quot;,sample_metadata_macro$sample))) %&gt;% # sort samples # sort genomes based on the order of the genome metadata df arrange(match(genome,genome_metadata$genome)) # sort genomes read_counts_macro &lt;- read_counts_macro %&gt;% filter(genome != &quot;MPB:bin_000147&quot;) 7.3 Genome covered bases This is the document containing the number of nucleotide bases that have been covered by at least one read in each sample and MAG. This information is used to calculate MAG coverage values. Load genome covered bases data genome_covered_bases_macro &lt;- read_tsv(&quot;data/macro/genome.covered_bases.REF0029-m_mg_hybrid-drep.0.95.tsv.gz&quot;) %&gt;% #simplify column names rename_all(~ str_remove_all(., &quot;.lib1&quot;)) %&gt;% rename(genome = 1) %&gt;% # sort samples select(all_of(c(&quot;genome&quot;,sample_metadata_macro$sample))) %&gt;% # sort genomes arrange(match(genome,genome_metadata$genome)) genome_covered_bases_macro &lt;- genome_covered_bases_macro %&gt;% filter(genome != &quot;MPB:bin_000147&quot;) 7.4 Filter and normalise data Raw data needs to be filtered and normalised to make it useful for downstream analyses. 7.4.1 Generate coverage table By dividing the number of base hits by the length of each genome, coverage values can be calculated. Calculate genome coverage by dividing covered bases by genome length genome_coverage_macro &lt;- genome_covered_bases_macro %&gt;% mutate(across(where(is.numeric), ~ . / genome_metadata$length)) 7.4.2 Coverage filtering Genomes that have less than 30% of their length covered by reads are turned into zeros to account for the random allocation of reads across genomes due to mapping heuristics. Apply 30% coverage filter to remove low-coverage genomes min_coverage &lt;- 0.3 read_counts_macro_filt_30 &lt;- genome_coverage_macro %&gt;% mutate(across(where(is.numeric), ~ ifelse(. &gt; min_coverage, 1, 0))) %&gt;% mutate(across(-1, ~ . * read_counts_macro[[cur_column()]])) 7.4.3 Generate genome count table Read counts are transformed into genome counts using genome-length and read-length information. Explanation: Read counts are influenced by sequencing depth and genome size. Larger genomes will naturally attract more reads than smaller ones, even if their actual abundance is the same. By normalizing read counts to genome size, genome counts provide a size-independent estimate of how many genome copies (or organisms carrying that genome) are present in a sample. Convert read counts to genome counts by normalizing for genome length readlength &lt;- 150 # change if sequencing read length is different # Reads without low-coverage filtering: genome_counts_macro &lt;- read_counts_macro %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) #Reads after filtering the low-coverage reads: genome_counts_macro_filt_30 &lt;- read_counts_macro_filt_30 %&gt;% mutate(across(where(is.numeric), ~ . / (genome_metadata$length / readlength))) Identify samples retained vs excluded by the 30% coverage filtering # Find which samples are retained vs excluded by the 30% coverage filtering genome_counts_macro_filt_30_zerosrem &lt;- genome_counts_macro_filt_30 %&gt;% # select columns that are not all zeros select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) %&gt;% filter(rowSums(select(., where(is.numeric)) != 0) &gt; 0) # Vector of retained sample names retained_samples_macro_filt_30 &lt;- colnames(genome_counts_macro_filt_30_zerosrem)[-1] 7.4.4 Generate length-corrected read count tables c_read_counts_macro &lt;- read_counts_macro %&gt;% mutate(across(where(is.numeric), ~ round(. / genome_metadata$length_ratio))) c_read_counts_macro_filt_30 &lt;- read_counts_macro_filt_30 %&gt;% mutate(across(where(is.numeric), ~ round(. / genome_metadata$length_ratio))) 7.5 Alpha diversity calculations Estimate the alpha diversity on the unfiltered and the coverage-filtered counts. # Genome tree should already be loaded from MAG_catalogue/data.Rdata # Calculate alpha diversity for unfiltered data alpha_div_macro_unfiltered &lt;- calculate_alpha_diversity( input_data = genome_counts_macro, dataset_name = &quot;unfiltered&quot;) %&gt;% mutate(filter_level = &quot;unfiltered&quot;) # Calculate alpha diversity for filtered data alpha_div_macro_filtered_30 &lt;- calculate_alpha_diversity( input_data = genome_counts_macro_filt_30, dataset_name = &quot;filtered&quot;) %&gt;% mutate(filter_level = &quot;filtered_30&quot;) Combine alpha diversity metrics with metadata # Load sample metadata for joining (already loaded in load_data chunk) # Combine unfiltered and filtered alpha diversity # Note: final_combined_stats_macro will be joined later in 01Cc when creating plot_data_stats_macro alpha_diversity_macro &lt;- bind_rows( alpha_div_macro_unfiltered, alpha_div_macro_filtered_30) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) %&gt;% mutate(filter_level = factor(filter_level, levels = c(&quot;unfiltered&quot;, &quot;filtered_30&quot;))) 7.6 Save working objects Save macro-sample count data # Save counts-related objects to separate file save( read_counts_macro, read_counts_macro_filt_30, genome_coverage_macro, genome_counts_macro, genome_counts_macro_filt_30, genome_counts_macro_filt_30_zerosrem, retained_samples_macro_filt_30, c_read_counts_macro, c_read_counts_macro_filt_30, alpha_div_macro_unfiltered, alpha_div_macro_filtered_30, alpha_diversity_macro, file = &quot;data/macro/counts.Rdata&quot; ) 7.7 Validation Validate macro-sample counts data # Check dimensions match between read_counts and sample_metadata cat(&quot;Read counts dimensions:\\n&quot;) print(dim(read_counts_macro)) cat(&quot;\\nSample metadata dimensions:\\n&quot;) print(dim(sample_metadata_macro)) cat(&quot;\\n&quot;) # Check that sample columns in read_counts match sample_metadata cat(&quot;Checking sample alignment:\\n&quot;) samples_in_counts &lt;- colnames(read_counts_macro)[-1] # exclude &#39;genome&#39; column samples_in_metadata &lt;- sample_metadata_macro$sample missing_in_counts &lt;- setdiff(samples_in_metadata, samples_in_counts) missing_in_metadata &lt;- setdiff(samples_in_counts, samples_in_metadata) if (length(missing_in_counts) &gt; 0) { cat(&quot;WARNING: Samples in metadata but not in counts:&quot;, length(missing_in_counts), &quot;\\n&quot;) knitr::kable(data.frame(missing_samples = head(missing_in_counts, 10))) } else { cat(&quot;OK: All metadata samples present in counts\\n&quot;) } if (length(missing_in_metadata) &gt; 0) { cat(&quot;WARNING: Samples in counts but not in metadata:&quot;, length(missing_in_metadata), &quot;\\n&quot;) knitr::kable(data.frame(missing_samples = head(missing_in_metadata, 10))) } else { cat(&quot;OK: All count samples present in metadata\\n&quot;) } cat(&quot;\\n&quot;) # Check filtering results cat(&quot;Filtering statistics:\\n&quot;) cat(&quot;Number of samples before filtering:&quot;, ncol(read_counts_macro) - 1, &quot;\\n&quot;) cat(&quot;Number of samples after filtering (retained):&quot;, length(retained_samples_macro_filt_30), &quot;\\n&quot;) cat(&quot;Number of samples excluded by filtering:&quot;, (ncol(read_counts_macro) - 1) - length(retained_samples_macro_filt_30), &quot;\\n\\n&quot;) # Coverage statistics cat(&quot;Coverage statistics:\\n&quot;) coverage_values &lt;- as.vector(as.matrix(genome_coverage_macro[, -1])) coverage_values &lt;- coverage_values[!is.na(coverage_values) &amp; coverage_values &gt; 0] cat(&quot; Mean coverage:&quot;, mean(coverage_values), &quot;\\n&quot;) cat(&quot; Median coverage:&quot;, median(coverage_values), &quot;\\n&quot;) cat(&quot; Min coverage:&quot;, min(coverage_values), &quot;\\n&quot;) cat(&quot; Max coverage:&quot;, max(coverage_values), &quot;\\n&quot;) cat(&quot; Number of genome-sample pairs with &gt;30% coverage:&quot;, sum(coverage_values &gt; 0.3), &quot;\\n&quot;) cat(&quot; Number of genome-sample pairs with &lt;=30% coverage:&quot;, sum(coverage_values &lt;= 0.3 &amp; coverage_values &gt; 0), &quot;\\n\\n&quot;) # Check genome counts cat(&quot;Genome counts summary:\\n&quot;) cat(&quot; Number of genomes:&quot;, nrow(genome_counts_macro), &quot;\\n&quot;) cat(&quot; Mean genomes per sample (unfiltered):&quot;, mean(colSums(genome_counts_macro[, -1] &gt; 0, na.rm = TRUE)), &quot;\\n&quot;) cat(&quot; Mean genomes per sample (filtered):&quot;, mean(colSums(genome_counts_macro_filt_30[, -1] &gt; 0, na.rm = TRUE)), &quot;\\n&quot;) "],["macro-sample-sequencing-statistics.html", "8 Macro-sample Sequencing Statistics 8.1 Load required data 8.2 FastP sequencing statistics 8.3 Non-bacterial mapped reads: human, chicken, swine, turkey, histomonas 8.4 Bacterial mapped reads 8.5 Alternative way to estimate bacterial read counts (from count table) 8.6 Sanity checks 8.7 Combine relevant sequencing statistics 8.8 Create plot_data_stats_macro 8.9 Save working objects 8.10 Validation", " 8 Macro-sample Sequencing Statistics Remember to change M to D, as only microsamples start from M, and these are macro-samples. 8.1 Load required data Load sample metadata load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/macro/counts.Rdata&quot;) 8.2 FastP sequencing statistics Download preprocess_data.zip &amp; place in appropriate directory. Get the multiqc_fastp.txt: FastP results, including QC. Packed in JSON format. (Does not contain gc and % unique content for before trimming.) Load and process FastP sequencing statistics fastp_seq_stats_macro &lt;- read_tsv(&quot;data/macro/preprocess_data/multiqc_fastp.txt&quot;, col_select = c(&quot;Sample&quot;, &quot;summary&quot;, &quot;duplication&quot;, &quot;filtering_result&quot;, &quot;adapter_cutting&quot;), show_col_types = FALSE) %&gt;% mutate(Sample = str_extract(Sample, &quot;D\\\\d+&quot;))%&gt;% mutate(duplication = as.numeric(gsub(&quot;.*:\\\\s*([0-9\\\\.]+).*&quot;, &quot;\\\\1&quot;, duplication))) %&gt;% rename(microsample = Sample) %&gt;% mutate( summary_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, summary), total_sequences_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$total_reads), total_bases_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$total_bases), percent_gc_before_trim = map_dbl(summary_clean, ~ fromJSON(.)$before_filtering$gc_content), total_sequences_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$total_reads), total_bases_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$total_bases), percent_gc_after_trim = map_dbl(summary_clean, ~ fromJSON(.)$after_filtering$gc_content) ) %&gt;% mutate( adaptor_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, adapter_cutting), adapter_trimmed_reads = map_dbl(adaptor_clean, ~ fromJSON(.)$adapter_trimmed_reads), adapter_trimmed_bases = map_dbl(adaptor_clean, ~ fromJSON(.)$adapter_trimmed_bases) ) %&gt;% mutate( filtering_clean = gsub(&quot;&#39;&quot;, &quot;\\&quot;&quot;, filtering_result), passed_filter_reads = map_dbl(filtering_clean, ~ fromJSON(.)$passed_filter_reads), low_quality_reads = map_dbl(filtering_clean, ~ fromJSON(.)$low_quality_reads), too_many_N_reads = map_dbl(filtering_clean, ~ fromJSON(.)$too_many_N_reads), too_short_reads = map_dbl(filtering_clean, ~ fromJSON(.)$too_short_reads) ) %&gt;% select(-summary_clean,-summary, -adaptor_clean, -filtering_result, -filtering_clean) %&gt;% filter(grepl(&quot;^D&quot;, microsample)) %&gt;% group_by(microsample) %&gt;% summarise( total_sequences_before_trim = sum(total_sequences_before_trim, na.rm = TRUE), total_bases_before_trim = sum(total_bases_before_trim, na.rm = TRUE), total_sequences_after_trim = sum(total_sequences_after_trim, na.rm = TRUE), total_bases_after_trim = sum(total_bases_after_trim, na.rm = TRUE), percent_gc_before_trim = mean(percent_gc_before_trim, na.rm = TRUE)*100, percent_gc_after_trim = mean(percent_gc_after_trim, na.rm = TRUE), duplication = mean(duplication, na.rm = TRUE)*100, adapter_trimmed_reads = sum(adapter_trimmed_reads, na.rm = TRUE), adapter_trimmed_bases = sum(adapter_trimmed_bases, na.rm = TRUE), passed_filter_reads = sum(passed_filter_reads, na.rm = TRUE), low_quality_reads = sum(low_quality_reads, na.rm = TRUE), too_many_N_reads = sum(too_many_N_reads, na.rm = TRUE), too_short_reads = sum(too_short_reads, na.rm = TRUE) ) %&gt;% filter(microsample %in% sample_metadata_macro$sample) 8.3 Non-bacterial mapped reads: human, chicken, swine, turkey, histomonas Get the multiqc_samtools_stats.txt. This is calculated on the trimmed reads. The reads are mapped to these references: 1. turkey (Turkey_5.1), 2. histomonas (Hmelea), 3. chicken (GRCg7b), 4. human (GRCh38), and 5. swine (Sscrofa11.1)) sequentially. To find the number of reads mapped to each reference you have to either - estimate number from the columns: reads_mapped + (reads_mapped - reads_mapped_and_paired) OR - subtract the number of reads that entered the analysis (e.g. column ‘total_passed’ of human - from column ‘total_passed’ of chicken = reads mapped to human). If you try both, these numbers should be equal. Load and process non-bacterial mapping statistics stats_non_bacteria_mapping_macro &lt;- read_tsv(&quot;data/macro/preprocess_data/multiqc_samtools_stats.txt&quot;, show_col_types = FALSE) %&gt;% # make new columns mutate(reference = case_when( # for type of reference based on reference code grepl(&quot;GRCh38&quot;, Sample, ignore.case = TRUE) ~ &quot;human&quot;, grepl(&quot;GRCg7b&quot;, Sample, ignore.case = TRUE) ~ &quot;chicken&quot;, grepl(&quot;Sscrofa11.1&quot;, Sample, ignore.case = TRUE) ~ &quot;swine&quot;, grepl(&quot;Turkey_5.1&quot;, Sample, ignore.case = TRUE) ~ &quot;turkey&quot;, grepl(&quot;Hmelea&quot;, Sample, ignore.case = TRUE) ~ &quot;histomonas&quot;, TRUE ~ NA_character_), # for microsample names microsample = str_extract(Sample, &quot;D\\\\d+&quot;), # for number of reads as input to each reference mapping chicken_total_passed = ifelse(reference == &quot;chicken&quot;, raw_total_sequences, NA_real_), human_total_passed = ifelse(reference == &quot;human&quot;, raw_total_sequences, NA_real_), swine_total_passed = ifelse(reference == &quot;swine&quot;, raw_total_sequences, NA_real_), turkey_total_passed = ifelse(reference == &quot;turkey&quot;, raw_total_sequences, NA_real_), histomonas_total_passed = ifelse(reference == &quot;histomonas&quot;, raw_total_sequences, NA_real_), # for number of reads that mapped to each reference chicken_total_mapped = ifelse(reference == &quot;chicken&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), human_total_mapped = ifelse(reference == &quot;human&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), swine_total_mapped = ifelse(reference == &quot;swine&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), turkey_total_mapped = ifelse(reference == &quot;turkey&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), histomonas_total_mapped = ifelse(reference == &quot;histomonas&quot;, reads_mapped + (reads_mapped - reads_mapped_and_paired), NA_real_), # for unmapped reads after mapping to all three references swine_unmapped = ifelse(reference == &quot;swine&quot;, swine_total_passed - swine_total_mapped, NA_real_)) %&gt;% # select relevant columns select(microsample, chicken_total_passed, human_total_passed, swine_total_passed, turkey_total_passed, histomonas_total_passed, chicken_total_mapped, human_total_mapped, swine_total_mapped, turkey_total_mapped, histomonas_total_mapped, swine_unmapped) %&gt;% # sum reads for same microsample for each reference group_by(microsample) %&gt;% summarise(across( starts_with(&quot;chicken_&quot;) | starts_with(&quot;human_&quot;) | starts_with(&quot;swine_&quot;)| starts_with(&quot;turkey_&quot;) | starts_with(&quot;histomonas_&quot;), sum, na.rm = TRUE)) %&gt;% filter(grepl(&quot;^D&quot;, microsample)) %&gt;% filter(microsample %in% sample_metadata_macro$sample) 8.4 Bacterial mapped reads Download quantify.zip &amp; place in appropriate directory. Get the multiqc_samtools_stats.txt. This is calculated on the trimmed reads after filtering for turkey, histomonas, human, chicken, and pig reads. ‘Unmapped reads’ are trimmed reads that did not map to the turkey, histomonas, human, chicken, and swine references, or to the bacterial MAG catalogue. Load and process bacterial mapping statistics stats_bacteria_mapping_macro &lt;- read_tsv(&quot;data/macro/quantify/multiqc_samtools_stats.txt&quot;, show_col_types = FALSE) %&gt;% # select only the dereplicated to 95% (as the file includes also the 98% and 99%) filter(str_detect(Sample, &quot;0\\\\.95&quot;) &amp; str_detect(Sample, &quot;REF0029&quot;)) %&gt;% # make new columns mutate( microsample = str_extract(Sample, &quot;D\\\\d+&quot;), bacteria_total_passed = raw_total_sequences, bacteria_total_mapped = reads_mapped, unmapped = reads_unmapped ) %&gt;% # sum reads of the same microsample because some samples were sequence multiple times group_by(microsample) %&gt;% summarise( bacteria_total_passed = sum(bacteria_total_passed, na.rm = TRUE), bacteria_total_mapped = sum(bacteria_total_mapped, na.rm = TRUE), unmapped = sum(unmapped, na.rm = TRUE) ) %&gt;% # select relevant columns select(microsample, bacteria_total_passed, bacteria_total_mapped, unmapped) %&gt;% # keep microsamples starting with D (i.e., remove &#39;NA&#39; or &#39;undetermined&#39;) filter(grepl(&quot;^D&quot;, microsample)) 8.5 Alternative way to estimate bacterial read counts (from count table) Calculate bacterial read counts from count table stats_bacteria_mapping_alternative_macro &lt;- read_counts_macro %&gt;% # Move genome names to rownames column_to_rownames(var = &quot;genome&quot;) %&gt;% # Transpose the data t() %&gt;% # Convert back to a data frame as.data.frame() %&gt;% # Move sample names into a column rownames_to_column(var = &quot;microsample&quot;) %&gt;% # sum the counts of all genomes in each sample (i.e., sum of each row) mutate(bacteria_total_read_counts = rowSums(select(., -microsample))) %&gt;% # select to show only the total_counts column select(microsample, bacteria_total_read_counts) %&gt;% # select only microsamples starting with &#39;D&#39; (i.e. not &#39;NA&#39; or &#39;Undetermined&#39;) filter(grepl(&quot;^D&quot;, microsample)) 8.6 Sanity checks Check if the two methods of counting bacterial reads agree: Compare bacterial mapping methods comparison_bacteria_mapping_macro &lt;- stats_bacteria_mapping_alternative_macro %&gt;% # Join on &#39;microsample&#39; inner_join(stats_bacteria_mapping_macro, by = &quot;microsample&quot;) %&gt;% # Compare the two columns mutate(same_counts = bacteria_total_read_counts == bacteria_total_mapped) # Check if all values are the same # TRUE if all are the same, FALSE otherwise all(comparison_bacteria_mapping_macro$same_counts) # Filter &amp; show rows where the counts between the two columns differ comparison_bacteria_mapping_macro %&gt;% filter(!same_counts) %&gt;% mutate(difference = bacteria_total_read_counts- bacteria_total_mapped) %&gt;% select(microsample, bacteria_total_read_counts, bacteria_total_mapped, difference) 8.7 Combine relevant sequencing statistics Combine all sequencing statistics into a single dataframe stats_combined_macro &lt;- reduce(list(fastp_seq_stats_macro, stats_non_bacteria_mapping_macro, stats_bacteria_mapping_macro, stats_bacteria_mapping_alternative_macro), full_join, by = &quot;microsample&quot;) %&gt;% filter(grepl(&quot;^D&quot;, microsample)) %&gt;% mutate(removed_sequences_after_trim = total_sequences_before_trim - total_sequences_after_trim) # estimate some percentages for easier plotting. final_combined_stats_macro &lt;- stats_combined_macro %&gt;% mutate( trimmed_reads_percentage = ((total_sequences_before_trim-total_sequences_after_trim)/total_sequences_before_trim)*100, human_percentage = (human_total_mapped/total_sequences_after_trim)*100, chicken_percentage = (chicken_total_mapped/total_sequences_after_trim)*100, swine_percentage = (swine_total_mapped/total_sequences_after_trim)*100, turkey_percentage = (turkey_total_mapped/total_sequences_after_trim)*100, histomonas_percentage = round((histomonas_total_mapped/total_sequences_after_trim)*100, 7), bacteria_percentage = (bacteria_total_mapped/total_sequences_after_trim)*100, unmapped_percentage = (unmapped/total_sequences_after_trim)*100, bacteria_percentage_enriched = (bacteria_total_mapped/(bacteria_total_mapped+unmapped)*100), unmapped_percentage_enriched = (unmapped/(bacteria_total_mapped+unmapped)*100), adapter_contamination_pct = (adapter_trimmed_bases / total_bases_before_trim)*100, histomonas_over_bacteria = round((histomonas_total_mapped/bacteria_total_mapped),7), bacteria_over_turkey = (bacteria_total_mapped/turkey_total_mapped), unique_pct = 100-duplication ) Add filter_status column # Load retained_samples_macro_filt_30 from counts data load(&quot;data/macro/counts.Rdata&quot;) # Add filter_status column to indicate which samples were retained by filtering final_combined_stats_macro &lt;- final_combined_stats_macro %&gt;% mutate(filter_status = if_else( microsample %in% retained_samples_macro_filt_30, &quot;Retained by filtering&quot;, &quot;Excluded from filtering&quot; )) 8.8 Create plot_data_stats_macro Combine sequencing statistics with sample metadata and alpha diversity for plotting. Create plot_data_stats_macro with sequencing stats, metadata, and alpha diversity # Load alpha diversity data (already loaded in load_data chunk) # Combine sequencing stats with sample metadata and alpha diversity plot_data_stats_macro &lt;- final_combined_stats_macro %&gt;% left_join(alpha_div_macro_filtered_30, by = join_by(microsample == microsample)) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) 8.9 Save working objects Save sequencing statistics data # Save seq stats-related objects to separate file save( final_combined_stats_macro, plot_data_stats_macro, file = &quot;data/macro/seq_stats.Rdata&quot; ) 8.10 Validation Validate sequencing statistics # Check dimensions cat(&quot;Final combined stats dimensions:\\n&quot;) print(dim(final_combined_stats_macro)) cat(&quot;\\nNumber of samples:&quot;, nrow(final_combined_stats_macro), &quot;\\n\\n&quot;) # Check that sanity checks pass cat(&quot;Sanity check results:\\n&quot;) cat(&quot;Bacterial mapping methods agree:&quot;, all(comparison_bacteria_mapping_macro$same_counts), &quot;\\n&quot;) if (!all(comparison_bacteria_mapping_macro$same_counts)) { cat(&quot; Number of samples with differences:&quot;, sum(!comparison_bacteria_mapping_macro$same_counts), &quot;\\n&quot;) knitr::kable(comparison_bacteria_mapping_macro %&gt;% filter(!same_counts) %&gt;% mutate(difference = bacteria_total_read_counts - bacteria_total_mapped) %&gt;% select(microsample, bacteria_total_read_counts, bacteria_total_mapped, difference)) } cat(&quot;\\n&quot;) # Verify percentages sum correctly (should be close to 100% for read composition) cat(&quot;Percentage validation:\\n&quot;) # Check that percentages for read composition make sense sample_check &lt;- final_combined_stats_macro %&gt;% mutate( total_pct_check = human_percentage + chicken_percentage + swine_percentage + turkey_percentage + histomonas_percentage + bacteria_percentage + unmapped_percentage ) %&gt;% select(microsample, total_sequences_after_trim, total_pct_check, human_percentage, chicken_percentage, swine_percentage, turkey_percentage, histomonas_percentage, bacteria_percentage, unmapped_percentage) cat(&quot;Mean total percentage (should be ~100):&quot;, mean(sample_check$total_pct_check, na.rm = TRUE), &quot;\\n&quot;) cat(&quot;Range of total percentage:&quot;, range(sample_check$total_pct_check, na.rm = TRUE), &quot;\\n\\n&quot;) # Check for anomalies cat(&quot;Anomaly checks:\\n&quot;) # Samples with very low bacterial percentage low_bacteria &lt;- final_combined_stats_macro %&gt;% filter(bacteria_percentage &lt; 1) %&gt;% select(microsample, bacteria_percentage, total_sequences_after_trim) if (nrow(low_bacteria) &gt; 0) { cat(&quot;Samples with &lt;1% bacterial reads:&quot;, nrow(low_bacteria), &quot;\\n&quot;) knitr::kable(head(low_bacteria, 10)) } else { cat(&quot;OK: No samples with &lt;1% bacterial reads\\n&quot;) } cat(&quot;\\n&quot;) # Samples with very high unmapped percentage high_unmapped &lt;- final_combined_stats_macro %&gt;% filter(unmapped_percentage &gt; 50) %&gt;% select(microsample, unmapped_percentage, total_sequences_after_trim) if (nrow(high_unmapped) &gt; 0) { cat(&quot;Samples with &gt;50% unmapped reads:&quot;, nrow(high_unmapped), &quot;\\n&quot;) knitr::kable(head(high_unmapped, 10)) } else { cat(&quot;OK: No samples with &gt;50% unmapped reads\\n&quot;) } cat(&quot;\\n&quot;) # Summary statistics cat(&quot;Summary statistics:\\n&quot;) cat(&quot; Mean bacterial percentage:&quot;, mean(final_combined_stats_macro$bacteria_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean unmapped percentage:&quot;, mean(final_combined_stats_macro$unmapped_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean histomonas percentage:&quot;, mean(final_combined_stats_macro$histomonas_percentage, na.rm = TRUE), &quot;%\\n&quot;) cat(&quot; Mean turkey percentage:&quot;, mean(final_combined_stats_macro$turkey_percentage, na.rm = TRUE), &quot;%\\n&quot;) "],["metabolomics-data-preparation.html", "9 Metabolomics Data Preparation 9.1 Load metabolomics data 9.2 Classify samples by type 9.3 Create dataframes for each sample type 9.4 Save processed data 9.5 Validation 9.6 Notes on metabolites metadata", " 9 Metabolomics Data Preparation This file processes metabolomics data from Afekta partners for Histomonas experiments. 9.1 Load metabolomics data 9.1.1 Load abundance values and metabolites metadata # Load abundance values (samples as columns) metabolites_abundance &lt;- read_csv(&quot;data/Afekta_Histomonas_Metabolites/histomonas_metabolomics_abundance_values.csv&quot;, show_col_types = FALSE) # Load metabolites metadata metabolites_metadata &lt;- read_csv(&quot;data/Afekta_Histomonas_Metabolites/histomonas_metabolomics_metabolites.csv&quot;, show_col_types = FALSE) 9.2 Classify samples by type Sample naming convention: - H samples: H###aN (Histomonas Chicken experiment, host tissue) or H###M (Histomonas Chicken experiment, digesta) - M samples: M###N (Histomonas Turkey experiment, host tissue) or M###M (Histomonas Turkey experiment, digesta) 9.2.1 Identify sample columns and classify by type # Get all column names (excluding SAMPLE_ID and Curated ID) sample_cols &lt;- colnames(metabolites_abundance)[-c(1, 2)] # Classify samples into 4 groups # HN: H samples ending in &quot;aN&quot; (Histomonas Chicken, host tissue) # HM: H samples ending in &quot;M&quot; but NOT &quot;aN&quot; (Histomonas Chicken, digesta) # MN: M samples ending in &quot;N&quot; but NOT &quot;M&quot; (Histomonas Turkey, host tissue) # MM: M samples ending in &quot;M&quot; (Histomonas Turkey, digesta) hn_samples &lt;- sample_cols[grepl(&quot;^H\\\\d+aN$&quot;, sample_cols)] hm_samples &lt;- sample_cols[grepl(&quot;^H\\\\d+M$&quot;, sample_cols) &amp; !grepl(&quot;aN$&quot;, sample_cols)] mn_samples &lt;- sample_cols[grepl(&quot;^M\\\\d+N$&quot;, sample_cols)] mm_samples &lt;- sample_cols[grepl(&quot;^M\\\\d+M$&quot;, sample_cols)] cat(&quot;Sample counts:\\n&quot;) cat(&quot; HN (H + aN):&quot;, length(hn_samples), &quot;\\n&quot;) cat(&quot; HM (H + M):&quot;, length(hm_samples), &quot;\\n&quot;) cat(&quot; MN (M + N):&quot;, length(mn_samples), &quot;\\n&quot;) cat(&quot; MM (M + M):&quot;, length(mm_samples), &quot;\\n&quot;) 9.3 Create dataframes for each sample type 9.3.1 HN: Histomonas Chicken, host tissue 9.3.1.1 Create dataframe for HN samples # Select HN samples, join with metadata to filter by ID level, then extract animal IDs metabolites_hn &lt;- metabolites_abundance %&gt;% select(SAMPLE_ID, `Curated ID`, all_of(hn_samples)) %&gt;% # Join with metadata to get ID level left_join(metabolites_metadata %&gt;% select(Feature_ID, `ID level`), by = c(&quot;SAMPLE_ID&quot; = &quot;Feature_ID&quot;)) %&gt;% # Filter for level 1 (high confidence) metabolites only filter(`ID level` == 1) %&gt;% # Remove metadata columns select(-SAMPLE_ID, -`ID level`) %&gt;% # Extract animal ID from column names (first 4 characters: H###) rename_with(~ str_extract(.x, &quot;^H\\\\d+&quot;), .cols = all_of(hn_samples)) %&gt;% # Keep only Curated ID and abundance columns select(`Curated ID`, everything()) 9.3.2 HM: Histomonas Chicken, digesta 9.3.2.1 Create dataframe for HM samples # Select HM samples, join with metadata to filter by ID level, then extract animal IDs metabolites_hm &lt;- metabolites_abundance %&gt;% select(SAMPLE_ID, `Curated ID`, all_of(hm_samples)) %&gt;% # Join with metadata to get ID level left_join(metabolites_metadata %&gt;% select(Feature_ID, `ID level`), by = c(&quot;SAMPLE_ID&quot; = &quot;Feature_ID&quot;)) %&gt;% # Filter for level 1 (high confidence) metabolites only filter(`ID level` == 1) %&gt;% # Remove metadata columns select(-SAMPLE_ID, -`ID level`) %&gt;% # Extract animal ID from column names (first 4 characters: H###) rename_with(~ str_extract(.x, &quot;^H\\\\d+&quot;), .cols = all_of(hm_samples)) %&gt;% # Keep only Curated ID and abundance columns select(`Curated ID`, everything()) 9.3.3 MN: Histomonas Turkey, host tissue 9.3.3.1 Create dataframe for MN samples # Select MN samples, join with metadata to filter by ID level, then extract animal IDs metabolites_mn &lt;- metabolites_abundance %&gt;% select(SAMPLE_ID, `Curated ID`, all_of(mn_samples)) %&gt;% # Join with metadata to get ID level left_join(metabolites_metadata %&gt;% select(Feature_ID, `ID level`), by = c(&quot;SAMPLE_ID&quot; = &quot;Feature_ID&quot;)) %&gt;% # Filter for level 1 (high confidence) metabolites only filter(`ID level` == 1) %&gt;% # Remove metadata columns select(-SAMPLE_ID, -`ID level`) %&gt;% # Extract animal ID from column names (first 4 characters: M###) rename_with(~ str_extract(.x, &quot;^M\\\\d+&quot;), .cols = all_of(mn_samples)) %&gt;% # Keep only Curated ID and abundance columns select(`Curated ID`, everything()) 9.3.4 MM: Histomonas Turkey, digesta 9.3.4.1 Create dataframe for MM samples # Select MM samples, join with metadata to filter by ID level, then extract animal IDs metabolites_mm &lt;- metabolites_abundance %&gt;% select(SAMPLE_ID, `Curated ID`, all_of(mm_samples)) %&gt;% # Join with metadata to get ID level left_join(metabolites_metadata %&gt;% select(Feature_ID, `ID level`), by = c(&quot;SAMPLE_ID&quot; = &quot;Feature_ID&quot;)) %&gt;% # Filter for level 1 (high confidence) metabolites only filter(`ID level` == 1) %&gt;% # Remove metadata columns select(-SAMPLE_ID, -`ID level`) %&gt;% # Extract animal ID from column names (first 4 characters: M###) rename_with(~ str_extract(.x, &quot;^M\\\\d+&quot;), .cols = all_of(mm_samples)) %&gt;% # Keep only Curated ID and abundance columns select(`Curated ID`, everything()) &lt;｜tool▁calls▁begin｜&gt;&lt;｜tool▁call▁begin｜&gt; read_lints 9.4 Save processed data 9.4.1 Save metabolomics dataframes save( metabolites_hn, metabolites_hm, metabolites_mn, metabolites_mm, metabolites_metadata, file = &quot;data/Afekta_Histomonas_Metabolites/metabolites_data.Rdata&quot; ) 9.5 Validation 9.5.1 Validate metabolomics data # Check dimensions cat(&quot;Metabolites dataframes dimensions:\\n&quot;) cat(&quot; HN:&quot;, nrow(metabolites_hn), &quot;rows,&quot;, ncol(metabolites_hn), &quot;columns\\n&quot;) cat(&quot; HM:&quot;, nrow(metabolites_hm), &quot;rows,&quot;, ncol(metabolites_hm), &quot;columns\\n&quot;) cat(&quot; MN:&quot;, nrow(metabolites_mn), &quot;rows,&quot;, ncol(metabolites_mn), &quot;columns\\n&quot;) cat(&quot; MM:&quot;, nrow(metabolites_mm), &quot;rows,&quot;, ncol(metabolites_mm), &quot;columns\\n&quot;) cat(&quot;\\n&quot;) # Check number of samples (animals) per sample type cat(&quot;Number of samples (animals) per sample type:\\n&quot;) cat(&quot; HN:&quot;, ncol(metabolites_hn) - 1, &quot;samples\\n&quot;) # -1 for Curated ID column cat(&quot; HM:&quot;, ncol(metabolites_hm) - 1, &quot;samples\\n&quot;) cat(&quot; MN:&quot;, ncol(metabolites_mn) - 1, &quot;samples\\n&quot;) cat(&quot; MM:&quot;, ncol(metabolites_mm) - 1, &quot;samples\\n&quot;) cat(&quot;\\n&quot;) # Check unique metabolites cat(&quot;Unique metabolites:\\n&quot;) cat(&quot; Total unique Curated IDs:&quot;, n_distinct(metabolites_hn$`Curated ID`, na.rm = TRUE), &quot;\\n&quot;) cat(&quot;\\n&quot;) # Display top rows cat(&quot;Top 5 rows of HN dataframe:\\n&quot;) knitr::kable(head(metabolites_hn, 5)) cat(&quot;\\n&quot;) # Show column names (sample IDs) cat(&quot;Sample IDs (first 10):\\n&quot;) cat(&quot; HN:&quot;, paste(head(colnames(metabolites_hn)[-1], 10), collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot; HM:&quot;, paste(head(colnames(metabolites_hm)[-1], 10), collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot; MN:&quot;, paste(head(colnames(metabolites_mn)[-1], 10), collapse = &quot;, &quot;), &quot;\\n&quot;) cat(&quot; MM:&quot;, paste(head(colnames(metabolites_mm)[-1], 10), collapse = &quot;, &quot;), &quot;\\n&quot;) 9.6 Notes on metabolites metadata The metabolites metadata file (histomonas_metabolomics_metabolites.csv) contains valuable information for downstream analyses: 9.6.1 Available metadata fields: Feature_ID: Unique identifier for each metabolite feature (matches SAMPLE_ID in abundance file) Mode: LC-MS mode (HILIC_neg, HILIC_pos, RP_pos, RP_neg) - useful for mode-specific analyses Retention time: Chromatographic retention time (min) - useful for quality control m/z: Mass-to-charge ratio - useful for identification and quality control Adduct type: Ionization adduct ([M+H]+, [M-H]-, [M+Na]+, etc.) - important for interpretation Curated ID: Metabolite name - human-readable identifier Database identifiers: HMDB (Human Metabolome Database) LipidMaps (for lipid metabolites) Other databases KEGG: KEGG compound ID - useful for pathway enrichment analysis ID level: Confidence level (1 = high confidence, 2 = medium confidence) - important for filtering Chemical taxonomy: Chemical class/functional group - useful for grouping and summarizing metabolites 9.6.2 Suggested uses: Filtering by ID level: Use level 1 (high confidence) metabolites for primary analyses Grouping by chemical taxonomy: Analyze metabolite classes (amino acids, lipids, nucleotides, etc.) Mode-based analysis: Separate analyses by LC-MS mode (HILIC vs RP, positive vs negative) Pathway analysis: Use KEGG IDs for pathway enrichment analysis (e.g., with KEGG pathway databases) Database integration: Use HMDB/LipidMaps IDs for additional annotations and cross-referencing Quality control: Filter by retention time or m/z for data quality checks Metabolite class summaries: Group metabolites by chemical taxonomy for class-level comparisons "],["mag-catalogue-1.html", "10 MAG catalogue 10.1 Genome quality 10.2 MAG catalogue phyla and order colours 10.3 MAG catalogue phyla and order colours, and genera number 10.4 Genome phylogeny plot 10.5 Genome phylogeny plot without legend 10.6 Functional overview 10.7 Functional distances 10.8 Functional ordination", " 10 MAG catalogue load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) print_median_iqr &lt;- function(x, name) { med &lt;- round(median(x), 2) iqr_vals &lt;- round(quantile(x, probs = c(0.25, 0.75)), 2) cat(name, &quot;median =&quot;, med, &quot;IQR =&quot;, iqr_vals[1], &quot;-&quot;, iqr_vals[2], &quot;\\n&quot;) } 10.1 Genome quality print_median_iqr(genome_metadata$completeness, &quot;Completeness:&quot;) Completeness: median = 97.9 IQR = 90.73 - 100 print_median_iqr(genome_metadata$contamination, &quot;Contamination:&quot;) Contamination: median = 0.46 IQR = 0 - 2.03 genome_metadata %&gt;% summarise( circular_count = sum(circularity == &quot;1&quot;), total_count = n(), circular_percent = 100 * circular_count / total_count ) # A tibble: 1 × 3 circular_count total_count circular_percent &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 162 526 30.8 order_metadata %&gt;% summarise( genera_count = sum(number_of_genera), lachnospirales_count = sum(number_of_genera[order == &quot;Lachnospirales&quot;]), lachnospirales_perc = 100 * lachnospirales_count / genera_count, οscillospirales_count = sum(number_of_genera[order == &quot;Oscillospirales&quot;]), οscillospirales_perc = 100 * οscillospirales_count / genera_count ) # A tibble: 1 × 5 genera_count lachnospirales_count lachnospirales_perc οscillospirales_count οscillospirales_perc &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; 1 222 56 25.2 73 32.9 #Generate quality biplot genome_biplot &lt;- genome_metadata %&gt;% select(c(genome,domain,order,completeness,contamination,length)) %&gt;% arrange(match(genome, rev(genome_tree$tip.label))) %&gt;% #sort MAGs according to phylogenetic tree ggplot(aes(x=completeness,y=contamination,size=length,color=order)) + geom_point(alpha=0.7) + xlim(c(70,100)) + ylim(c(25,0)) + scale_color_manual(values=order_colors) + labs(y= &quot;Contamination&quot;, x = &quot;Completeness&quot;) + theme_classic() + theme(legend.position = &quot;none&quot;) #Generate contamination boxplot genome_contamination &lt;- genome_metadata %&gt;% ggplot(aes(y=contamination)) + ylim(c(25,0)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0.40, 0),&quot;inches&quot;)) #add bottom-margin (top, right, bottom, left) #Generate completeness boxplot genome_completeness &lt;- genome_metadata %&gt;% ggplot(aes(x=completeness)) + xlim(c(70,100)) + geom_boxplot(colour = &quot;#999999&quot;, fill=&quot;#cccccc&quot;) + theme_void() + theme(legend.position = &quot;none&quot;, axis.title.x = element_blank(), axis.title.y = element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank(), plot.margin = unit(c(0, 0, 0, 0.50),&quot;inches&quot;)) #add left-margin (top, right, bottom, left) # Align margins genome_biplot &lt;- genome_biplot + theme(plot.margin = margin(5, 5, 5, 5)) genome_completeness &lt;- genome_completeness + theme(plot.margin = margin(0, 5, 0, 5)) genome_contamination &lt;- genome_contamination + theme(plot.margin = margin(5, 0, 5, 0)) # Compose layout top_row &lt;- genome_completeness + plot_spacer() + plot_layout(widths = c(15, 1)) bottom_row &lt;- genome_biplot + genome_contamination + plot_layout(widths = c(15, 1)) # Stack rows MAG_plot &lt;- (top_row / bottom_row + plot_layout(heights = c(2, 15))) + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) MAG_plot 10.2 MAG catalogue phyla and order colours MAG_tax_df &lt;- order_metadata %&gt;% select(order, phylum) %&gt;% distinct() # ensure no duplicates # get the phylum order that facet_grid2 will use (alphabetical by default) phylum_order &lt;- MAG_tax_df %&gt;% distinct(phylum) %&gt;% arrange(phylum) %&gt;% pull(phylum) # phylum strip colors in correct order strip_colors &lt;- phylum_colors[phylum_order] # plot: use y = 1 directly ggplot(MAG_tax_df, aes(x = order, y = 1, fill = order)) + geom_col(width = 0.9, show.legend = FALSE) + geom_text(aes(label = order), angle = 90, color = &quot;white&quot;, size = 3, hjust = 1.1, vjust = 0.5) + scale_fill_manual(values = order_colors) + facet_grid2( . ~ phylum, scales = &quot;free_x&quot;, space = &quot;free&quot;, strip = strip_themed( background_x = elem_list_rect(fill = strip_colors), text_x = elem_list_text(angle = 90, color = &quot;white&quot;, face = &quot;bold&quot;) ) ) + theme_minimal(base_size = 11) + theme( axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), panel.grid = element_blank(), panel.spacing = unit(0.3, &quot;lines&quot;) ) 10.3 MAG catalogue phyla and order colours, and genera number MAG_tax_df &lt;- order_metadata %&gt;% select(phylum, order, number_of_genera) %&gt;% distinct() %&gt;% mutate( order_color = order_colors[order], phylum_color = phylum_colors[phylum] ) # 2. Get facet strip colors in correct order phylum_order &lt;- MAG_tax_df %&gt;% distinct(phylum) %&gt;% arrange(phylum) %&gt;% pull(phylum) strip_colors &lt;- unname(phylum_colors[phylum_order]) # 3. Plot ggplot(MAG_tax_df, aes(x = order, y = number_of_genera, fill = order)) + # Bars geom_col(width = 0.9, show.legend = FALSE) + # Color scale scale_fill_manual(values = order_colors) + # Facet by phylum (strip on bottom) facet_grid2( . ~ phylum, scales = &quot;free_x&quot;, space = &quot;free_x&quot;, switch = &quot;x&quot;, strip = strip_themed( background_x = elem_list_rect(fill = strip_colors), text_x = elem_list_text(angle = 90, color = &quot;white&quot;, face = &quot;bold&quot;) ) ) + # Flip x-axis title and text to top scale_x_discrete(position = &quot;top&quot;) + # Theme theme_minimal(base_size = 11) + theme( axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0), axis.title = element_blank(), panel.spacing = unit(1, &quot;lines&quot;), strip.background = element_blank(), strip.placement = &quot;outside&quot; ) 10.4 Genome phylogeny plot # Generate the phylum color heatmap phylum_heatmap &lt;- genome_metadata %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome,phylum) %&gt;% mutate(phylum = factor(phylum, levels = unique(phylum))) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Generate the order color heatmap order_heatmap &lt;- genome_metadata %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome, order) %&gt;% mutate(order = factor(order, levels = unique(order))) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Generate the basal tree circular_tree &lt;- force.ultrametric(genome_tree, method=&quot;extend&quot;) %&gt;% # extend to ultrametric for the sake of visualisation ggtree(., layout=&quot;fan&quot;, open.angle=10, size=0.1) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # Add the phylum ring circular_tree &lt;- gheatmap(circular_tree, phylum_heatmap, offset = 1.3, width = 0.2, colnames = FALSE) + scale_fill_manual(values = phylum_colors, name = &quot;Phylum&quot;) + geom_tiplab2(size = 1, hjust = -0.1) + theme(plot.margin = margin(0, 0, 0, 0), panel.margin = margin(0, 0, 0, 0)) # Flush color scale for the next ring circular_tree &lt;- circular_tree + new_scale_fill() # Add order ring circular_tree &lt;- gheatmap(circular_tree, order_heatmap, offset = 0.55, width = 0.3, colnames = FALSE) + scale_fill_manual(values = order_colors, name = &quot;Order&quot;) + theme(legend.position = &quot;right&quot;) # Flush color scale to enable a new color scheme in the next ring circular_tree &lt;- circular_tree + new_scale_fill() circular_tree &lt;- circular_tree + new_scale_fill() + scale_fill_manual(values = c(&quot;1&quot; = &quot;#fcbb6d&quot;, &quot;0&quot; = &quot;#465c7a&quot;), name = &#39;Circularized genomes&#39;) + geom_fruit( data = genome_metadata, geom = geom_bar, # Use as.factor to map circularity mapping = aes(x = 1, y = genome, fill = circularity), offset = 1.0, orientation = &quot;y&quot;, stat = &quot;identity&quot;) # Add text circular_tree &lt;- circular_tree + annotate(&#39;text&#39;, x=3.2, y=0, label=&#39; Order&#39;, size=3.5) + annotate(&#39;text&#39;, x=3.6, y=0, label=&#39; Phylum&#39;, size=3.5) + annotate(&#39;text&#39;, x=4.2, y=0, label=&#39; Circularised&#39;, size=3.5) #Plot circular tree p &lt;-circular_tree %&gt;% open_tree(45) %&gt;% rotate_tree(90) + theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) # print(p) # ggsave(filename = &quot;results/figures/MAG_macro_tree.pdf&quot;, plot = p, # units = &quot;cm&quot;, width = 29, height = 40) 10.5 Genome phylogeny plot without legend p + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;none&quot;) #Aggregate bundle-level GIFTs into the compound level GIFTs_elements &lt;- to.elements(genome_gifts,GIFT_db) #Aggregate element-level GIFTs into the function level GIFTs_functions &lt;- to.functions(GIFTs_elements,GIFT_db) #Aggregate function-level GIFTs into overall Biosynthesis, Degradation and Structural GIFTs GIFTs_domains &lt;- to.domains(GIFTs_functions,GIFT_db) 10.6 Functional overview function_group_colors &lt;- c( B01 = &quot;#f7941d&quot;, # topmost color (orange) B02 = &quot;#f26c1f&quot;, # apricot-orange B03 = &quot;#e63e26&quot;, # red-orange B04 = &quot;#e6004c&quot;, # deep pink B06 = &quot;#a1246b&quot;, # magenta B07 = &quot;#ed559f&quot;, # pink B08 = &quot;#f99388&quot;, # peach B09 = &quot;#1a3c85&quot;, # dark blue B10 = &quot;#2b8ac4&quot;, # blue D01 = &quot;#5ec4ed&quot;, # sky blue D02 = &quot;#89d2ef&quot;, # pale blue D03 = &quot;#d9efe9&quot;, # pale mint D04 = &quot;#9ed7b4&quot;, # light green D05 = &quot;#4fb18f&quot;, # mint green D06 = &quot;#3b946d&quot;, # dark teal D07 = &quot;#2a7854&quot;, # deeper teal D08 = &quot;#295b47&quot;, # forest green D09 = &quot;#234c3f&quot;, # deep green S01 = &quot;#1b3e34&quot;, # nearly black-green S02 = &quot;#aaaaaa&quot;, # light grey S03 = &quot;#666666&quot; # dark grey ) order_heatmap &lt;- genome_metadata %&gt;% arrange(match(genome, genome_tree$tip.label)) %&gt;% select(genome,order) %&gt;% column_to_rownames(var = &quot;genome&quot;) # Aggregate basal GIFT into elements function_table &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) # 1. Base tree function_tree &lt;- force.ultrametric(genome_tree, method=&quot;extend&quot;) %&gt;% ggtree(size = 0.3) *************************************************************** * Note: * * force.ultrametric does not include a formal method to * * ultrametricize a tree &amp; should only be used to coerce * * a phylogeny that fails is.ultrametric due to rounding -- * * not as a substitute for formal rate-smoothing methods. * *************************************************************** # 2. First heatmap: add order (row) color strip function_tree &lt;- gheatmap( function_tree, order_heatmap, offset = 0, width = 0.1, colnames = FALSE ) + scale_fill_manual(values = order_colors) + labs(fill = &quot;Order&quot;) # 5. Reset fill scale again for main function matrix function_tree &lt;- function_tree + new_scale_fill() # 6. Add the full function table heatmap (numeric) function_tree &lt;- gheatmap( function_tree, function_table, offset = 0.5, width = 3.5, colnames = FALSE ) + vexpand(0) + # vexpand(0.08) + coord_cartesian(clip = &quot;off&quot;) + scale_fill_gradient(low = &quot;#f4f4f4&quot;, high = &quot;#666666&quot;, na.value = &quot;white&quot;) + labs(fill = &quot;GIFT&quot;) # 7. Final plot function_tree &lt;- function_tree + theme_void() + theme(legend.position = &quot;none&quot;) # function_tree # Join to get Code_function (e.g. B01, D01) for each Code_element (e.g. B0101, B0204) column_annotation &lt;- tibble(Code_element = colnames(function_table)) %&gt;% left_join( GIFT_db %&gt;% select(Code_element, Code_function) %&gt;% distinct(Code_element, .keep_all = TRUE), by = &quot;Code_element&quot; ) # Create a 1-row matrix with Code_function values column_annotation_matrix &lt;- matrix( column_annotation$Code_function, nrow = 1, dimnames = list(&quot;Function_group&quot;, column_annotation$Code_element) ) # Ensure Code_element order matches your heatmap column_annotation_df &lt;- column_annotation %&gt;% distinct(Code_element, Code_function) column_annotation_df$Code_element &lt;- factor( column_annotation_df$Code_element, levels = column_annotation$Code_element ) # Plot annotation strip annotation_strip &lt;- ggplot(column_annotation_df, aes(x = Code_element, y = 1, fill = Code_function)) + geom_tile(color = &quot;white&quot;, linewidth = 0.1) + scale_fill_manual(values = function_group_colors, na.translate = FALSE) + theme_void() + theme( axis.text.x = element_blank(), plot.margin = margin(0, 0, 0, 0) ) + guides(fill = &quot;none&quot;) + theme_void() # annotation_strip combined_plot &lt;- ((plot_spacer() | wrap_elements(annotation_strip) | plot_spacer()) + plot_layout(widths = c(10.1, 25, 1.1))) / wrap_elements(function_tree) + plot_layout(heights = c(0.2, 10)) # adjust strip height as needed combined_plot 10.7 Functional distances functional_distances &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% as.data.frame() %&gt;% stats::dist(., method = &quot;manhattan&quot;) / ncol(genome_gifts[genome_metadata$genome, ]) mean(functional_distances) sd(functional_distances) max(functional_distances) 10.8 Functional ordination PCoA functional ordination with PCA loadings. gift_pcoa &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% as.data.frame() %&gt;% vegdist(method=&quot;euclidean&quot;) %&gt;% pcoa() gift_pcoa_rel_eigen &lt;- gift_pcoa$values$Relative_eig[1:10] # Get genome positions gift_pcoa_vectors &lt;- gift_pcoa$vectors %&gt;% #extract vectors as.data.frame() %&gt;% select(Axis.1,Axis.2) # keep the first 2 axes gift_pcoa_eigenvalues &lt;- gift_pcoa$values$Eigenvalues[c(1,2)] gift_pcoa_gifts &lt;- cov(genome_gifts, scale(gift_pcoa_vectors)) %*% diag((gift_pcoa_eigenvalues/(nrow(genome_gifts)-1))^(-0.5)) %&gt;% as.data.frame() %&gt;% rename(Axis.1=1,Axis.2=2) %&gt;% rownames_to_column(var=&quot;label&quot;) %&gt;% #get function summary vectors mutate(func=substr(label,1,3)) %&gt;% group_by(func) %&gt;% summarise(Axis.1=mean(Axis.1), Axis.2=mean(Axis.2)) %&gt;% rename(label=func) %&gt;% filter(!label %in% c(&quot;S01&quot;,&quot;S02&quot;,&quot;S03&quot;)) scale &lt;- 15 # scale for vector loadings pcoa_plot &lt;- gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;genome&quot;) %&gt;% left_join(genome_metadata, by=&quot;genome&quot;) %&gt;% ggplot() + #genome positions scale_color_manual(values=order_colors)+ geom_point(aes(x=Axis.1,y=Axis.2, color=order, size=length), alpha=0.9, shape=16) + guides(color = &quot;none&quot;) + #scale_color_manual(values=phylum_colors) + scale_size_continuous(range = c(0.1,5)) + #loading positions geom_segment(data=gift_pcoa_gifts, aes(x=0, y=0, xend=Axis.1 * scale, yend=Axis.2 * scale), arrow = arrow(length = unit(0.3, &quot;cm&quot;), type = &quot;open&quot;, angle = 25), linewidth = 0.5, color = &quot;black&quot;) + #Primary and secondary scale adjustments # scale_x_continuous(name = paste0(&quot;PCoA1 (&quot;,round(gift_pcoa_rel_eigen[1]*100, digits = 2), &quot; %)&quot;), # sec.axis = sec_axis(~ . / scale) # ) + # scale_y_continuous(name = paste0(&quot;PCoA2 (&quot;,round(gift_pcoa_rel_eigen[2]*100, digits = 2), &quot; %)&quot;), # sec.axis = sec_axis(~ . / scale) # ) + geom_label_repel(data = gift_pcoa_gifts, aes(label = label, x = Axis.1 * scale, y = Axis.2 * scale), segment.color = &#39;transparent&#39;) + theme_minimal() # pcoa_plot WARNING IS GIVEN FOR THIS: genome Axis.1 Axis.2 domain phylum class order family genus species completeness contamination coding_density length N50_length circularity 1 MPB:bin_000147 -0.3441338 1.451352 NA NA NA NA NA which I cannot find in genome metadata. So I will ignore this warning for now. gift_axis_1 &lt;- gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;genome&quot;) %&gt;% left_join(genome_metadata, by=&quot;genome&quot;) %&gt;% ggplot(aes(x=Axis.1, y=length)) + geom_smooth(color = &quot;black&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;) + labs(y = &quot;Genome length&quot;, x = &quot;PCoA Axis 1&quot;) # gift_axis_1 gift_df_PCoA &lt;- genome_gifts %&gt;% to.elements(., GIFT_db) %&gt;% to.functions(., GIFT_db) %&gt;% as.data.frame() %&gt;% rownames_to_column(var=&quot;genome&quot;) %&gt;% left_join(genome_metadata, by=&quot;genome&quot;) %&gt;% left_join(gift_pcoa_vectors %&gt;% rownames_to_column(var=&quot;genome&quot;), by=&quot;genome&quot;) gift_long &lt;- gift_df_PCoA %&gt;% select(genome, Axis.2, B01, B02, B03, B04, B06, B07, B08, B09, B10, D01, D02, D03, D04, D05, D06, D07, D08, D09, S01, S02, S03) %&gt;% pivot_longer( cols = c(B01, B02, B03, B04, B06, B07, B08, B09, B10, D01, D02, D03, D04, D05, D06, D07, D08, D09, S01, S02, S03), names_to = &quot;component&quot;, values_to = &quot;value&quot; ) # Plot: x = Axis.2, y = value, colored by component (D01 vs D02) gift_plot_PC2 &lt;- gift_long %&gt;% filter(component %in% c(&quot;D01&quot;, &quot;D02&quot;)) %&gt;% ggplot(aes(y = value, x = Axis.2, color = component)) + geom_smooth() + scale_color_manual(values = c(D01 = &quot;#5ec4ed&quot;, D02 = &quot;#89d2ef&quot;)) + theme_minimal() + labs(y = &quot;GIFT&quot;, x = &quot;PCoA Axis 2&quot;, color = &quot;Component&quot;) + theme(legend.position = &quot;right&quot;)+ coord_flip() # gift_plot_PC2 gift_long %&gt;% ggplot(aes(x = Axis.2, y = value)) + geom_smooth(se = FALSE, color = &quot;black&quot;, linewidth = 0.6) + facet_wrap(~ component, ncol = 5, scales = &quot;free_y&quot;) + theme_minimal() + labs(x = &quot;PCoA Axis 2&quot;, y = &quot;Component value&quot;) + theme( strip.text = element_text(size = 8, face = &quot;bold&quot;), panel.spacing = unit(0.5, &quot;lines&quot;), axis.title = element_text(size = 10) ) Trying to make two axes but the coord_flip () flips them the wrong way https://www.reddit.com/r/rstats/comments/wh9bzd/how_can_i_add_a_secondary_axis_to_ggplot_that/ # # Step 1. Compute ranges of each component # ranges &lt;- gift_long %&gt;% # filter(component %in% c(&quot;D01&quot;, &quot;D02&quot;)) %&gt;% # group_by(component) %&gt;% # summarise(min_val = min(value, na.rm = TRUE), # max_val = max(value, na.rm = TRUE)) # # ranges # # gift_plot_PC2 &lt;- gift_long %&gt;% # filter(component %in% c(&quot;D01&quot;, &quot;D02&quot;)) %&gt;% # ggplot(aes(x = Axis.2)) + # # # Plot D01 as is # geom_smooth( # data = subset(gift_long, component == &quot;D01&quot;), # aes(y = value, color = &quot;Lipid degradation&quot;), # linewidth = 1 # ) + # # # Plot D02 rescaled to fit D01 range # geom_smooth( # data = subset(gift_long, component == &quot;D02&quot;), # aes(y = value / 1.5, color = &quot;Polysaccharide degradation&quot;), # scale to align # linewidth = 1 # ) + # # scale_color_manual(values = c( # &quot;Lipid degradation&quot; = &quot;#5ec4ed&quot;, # &quot;Polysaccharide degradation&quot; = &quot;#89d2ef&quot; # )) + # # # Add secondary axis showing original D02 scale (rescaled) # scale_y_continuous( # name = &quot;Lipid degradation&quot;, # sec.axis = sec_axis(~ . * 1.5, name = &quot;Polysaccharide degradation&quot;) # ) + # # theme_minimal() + # coord_flip() + # theme( # legend.position = &quot;none&quot;, # axis.title.x.top = element_text(color = &quot;#5ec4ed&quot;, face = &quot;bold&quot;), # axis.title.x.bottom = element_text(color = &quot;#89d2ef&quot;, face = &quot;bold&quot;) # ) # # # gift_plot_PC2 ((gift_axis_1| plot_spacer()) + plot_layout(widths = c(4.5, 1))) / ((pcoa_plot | gift_plot_PC2) + plot_layout(widths = c(7, 1))) + plot_layout(heights = c(1, 6), guides = &quot;collect&quot;) + theme(legend.position = &quot;bottom&quot;) GIFT_db_functions &lt;- GIFT_db %&gt;% select(Code_function, Function, Domain) %&gt;% distinct(Code_function, .keep_all = TRUE) GIFT_db_functions Code_function Function Domain 1 B01 Nucleic acid biosynthesis Biosynthesis 2 B02 Amino acid biosynthesis Biosynthesis 3 B03 Amino acid derivative biosynthesis Biosynthesis 4 B04 SCFA biosynthesis Biosynthesis 5 B06 Organic anion biosynthesis Biosynthesis 6 B07 Vitamin biosynthesis Biosynthesis 7 B08 Aromatic compound biosynthesis Biosynthesis 8 B09 Metallophore biosynthesis Biosynthesis 9 B10 Antibiotic biosynthesis Biosynthesis 10 D01 Lipid degradation Degradation 11 D02 Polysaccharide degradation Degradation 12 D03 Sugar degradation Degradation 13 D04 Protein degradation Degradation 14 D05 Amino acid degradation Degradation 15 D06 Nitrogen compound degradation Degradation 16 D07 Alcohol degradation Degradation 17 D08 Xenobiotic degradation Degradation 18 D09 Antibiotic degradation Degradation 19 S01 Cellular structure Structure 20 S02 Appendages Structure 21 S03 Spore Structure GIFT_legend_df &lt;- GIFT_db_functions %&gt;% mutate(color = function_group_colors[Code_function]) %&gt;% arrange(Code_function) # keep the order consistent function_colors &lt;- ggplot(GIFT_legend_df, aes(y = reorder(Code_function, desc(Code_function)), x = 1, fill = Code_function)) + geom_tile(color = &quot;white&quot;, linewidth = 0.4, width = 1.1, height = 0.9) + scale_fill_manual(values = function_group_colors, guide = &quot;none&quot;) + geom_text(aes(label = paste0(Code_function, &quot;: &quot;, Function)), hjust = 0, nudge_x = - 0.5, color = &quot;white&quot;, size = 3.5, fontface = &quot;bold&quot;) + theme_void() + theme( aspect.ratio = NULL, plot.margin = margin(0, 0, 0, 0) ) function_colors "],["histomonas-presence.html", "11 Histomonas Presence 11.1 Macro 11.2 Micro", " 11 Histomonas Presence load(&quot;data/macro/plot_data.Rdata&quot;) load(&quot;data/micro/plot_data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 11.1 Macro var &lt;- &quot;histomonas_percentage&quot; summary_stats &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% group_by(treatment_expl, age_category) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 3)) #format(median, scientific = TRUE, digits = 5)) knitr::kable(summary_stats) treatment_expl age_category median IQR Q1 Q3 label_txt ControlGroup a 0.0003067 0.0003577 0.0000591 0.0004168 0.000 ControlGroup b 0.0000393 0.0000109 0.0000384 0.0000493 0.000 ControlGroup c 0.0000754 0.0000162 0.0000640 0.0000802 0.000 ControlGroup d 0.0001457 0.0001455 0.0000796 0.0002251 0.000 OnlyHistomonas a 0.0001061 0.0003813 0.0000781 0.0004594 0.000 OnlyHistomonas b 0.0791479 0.0806973 0.0257973 0.1064946 0.079 OnlyHistomonas c 0.1417289 0.0469864 0.1106992 0.1576856 0.142 VaccinatedCloacal&amp;Histomonas a 0.3312334 0.6929748 0.0040287 0.6970035 0.331 VaccinatedCloacal&amp;Histomonas b 0.0040184 0.0146591 0.0037604 0.0184195 0.004 VaccinatedCloacal&amp;Histomonas c 0.0295119 0.0282338 0.0294793 0.0577131 0.030 VaccinatedCloacal&amp;Histomonas d 0.0860196 0.1868106 0.0252611 0.2120717 0.086 VaccinatedOral&amp;Histomonas a 0.1183620 0.1151790 0.0711032 0.1862822 0.118 VaccinatedOral&amp;Histomonas b 0.1156056 0.0525126 0.0929984 0.1455110 0.116 VaccinatedOral&amp;Histomonas c 0.0203249 0.0719668 0.0001374 0.0721042 0.020 VaccinatedOral&amp;Histomonas d 0.1064631 0.3813226 0.0011719 0.3824945 0.106 boxplot_reads_prc_1 &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = age_category, y = histomonas_percentage, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5, size = 2) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;% reads mapping to Histomonas&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = age_category, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ # ggtitle(&quot;XX&quot;) # boxplot_reads_prc_1 barplot_hist &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = microsample, y = histomonas_total_mapped, fill = treatment)) + geom_bar(stat = &quot;identity&quot;, colour = &quot;white&quot;, linewidth = 0.1) + scale_fill_manual(values = treatment_colours_bright) + labs(x = &quot;Samples&quot;, y = &quot;Histomonas reads&quot;, fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category, scales = &quot;free&quot;, space = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_blank(), axis.text.y = element_text(), legend.position = &quot;bottom&quot;, plot.margin = margin(0.2, 0.2, 0.2, 0.2)) #+ #ggtitle(&quot;XX&quot;) # barplot_hist (boxplot_reads_prc_1 + barplot_hist) + plot_layout( ncol = 1, # single column heights = c(2, 1), # assign relative heights guides = &quot;collect&quot; ) + plot_annotation(tag_levels = &#39;a&#39;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 11.2 Micro var &lt;- &quot;histomonas_percentage&quot; summary_stats &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% group_by(treatment_expl, age_category, type_simple, animal) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 5)) #format(median, scientific = TRUE, digits = 5)) knitr::kable(summary_stats) treatment_expl age_category type_simple animal median IQR Q1 Q3 label_txt ControlGroup a P M061a 0.0000083 0.0000270 0.0000000 0.0000270 0.00001 ControlGroup a P M065a 0.0000000 0.0000058 0.0000000 0.0000058 0.00000 ControlGroup d P M078d 0.0000031 0.0000070 0.0000000 0.0000070 0.00000 ControlGroup d P M080d 0.0000000 0.0000087 0.0000000 0.0000087 0.00000 OnlyHistomonas a P M041a 0.0000000 0.0000245 0.0000000 0.0000245 0.00000 OnlyHistomonas a P M042a 0.0000000 0.0000061 0.0000000 0.0000061 0.00000 VaccinatedCloacal&amp;Histomonas a P M002a 0.0002499 0.0025940 0.0000417 0.0026356 0.00025 VaccinatedCloacal&amp;Histomonas a P M003a 0.0000070 0.0000293 0.0000000 0.0000293 0.00001 VaccinatedCloacal&amp;Histomonas d P M017d 0.0008340 0.0069444 0.0000746 0.0070190 0.00083 VaccinatedCloacal&amp;Histomonas d P M018d 0.0000746 0.0001890 0.0000076 0.0001966 0.00007 VaccinatedOral&amp;Histomonas a P M021a 0.0000059 0.0000178 0.0000000 0.0000178 0.00001 VaccinatedOral&amp;Histomonas a P M022a 0.0000605 0.0021172 0.0000216 0.0021388 0.00006 VaccinatedOral&amp;Histomonas d P M038d 0.0038477 0.0122219 0.0009026 0.0131244 0.00385 VaccinatedOral&amp;Histomonas d P M039d 0.0000169 0.0000353 0.0000041 0.0000394 0.00002 boxplot_reads_prc_2 &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% ggplot(aes(x = type_simple, y = histomonas_percentage, color = treatment)) + # x = age_category geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5, size = 2) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl + age_category + animal, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;% reads mapping to Histomonas&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = type_simple, y = median, label = label_txt), # x = age_category inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ # ggtitle(&quot;XX&quot;) # boxplot_reads_prc_2 barplot_hist_2 &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% ggplot(aes(x = microsample, y = histomonas_total_mapped, fill = treatment)) + geom_bar(stat = &quot;identity&quot;, colour = &quot;white&quot;, linewidth = 0.1) + scale_fill_manual(values = treatment_colours_bright) + labs(x = &quot;Samples&quot;, y = &quot;Histomonas reads&quot;, fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category + animal, scales = &quot;free&quot;, space = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_blank(), axis.text.y = element_text(), legend.position = &quot;bottom&quot;, plot.margin = margin(0.2, 0.2, 0.2, 0.2), panel.grid.major = element_line(color = &quot;white&quot;), panel.grid.minor = element_line(color = &quot;#dde3e9&quot;)) # Customize major grid lines #+ #ggtitle(&quot;XX&quot;) # barplot_hist_2 (boxplot_reads_prc_2 + barplot_hist_2) + plot_layout( ncol = 1, # single column heights = c(1, 2), # assign relative heights guides = &quot;collect&quot; ) + plot_annotation(tag_levels = &#39;a&#39;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) "],["sequencing-statistics.html", "12 Sequencing Statistics 12.1 Prepare tidy tables for plotting 12.2 Macro-samples 12.3 Micro-samples", " 12 Sequencing Statistics load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/macro/counts.Rdata&quot;) load(&quot;data/macro/seq_stats.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/counts.Rdata&quot;) load(&quot;data/micro/seq_stats.Rdata&quot;) load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 12.1 Prepare tidy tables for plotting Create tidy table for sequencing stats before &amp; after trimming (micro) tidy_plot_data_stats_before_after &lt;- plot_data_stats %&gt;% pivot_longer( cols = c( total_sequences_before_trim, total_sequences_after_trim, percent_gc_before_trim, percent_gc_after_trim, total_bases_before_trim, total_bases_after_trim), names_to = c(&quot;Metric&quot;, &quot;Condition&quot;), # Split column names names_pattern = &quot;(.*)_(before|after)_trim&quot;) %&gt;% pivot_wider(names_from = Metric, values_from = value) %&gt;% mutate(Condition = factor(Condition, levels = c(&quot;before&quot;, &quot;after&quot;))) Create tidy table for sequencing stats before &amp; after trimming (macro) tidy_plot_data_stats_before_after_macro &lt;- plot_data_stats_macro %&gt;% pivot_longer( cols = c( total_sequences_before_trim, total_sequences_after_trim, percent_gc_before_trim, percent_gc_after_trim, total_bases_before_trim, total_bases_after_trim), names_to = c(&quot;Metric&quot;, &quot;Condition&quot;), # Split column names names_pattern = &quot;(.*)_(before|after)_trim&quot;) %&gt;% pivot_wider(names_from = Metric, values_from = value) %&gt;% mutate(Condition = factor(Condition, levels = c(&quot;before&quot;, &quot;after&quot;))) Create tidy table for read counts (micro) category_counts &lt;- tibble::tibble( category = c( &quot;bacteria_total_mapped&quot;, &quot;turkey_total_mapped&quot;, &quot;histomonas_total_mapped&quot;, &quot;chicken_total_mapped&quot;, &quot;human_total_mapped&quot;, &quot;swine_total_mapped&quot;, &quot;unmapped&quot;, &quot;removed_sequences_after_trim&quot;), label = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;), color = c( &quot;#B92D65&quot;, &quot;#79b1a3&quot;, &quot;#e35d51&quot;, &quot;#E8BD50&quot;, &quot;#1092b4&quot;, &quot;#3baf6f&quot;, &quot;#8d98ae&quot;, &quot;#2b2d42&quot;)) tidy_plot_data_stats_counts &lt;- plot_data_stats %&gt;% pivot_longer( cols = c( chicken_total_mapped, human_total_mapped, swine_total_mapped, bacteria_total_mapped, turkey_total_mapped, histomonas_total_mapped, unmapped, removed_sequences_after_trim), names_to = &quot;mapping_status&quot;, values_to = &quot;counts&quot;) %&gt;% left_join(category_counts, by = c(&quot;mapping_status&quot; = &quot;category&quot;)) %&gt;% # order the groups in desired order mutate(label = factor(label, levels = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;))) # set labels &amp; colours as colour palette color_palette_tidy_plot_data_stats_counts &lt;- setNames(category_counts$color, category_counts$label) Create tidy table for read counts (macro) category_counts &lt;- tibble::tibble( category = c( &quot;bacteria_total_mapped&quot;, &quot;turkey_total_mapped&quot;, &quot;histomonas_total_mapped&quot;,&quot;chicken_total_mapped&quot;, &quot;human_total_mapped&quot;, &quot;swine_total_mapped&quot;, &quot;unmapped&quot;, &quot;removed_sequences_after_trim&quot;), label = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;), color = c( &quot;#B92D65&quot;, &quot;#79b1a3&quot;, &quot;#e35d51&quot;, &quot;#E8BD50&quot;, &quot;#1092b4&quot;, &quot;#3baf6f&quot;, &quot;#8d98ae&quot;, &quot;#2b2d42&quot;)) tidy_plot_data_stats_counts_macro &lt;- plot_data_stats_macro %&gt;% pivot_longer( cols = c( chicken_total_mapped, human_total_mapped, swine_total_mapped, bacteria_total_mapped, turkey_total_mapped, histomonas_total_mapped, unmapped, removed_sequences_after_trim), names_to = &quot;mapping_status&quot;, values_to = &quot;counts&quot;) %&gt;% left_join(category_counts, by = c(&quot;mapping_status&quot; = &quot;category&quot;)) %&gt;% # order the groups in desired order mutate(label = factor(label, levels = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;))) # set labels &amp; colours as colour palette color_palette_tidy_plot_data_stats_counts &lt;- setNames(category_counts$color, category_counts$label) Create tidy table for read percentages (micro) category_prc &lt;- tibble::tibble( category = c( &quot;bacteria_percentage&quot;, &quot;turkey_percentage&quot;, &quot;histomonas_percentage&quot;, &quot;chicken_percentage&quot;, &quot;human_percentage&quot;, &quot;swine_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;), label = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;), color = c( &quot;#B92D65&quot;, &quot;#79b1a3&quot;, &quot;#e35d51&quot;, &quot;#E8BD50&quot;, &quot;#1092b4&quot;, &quot;#3baf6f&quot;, &quot;#8d98ae&quot;, &quot;#2b2d42&quot;)) tidy_plot_data_stats_counts_prc &lt;- plot_data_stats %&gt;% pivot_longer( cols = c( chicken_percentage, human_percentage, swine_percentage, bacteria_percentage, turkey_percentage, histomonas_percentage, unmapped_percentage, trimmed_reads_percentage), names_to = &quot;mapping_status&quot;, values_to = &quot;counts&quot;) %&gt;% left_join(category_prc, by = c(&quot;mapping_status&quot; = &quot;category&quot;)) %&gt;% # order the groups in desired order mutate(label = factor(label, levels = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;))) # set labels &amp; colours as colour palette color_palette_tidy_plot_data_stats_counts &lt;- setNames(category_counts$color, category_counts$label) Create tidy table for read percentages (macro) category_prc &lt;- tibble::tibble( category = c( &quot;bacteria_percentage&quot;, &quot;turkey_percentage&quot;, &quot;histomonas_percentage&quot;, &quot;chicken_percentage&quot;, &quot;human_percentage&quot;, &quot;swine_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;), label = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;), color = c( &quot;#B92D65&quot;, &quot;#79b1a3&quot;, &quot;#e35d51&quot;, &quot;#E8BD50&quot;, &quot;#1092b4&quot;, &quot;#3baf6f&quot;, &quot;#8d98ae&quot;, &quot;#2b2d42&quot;)) tidy_plot_data_stats_counts_prc_macro &lt;- plot_data_stats_macro %&gt;% pivot_longer( cols = c( chicken_percentage, human_percentage, swine_percentage, bacteria_percentage, turkey_percentage, histomonas_percentage, unmapped_percentage, trimmed_reads_percentage), names_to = &quot;mapping_status&quot;, values_to = &quot;counts&quot;) %&gt;% left_join(category_prc, by = c(&quot;mapping_status&quot; = &quot;category&quot;)) %&gt;% # order the groups in desired order mutate(label = factor(label, levels = c(&quot;Bacteria&quot;, &quot;Turkey&quot;, &quot;Histomonas&quot;, &quot;Chicken&quot;, &quot;Human&quot;, &quot;Swine&quot;, &quot;Unmapped&quot;, &quot;Removed&quot;))) # set labels &amp; colours as colour palette color_palette_tidy_plot_data_stats_counts &lt;- setNames(category_counts$color, category_counts$label) Create tidy tables for genome counts (micro) tidy_plot_genome_counts &lt;- genome_counts %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% # Flatten section if it&#39;s a list mutate(section = unlist(section)) %&gt;% # Filter out rows with count &lt;= 0 # (that are redundant after pivot_longer, but important for b div) filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) 12.2 Macro-samples 12.2.1 Number of bases &amp; reads var &lt;- &quot;total_bases_before_trim&quot; summary_stats &lt;-plot_data_stats_macro %&gt;% group_by(type_simple, batch) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple batch median IQR Q1 Q3 label_txt N S3B014 6596700 0 6596700 6596700 6.6e+06 P S3B014 5511612750 1499163075 4918069350 6417232425 5.5e+09 barplot_bases &lt;- plot_data_stats_macro %&gt;% ggplot(aes(x = type_simple, y = total_bases_before_trim, color = bacteria_percentage, shape=filter_status)) + labs(x = &quot;Sample type&quot;, y = &quot;Number of bases before trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.1, alpha = 0.6, size = 3) + facet_nested(. ~ batch, scales = &quot;free&quot;, space = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 10, 0.2, 0.2)) + geom_text( data = summary_stats, aes(x = type_simple, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 4, alpha = 1, color = &quot;black&quot;) # barplot_bases var &lt;- &quot;total_sequences_after_trim&quot; summary_stats &lt;-plot_data_stats_macro %&gt;% group_by(type_simple, batch) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple batch median IQR Q1 Q3 label_txt N S3B014 28 0 28 28 2.8e+01 P S3B014 35792651 9020001 31968296 40988296 3.6e+07 barplot_reads_after &lt;- plot_data_stats_macro %&gt;% ggplot(aes(x = type_simple, y = total_sequences_after_trim, color = bacteria_percentage, shape=filter_status)) + labs(x = &quot;Sample type&quot;, y = &quot;Number of reads after trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.1, alpha = 0.6, size = 3) + facet_nested(. ~ batch, scales = &quot;free&quot;, space = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 0.2, 0.2, 0.6)) + geom_text( data = summary_stats, aes(x = type_simple, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 4, alpha = 1, color = &quot;black&quot;) # barplot_trimmed_reads + barplot_reads_after + # plot_annotation(tag_levels = &#39;a&#39;) + # plot_layout(guides = &quot;collect&quot;) &amp; # theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) barplot_bases + barplot_reads_after + plot_annotation(tag_levels = &#39;a&#39;) + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.2.2 % of reads mapped to references, removed by trimming, unmapped var &lt;- &quot;counts&quot; summary_stats &lt;- tidy_plot_data_stats_counts_prc_macro %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;,&quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% group_by(type_simple, batch, label) %&gt;% #treatment_expl, age, summarise( Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), median = median(.data[[var]], na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% mutate( label_txt = paste0( &quot;&quot;, round(median, 1),&quot;%&quot;, &quot; [&quot;, round(Q1, 1), &quot;–&quot;, round(Q3, 1), &quot;]&quot;)) knitr::kable(summary_stats) type_simple batch label Q1 median Q3 label_txt P S3B014 Bacteria 11.837008 47.666029 80.284200 47.7% [11.8–80.3] P S3B014 Turkey 6.416658 47.463445 85.672307 47.5% [6.4–85.7] P S3B014 Unmapped 3.149501 6.687567 11.451008 6.7% [3.1–11.5] P S3B014 Removed 2.404141 2.754639 3.467268 2.8% [2.4–3.5] boxplot_reads_prc_1 &lt;- tidy_plot_data_stats_counts_prc_macro %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;, &quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% ggplot(aes(x = batch, y = counts, color = label)) + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = color_palette_tidy_plot_data_stats_counts) + facet_nested(. ~ label, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = NULL,y = &quot;Reads %&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = batch, y = median, label = label_txt), inherit.aes = FALSE, vjust = -1.5, size = 3, alpha = 1, color = &quot;black&quot;) # boxplot_reads_prc_1 12.2.3 Composition of reads vs. references barplot_1 &lt;- tidy_plot_data_stats_counts_macro %&gt;% ggplot(aes(x = counts, y = microsample, fill = label)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1, position = &quot;fill&quot;) + #plot stacked bars with white borders scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Counts&quot;,y = &quot;Microsample&quot;,fill = &quot;Read type&quot;) + facet_nested(type_simple + batch ~ ., scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + # treatment + day + animal + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(), legend.position = &quot;bottom&quot;) + ggtitle(&quot;Ratio of reads&quot;) # barplot_1 barplot_2 &lt;- tidy_plot_data_stats_counts_macro %&gt;% ggplot(aes(x = counts, y = microsample, fill = label)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values = color_palette_tidy_plot_data_stats_counts) + labs(x = &quot;Counts&quot;,y = &quot;Samples&quot;,fill = &quot;Read type&quot;) + facet_nested(type_simple ~ ., scales = &quot;free&quot;, space = &quot;free&quot;, switch = &quot;y&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), axis.text.y = element_blank(), legend.position = &quot;bottom&quot;, plot.margin = margin(0.2, 0.2, 0.2, 0.2)) # barplot_2 (boxplot_reads_prc_1 |barplot_2 ) + plot_layout( ncol = 2, # single column widths = c(2, 2), # assign relative heights guides = &quot;collect&quot; ) + plot_annotation(tag_levels = &#39;a&#39;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.3 Micro-samples 12.3.1 Number of bases var &lt;- &quot;total_bases_before_trim&quot; summary_stats &lt;-plot_data_stats %&gt;% group_by(type_simple, section) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple section median IQR Q1 Q3 label_txt N Caecum right 37071450 147571200 11465475 159036675 3.7e+07 P Caecum right 4127211450 4200413625 2236636050 6437049675 4.1e+09 barplot_bases_all &lt;- plot_data_stats %&gt;% ggplot(aes(x = section, y = total_bases_before_trim)) + labs(x = &quot;Type&quot;, y = &quot;Number of bases before trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + # single boxplot per batch geom_boxplot(outlier.shape = NA) + # keep color &amp; shape for jitter points only geom_jitter(aes(color = bacteria_percentage, shape = filter_status), width = 0.3, alpha = 0.5, size = 2) + facet_nested(type_simple ~ ., scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme( plot.margin = margin(0.2, 10, 0.2, 0.2), axis.title.x = element_blank(), # remove x-axis title axis.text.x = element_blank(), # remove tick labels #axis.text.x = element_text(angle = 90, hjust = 1) axis.ticks.x = element_blank(), # remove tick marks ) + geom_text( data = summary_stats, aes(x = section, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 3, alpha = 1, color = &quot;black&quot;) # barplot_bases_all var &lt;- &quot;total_bases_before_trim&quot; summary_stats &lt;-plot_data_stats %&gt;% group_by(type_simple, batch) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple batch median IQR Q1 Q3 label_txt N MSEB0042 381594000 670141875 76284600 746426475 3.8e+08 N MSEB0043 308657850 1501134900 74798250 1575933150 3.1e+08 N MSEB0044 313270950 1033517175 149868450 1183385625 3.1e+08 N MSEB0045 593576250 352137000 319580400 671717400 5.9e+08 N MSEB0046 15834300 30303375 6954150 37257525 1.6e+07 N MSEB0047 17806500 13547250 8759100 22306350 1.8e+07 N MSEB0048 64911300 89521875 12463500 101985375 6.5e+07 N MSEB0049 36247200 88652625 20577750 109230375 3.6e+07 N MSEB0050 29742000 41094225 12299175 53393400 3.0e+07 N MSEB0051 19828800 25715625 11875950 37591575 2.0e+07 N MSEB0052 11830200 18216525 2158200 20374725 1.2e+07 N MSEB0053 28588950 109663650 7541775 117205425 2.9e+07 N MSEB0054 13662450 15208875 8577675 23786550 1.4e+07 N MSEB0055 14385600 21515325 6401850 27917175 1.4e+07 P MSEB0042 4981095750 1444314375 4247286150 5691600525 5.0e+09 P MSEB0043 4875332700 1379680050 4143547875 5523227925 4.9e+09 P MSEB0044 4187239200 1095840975 3664518150 4760359125 4.2e+09 P MSEB0045 2820497550 754390725 2456315775 3210706500 2.8e+09 P MSEB0046 3801025050 6926109975 1345935750 8272045725 3.8e+09 P MSEB0047 4781791650 8701430250 1523287050 10224717300 4.8e+09 P MSEB0048 3194397450 4334175900 1442898375 5777074275 3.2e+09 P MSEB0049 2603536650 4829702550 904386675 5734089225 2.6e+09 P MSEB0050 4860384600 4451667900 3329187675 7780855575 4.9e+09 P MSEB0051 5171776050 3118518375 3798897525 6917415900 5.2e+09 P MSEB0052 1813507650 8666631525 421784625 9088416150 1.8e+09 P MSEB0053 1641974700 8794150350 674247675 9468398025 1.6e+09 P MSEB0054 4084768050 4030189125 2531654325 6561843450 4.1e+09 P MSEB0055 3484194300 3949275675 2372665575 6321941250 3.5e+09 barplot_bases_batch &lt;- plot_data_stats %&gt;% ggplot(aes(x = batch, y = total_bases_before_trim)) + labs(x = &quot;Batch&quot;, y = &quot;Number of bases before trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + # single boxplot per batch geom_boxplot(aes(group = batch), outlier.shape = NA) + # keep color &amp; shape for jitter points only geom_jitter(aes(color = bacteria_percentage, shape = filter_status), width = 0.1, alpha = 0.5, size = 2) + facet_nested(type_simple ~ ., scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + geom_text( data = summary_stats, aes(x = batch, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 3, alpha = 1, color = &quot;black&quot;) # barplot_bases_batch (barplot_bases_all + barplot_bases_batch) + plot_annotation(tag_levels = &#39;a&#39;) + plot_layout(guides = &quot;collect&quot;, ncol = 2, # single column width = c(1, 8)) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.3.2 Number of reads after trimming var &lt;- &quot;total_sequences_after_trim&quot; summary_stats &lt;-plot_data_stats %&gt;% group_by(type_simple, section) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple section median IQR Q1 Q3 label_txt N Caecum right 228788 975349.5 65023.5 1040373 2.3e+05 P Caecum right 27009021 27553216.5 14600111.5 42153328 2.7e+07 barplot_trimmed_reads_all &lt;- plot_data_stats %&gt;% ggplot(aes(x = section, y = total_sequences_after_trim)) + labs(x = &quot;Type&quot;, y = &quot;Number of reads after trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + # single boxplot per batch geom_boxplot(outlier.shape = NA) + # keep color &amp; shape for jitter points only geom_jitter(aes(color = bacteria_percentage, shape = filter_status), width = 0.3, alpha = 0.5, size = 2) + facet_nested(type_simple ~ ., scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme( plot.margin = margin(0.2, 10, 0.2, 0.2), axis.title.x = element_blank(), # remove x-axis title axis.text.x = element_blank(), # remove tick labels #axis.text.x = element_text(angle = 90, hjust = 1) axis.ticks.x = element_blank(), # remove tick marks ) + geom_text( data = summary_stats, aes(x = section, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 3, alpha = 1, color = &quot;black&quot;) # barplot_trimmed_reads_all var &lt;- &quot;total_sequences_after_trim&quot; summary_stats &lt;-plot_data_stats %&gt;% group_by(type_simple, batch) %&gt;% # replace with your grouping var if any summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) knitr::kable(summary_stats) type_simple batch median IQR Q1 Q3 label_txt N MSEB0042 2459842 4376797.5 484543.5 4861341.0 2.5e+06 N MSEB0043 1995247 9765967.5 473412.5 10239380.0 2.0e+06 N MSEB0044 2031699 6757173.5 962332.0 7719505.5 2.0e+06 N MSEB0045 3858248 2286869.0 2070613.5 4357482.5 3.9e+06 N MSEB0046 97302 194909.0 41086.5 235995.5 9.7e+04 N MSEB0047 112590 94468.0 48824.0 143292.0 1.1e+05 N MSEB0048 422369 589077.5 77794.0 666871.5 4.2e+05 N MSEB0049 233202 584384.0 127094.0 711478.0 2.3e+05 N MSEB0050 183764 263284.5 73870.5 337155.0 1.8e+05 N MSEB0051 126293 170428.5 74213.0 244641.5 1.3e+05 N MSEB0052 71049 117197.5 11686.5 128884.0 7.1e+04 N MSEB0053 125765 726604.5 38541.5 765146.0 1.3e+05 N MSEB0054 81420 96777.0 50288.5 147065.5 8.1e+04 N MSEB0055 51828 123490.0 17762.0 141252.0 5.2e+04 P MSEB0042 32672262 9469309.5 27653623.5 37122933.0 3.3e+07 P MSEB0043 31845581 9116962.5 27053912.5 36170875.0 3.2e+07 P MSEB0044 27419607 7164158.0 24065772.5 31229930.5 2.7e+07 P MSEB0045 18358025 4841444.0 16017658.5 20859102.5 1.8e+07 P MSEB0046 24882457 45345945.0 8747816.5 54093761.5 2.5e+07 P MSEB0047 31398133 56331608.5 9964526.0 66296134.5 3.1e+07 P MSEB0048 20889594 28266741.5 9443605.0 37710346.5 2.1e+07 P MSEB0049 17060753 31821673.0 5901804.0 37723477.0 1.7e+07 P MSEB0050 31730068 29040813.5 21703138.5 50743952.0 3.2e+07 P MSEB0051 33817176 20378751.5 24883836.5 45262588.0 3.4e+07 P MSEB0052 11879344 56917064.5 2760204.0 59677268.5 1.2e+07 P MSEB0053 10752621 57914814.0 4433817.0 62348631.0 1.1e+07 P MSEB0054 26803237 26544213.0 16659330.5 43203543.5 2.7e+07 P MSEB0055 22755967 25748179.5 15532349.0 41280528.5 2.3e+07 barplot_reads_batch &lt;- plot_data_stats %&gt;% ggplot(aes(x = batch, y = total_sequences_after_trim)) + labs(x = &quot;Batch&quot;, y = &quot;Number of reads after trimming&quot;) + scale_color_gradient(low = &quot;#c90076&quot;, high = &quot;#3598bf&quot;, name = &quot;bacteria_percentage&quot;) + scale_shape_manual(values = c(&quot;Retained by filtering&quot; = 16, &quot;Excluded from filtering&quot; = 17)) + # single boxplot per batch geom_boxplot(aes(group = batch), outlier.shape = NA) + # keep color &amp; shape for jitter points only geom_jitter(aes(color = bacteria_percentage, shape = filter_status), width = 0.1, alpha = 0.5, size = 2) + facet_nested(type_simple ~ ., scales = &quot;free&quot;, space = &quot;fixed&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + geom_text( data = summary_stats, aes(x = batch, y = median, label = label_txt), inherit.aes = FALSE, vjust = -7, size = 3, alpha = 1, color = &quot;black&quot;) # barplot_reads_batch (barplot_trimmed_reads_all + barplot_reads_batch) + plot_annotation(tag_levels = &#39;a&#39;) + plot_layout(guides = &quot;collect&quot;, ncol = 2, # single column width = c(1, 8)) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.3.3 % of reads mapped to references, removed by trimming, unmapped var &lt;- &quot;counts&quot; summary_stats &lt;- tidy_plot_data_stats_counts_prc %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;,&quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% group_by(type_simple, batch, label) %&gt;% #treatment_expl, age, summarise( Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), median = median(.data[[var]], na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% mutate( label_txt = paste0( &quot;&quot;, round(median, 1),&quot;%&quot;, &quot;\\n[&quot;, round(Q1, 1), &quot;–&quot;, round(Q3, 1), &quot;]&quot;)) knitr::kable(summary_stats) type_simple batch label Q1 median Q3 label_txt P MSEB0042 Bacteria 77.1293571 83.2961642 84.5142164 83.3% [77.1–84.5] P MSEB0042 Turkey 0.0163631 0.0775952 0.6249221 0.1% [0–0.6] P MSEB0042 Unmapped 14.8680114 15.5989254 16.6786750 15.6% [14.9–16.7] P MSEB0042 Removed 1.8511632 2.0813832 2.2809274 2.1% [1.9–2.3] P MSEB0043 Bacteria 74.7726283 83.6791796 84.5846879 83.7% [74.8–84.6] P MSEB0043 Turkey 0.0182617 0.0603251 0.6514980 0.1% [0–0.7] P MSEB0043 Unmapped 14.9959424 15.5211378 17.6947215 15.5% [15–17.7] P MSEB0043 Removed 1.7752821 1.8905281 2.0392039 1.9% [1.8–2] P MSEB0044 Bacteria 83.5210896 84.9906296 86.5133880 85% [83.5–86.5] P MSEB0044 Turkey 0.0080653 0.0274581 0.0989144 0% [0–0.1] P MSEB0044 Unmapped 13.2241987 14.3693125 15.4378358 14.4% [13.2–15.4] P MSEB0044 Removed 1.5822186 1.7263551 1.9232553 1.7% [1.6–1.9] P MSEB0045 Bacteria 82.3508961 84.6193457 85.9756554 84.6% [82.4–86] P MSEB0045 Turkey 0.0105255 0.0311007 0.0730272 0% [0–0.1] P MSEB0045 Unmapped 13.4687550 14.5327848 16.3119726 14.5% [13.5–16.3] P MSEB0045 Removed 2.0254291 2.1240288 2.2712657 2.1% [2–2.3] P MSEB0046 Bacteria 74.2299750 84.6805031 85.7276876 84.7% [74.2–85.7] P MSEB0046 Turkey 0.0396768 0.0668880 3.8427631 0.1% [0–3.8] P MSEB0046 Unmapped 12.9973831 14.1442125 14.7835713 14.1% [13–14.8] P MSEB0046 Removed 1.8415862 2.0623751 2.4170526 2.1% [1.8–2.4] P MSEB0047 Bacteria 77.1587525 85.3044997 86.0318982 85.3% [77.2–86] P MSEB0047 Turkey 0.0204822 0.0510766 1.8557002 0.1% [0–1.9] P MSEB0047 Unmapped 13.4511761 13.9991858 14.6097289 14% [13.5–14.6] P MSEB0047 Removed 1.4889355 1.6335126 2.0240630 1.6% [1.5–2] P MSEB0048 Bacteria 44.3119121 79.5957342 82.7621054 79.6% [44.3–82.8] P MSEB0048 Turkey 0.1161374 0.4561889 8.7927736 0.5% [0.1–8.8] P MSEB0048 Unmapped 15.3743041 16.4974759 19.2672206 16.5% [15.4–19.3] P MSEB0048 Removed 1.3131258 1.6093493 1.9238509 1.6% [1.3–1.9] P MSEB0049 Bacteria 35.5715021 74.9750661 83.6844949 75% [35.6–83.7] P MSEB0049 Turkey 0.2431261 1.0566258 13.8758066 1.1% [0.2–13.9] P MSEB0049 Unmapped 13.8179520 15.4889199 16.9442993 15.5% [13.8–16.9] P MSEB0049 Removed 1.5424711 1.7097963 2.1480213 1.7% [1.5–2.1] P MSEB0050 Bacteria 72.2037405 77.3274856 84.0068925 77.3% [72.2–84] P MSEB0050 Turkey 0.0260250 0.1860261 0.9077713 0.2% [0–0.9] P MSEB0050 Unmapped 15.4932886 17.0659670 25.7773520 17.1% [15.5–25.8] P MSEB0050 Removed 1.9281271 2.1525063 2.3540014 2.2% [1.9–2.4] P MSEB0051 Bacteria 64.1898671 73.5891383 83.5954659 73.6% [64.2–83.6] P MSEB0051 Turkey 0.1082772 1.5973252 13.5046668 1.6% [0.1–13.5] P MSEB0051 Unmapped 14.9626748 15.9121371 21.9471895 15.9% [15–21.9] P MSEB0051 Removed 1.6643115 1.7528041 2.0521254 1.8% [1.7–2.1] P MSEB0052 Bacteria 75.4714397 80.3653056 81.4467296 80.4% [75.5–81.4] P MSEB0052 Turkey 0.0157989 0.0659510 1.4378359 0.1% [0–1.4] P MSEB0052 Unmapped 14.0850042 18.4452630 19.2824423 18.4% [14.1–19.3] P MSEB0052 Removed 1.4784958 1.7128655 1.9542425 1.7% [1.5–2] P MSEB0053 Bacteria 75.2843254 80.6497342 82.1695767 80.6% [75.3–82.2] P MSEB0053 Turkey 0.0077423 0.0697835 1.1262749 0.1% [0–1.1] P MSEB0053 Unmapped 14.6916246 18.3726727 19.4179476 18.4% [14.7–19.4] P MSEB0053 Removed 1.2567151 1.4179257 1.5856805 1.4% [1.3–1.6] P MSEB0054 Bacteria 80.9539823 81.7838361 83.5732925 81.8% [81–83.6] P MSEB0054 Turkey 0.0257158 0.0393262 0.0742836 0% [0–0.1] P MSEB0054 Unmapped 15.3496390 17.8094652 18.5849505 17.8% [15.3–18.6] P MSEB0054 Removed 1.1057230 1.3786884 1.6344811 1.4% [1.1–1.6] P MSEB0055 Bacteria 80.4113285 81.4877636 84.2331777 81.5% [80.4–84.2] P MSEB0055 Turkey 0.0060460 0.0190133 0.0901665 0% [0–0.1] P MSEB0055 Unmapped 15.3220475 18.2083489 19.0241478 18.2% [15.3–19] P MSEB0055 Removed 1.7621776 2.0057958 2.3095357 2% [1.8–2.3] boxplot_reads_prc_1_batch &lt;- tidy_plot_data_stats_counts_prc %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;, &quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% ggplot(aes(x = batch, y = counts, color = label)) + geom_boxplot(outlier.shape = NA, color=&quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = color_palette_tidy_plot_data_stats_counts) + facet_nested(label ~ ., scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = NULL,y = &quot;Reads %&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2), axis.text.x = element_text(angle = 90, hjust = 1)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.20))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = batch, y = median, label = label_txt), inherit.aes = FALSE, vjust = -0.8, size = 2, alpha = 1, color = &quot;black&quot;) boxplot_reads_prc_1_batch var &lt;- &quot;counts&quot; summary_stats &lt;- tidy_plot_data_stats_counts_prc %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;,&quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% group_by(type_simple, section, label) %&gt;% #treatment_expl, age, summarise( Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), median = median(.data[[var]], na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% mutate( label_txt = paste0( &quot;&quot;, round(median, 1),&quot;%&quot;, &quot;\\n[&quot;, round(Q1, 1), &quot;–&quot;, round(Q3, 1), &quot;]&quot;)) knitr::kable(summary_stats) type_simple section label Q1 median Q3 label_txt P Caecum right Bacteria 74.3035568 81.8784869 84.566429 81.9% [74.3–84.6] P Caecum right Turkey 0.0220467 0.0822649 1.003598 0.1% [0–1] P Caecum right Unmapped 14.1923635 15.5623896 18.611575 15.6% [14.2–18.6] P Caecum right Removed 1.5771308 1.8370861 2.141348 1.8% [1.6–2.1] boxplot_reads_prc_1_all &lt;- tidy_plot_data_stats_counts_prc %&gt;% filter(type_simple == &quot;P&quot;)%&gt;% filter(mapping_status %in% c(&quot;bacteria_percentage&quot;, &quot;turkey_percentage&quot;, &quot;unmapped_percentage&quot;, &quot;trimmed_reads_percentage&quot;)) %&gt;% ggplot(aes(x = section, y = counts, color = label)) + geom_boxplot(outlier.shape = NA, color=&quot;black&quot;) + geom_jitter(width = 0.3, alpha = 0.3) + scale_color_manual(values = color_palette_tidy_plot_data_stats_counts) + facet_nested(label ~ ., scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = NULL,y = &quot;Reads %&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 10, 0.2, 0.2), axis.title.x = element_blank(), # remove x-axis title axis.text.x = element_blank(), # remove tick labels #axis.text.x = element_text(angle = 90, hjust = 1) axis.ticks.x = element_blank(), # remove tick marks ) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.21))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = section, y = median, label = label_txt), inherit.aes = FALSE, vjust = -0.3, size = 3, alpha = 1, color = &quot;black&quot;) boxplot_reads_prc_1_all (boxplot_reads_prc_1_all + boxplot_reads_prc_1_batch) + plot_annotation(tag_levels = &#39;a&#39;) + plot_layout(guides = &quot;collect&quot;, ncol = 2, # single column width = c(1, 8)) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.3.4 Collection attempts collection_attempts_plot_simple &lt;- plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% # filter(batch == &quot;MSEB0048&quot;) mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot; )) %&gt;% mutate(collection_attempts_text = factor(collection_attempts_text, levels = c(&quot;Fail&quot;, &quot;Two&quot;, &quot;One&quot;))) %&gt;% ggplot(aes(x = batch, fill = collection_attempts_text)) + labs(x = NULL, y = &quot;# of collection attempts&quot;) + geom_bar() + #position = &quot;fill&quot; geom_text(stat = &quot;count&quot;, aes(label = ..count.., group = collection_attempts_text), position = position_stack(vjust = 0.5), color = &quot;white&quot;) + # text colour; adjust for contrast scale_fill_manual(values = c(&quot;#685d79&quot;,&quot;#d9727f&quot;,&quot;#fcbb6d&quot;)) + facet_nested(. ~ type_simple, scales = &quot;free&quot;, space = &quot;free&quot;,switch = &quot;y&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90), plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;), panel.spacing = unit(0.3, &quot;lines&quot;), strip.text = element_text(size = 10, face = &quot;bold&quot;, color = &quot;black&quot;)) collection_attempts_plot_simple filter_status_plot_simple &lt;- plot_data_stats %&gt;% ggplot(aes(x = batch, fill = filter_status)) + labs(x = NULL, y = &quot;# of collection attempts&quot;) + geom_bar() + #position = &quot;fill&quot; geom_text(stat = &quot;count&quot;, aes(label = ..count.., group = filter_status), position = position_stack(vjust = 0.5), color = &quot;white&quot;) + # text colour; adjust for contrast scale_fill_manual(values = c(&quot;#685d79&quot;,&quot;#d9727f&quot;,&quot;#fcbb6d&quot;)) + facet_nested(. ~ type_simple, scales = &quot;free&quot;, space = &quot;free&quot;,switch = &quot;y&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 0), plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;), panel.spacing = unit(0.3, &quot;lines&quot;), strip.text = element_text(size = 10, face = &quot;bold&quot;, color = &quot;black&quot;)) filter_status_plot_simple &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 12.3.5 Collection attempts vs filtering retention collection_attempts_plot &lt;- plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot; )) %&gt;% mutate(collection_attempts_text = factor(collection_attempts_text, levels = c(&quot;Fail&quot;, &quot;Two&quot;, &quot;One&quot;))) %&gt;% ggplot(aes(x = batch, fill = collection_attempts_text)) + labs(x = NULL, y = &quot;# of collection attempts&quot;) + geom_bar() + #position = &quot;fill&quot; scale_fill_manual(values = c(&quot;#685d79&quot;,&quot;#d9727f&quot;,&quot;#fcbb6d&quot;)) + facet_nested(. ~ filter_status, scales = &quot;free&quot;, space = &quot;free&quot;,switch = &quot;y&quot;) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_blank(), plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;), panel.spacing = unit(0.3, &quot;lines&quot;), strip.text = element_text(size = 10, face = &quot;bold&quot;, color = &quot;black&quot;)) barplot_collection_reads_after &lt;- plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot; )) %&gt;% ggplot(aes(x = batch, y = total_sequences_after_trim)) + labs(x = &quot;Batch&quot;, y = &quot;# of reads after trimming&quot;) + geom_boxplot(outlier.shape = NA) + geom_jitter(aes(color = collection_attempts_text), width = 0.2, alpha = 0.5, size=1.5) + scale_color_manual(values = c(&quot;#685d79&quot;,&quot;#d9727f&quot;,&quot;#fcbb6d&quot;)) + facet_nested(. ~ filter_status, scales = &quot;free&quot;, space = &quot;free&quot;) + theme_minimal() + custom_ggplot_theme + guides(color = &quot;none&quot;) + # Remove legend theme(axis.text.x = element_text(angle = 90, hjust = 1), strip.background = element_blank(), strip.text.x = element_blank(), plot.margin = unit(c(0, 0, 0, 0), &quot;cm&quot;), panel.spacing = unit(0.3, &quot;lines&quot;), strip.text = element_text(size = 10, face = &quot;bold&quot;, color = &quot;black&quot;)) # collection_attempts_plot / barplot_collection_reads_after + # plot_annotation(tag_levels = &#39;a&#39;) + # plot_layout(guides = &quot;collect&quot;) &amp; # theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) # # ggtitle(&quot;*Microsample M305574 removed (2 attempts)&quot;) scale_fonts = 0.9 plot_attempts &lt;- collection_attempts_plot / barplot_collection_reads_after + plot_annotation(tag_levels = &#39;a&#39;) + plot_layout(guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) # ggtitle(&quot;*Microsample M305574 removed (2 attempts)&quot;) plot_attempts + theme( legend.position = &quot;none&quot;) &amp; theme( axis.text = element_text(size = rel(scale_fonts)), # axis tick labels axis.title = element_text(size = rel(scale_fonts)), # axis titles strip.text = element_text(size = rel(scale_fonts)), # facet labels plot.title = element_text(size = rel(scale_fonts)), # plot titles legend.text = element_text(size = rel(scale_fonts)), # legend text legend.title = element_text(size = rel(scale_fonts)) # legend title ) plot_data_stats %&gt;% filter(collection_attempts &gt; 0, type_simple == &quot;P&quot;) %&gt;% mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot;, TRUE ~ &quot;Other&quot; )) %&gt;% count(filter_status, collection_attempts_text) %&gt;% group_by(filter_status) %&gt;% mutate(percent = 100 * n / sum(n)) %&gt;% ungroup() # A tibble: 6 × 4 filter_status collection_attempts_text n percent &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 Excluded from filtering Fail 29 59.2 2 Excluded from filtering One 17 34.7 3 Excluded from filtering Two 3 6.12 4 Retained by filtering Fail 142 12.6 5 Retained by filtering One 743 66.0 6 Retained by filtering Two 241 21.4 plot_data_stats %&gt;% filter(collection_attempts &gt; 0, type_simple == &quot;P&quot;) %&gt;% count(filter_status) %&gt;% # group_by(filter_status) %&gt;% mutate(percent = 100 * n / sum(n)) %&gt;% ungroup() # A tibble: 2 × 3 filter_status n percent &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 Excluded from filtering 49 4.17 2 Retained by filtering 1126 95.8 var &lt;- &quot;total_sequences_after_trim&quot; plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_status == &quot;Excluded from filtering&quot;) %&gt;% select(microsample, filter_status, collection_attempts, collection, total_sequences_after_trim) %&gt;% group_by(filter_status) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) # A tibble: 1 × 5 filter_status median IQR Q1 Q3 &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 Excluded from filtering 404160 1432942 265862 1698804 plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot;)) %&gt;% select(microsample, filter_status, collection_attempts_text, total_sequences_after_trim) %&gt;% count(collection_attempts_text) %&gt;% mutate(percent = 100 * n / sum(n)) # A tibble: 3 × 3 collection_attempts_text n percent &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 Fail 142 12.6 2 One 743 66.0 3 Two 241 21.4 var &lt;- &quot;total_sequences_after_trim&quot; plot_data_stats %&gt;% filter(collection_attempts &gt;0) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% mutate(collection_attempts_text = case_when( collection == &quot;Fail&quot; ~ &quot;Fail&quot;, collection_attempts == 1 ~ &quot;One&quot;, collection_attempts == 2 ~ &quot;Two&quot;)) %&gt;% select(microsample, filter_status, collection_attempts_text, total_sequences_after_trim) %&gt;% group_by(collection_attempts_text) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = paste0(&quot;&quot;, format(median, scientific = TRUE, digits = 2))) # A tibble: 3 × 6 collection_attempts_text median IQR Q1 Q3 label_txt &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; 1 Fail 22489991 25385741 5015120 30400861 2.2e+07 2 One 28437666 27578028 17203632 44781660 2.8e+07 3 Two 29158200 29214266 17931182 47145448 2.9e+07 # Select data &amp; pivot to wide df neg_vs_pos_wide &lt;- tidy_plot_genome_counts %&gt;% # arrange samples: first negatives, then positives (for ALDEx2). arrange(type_simple) %&gt;% select(genome, microsample, count) %&gt;% pivot_wider( names_from = genome, values_from = count, values_fill = 0 ) %&gt;% select(where(~ any(. != 0))) %&gt;% mutate(across(-microsample, ~ . / rowSums(across(where(is.numeric))) * 100 )) %&gt;% column_to_rownames(var = &quot;microsample&quot;) # Remove taxa in few samples, and samples with few taxa neg_vs_pos_wide &lt;- remove_samples_or_taxa(df = neg_vs_pos_wide, min_samples_per_taxon = 10, min_taxa_per_sample = 10) Initial df: Rows (samples): 1344 , Columns (taxa): 526 Removed: Rows (samples): 0 , Columns (taxa): 0 Resulting df: Rows (samples): 1344 , Columns (taxa): 526 # Remove taxa with less than 0.1% rel. abun. in all samples # neg_vs_pos_wide &lt;- neg_vs_pos_wide %&gt;% select(where(~ any(. &gt;= 0.1))) # Perform PCA &amp; make PCA plot neg_pos_PCA &lt;- perform_pca(neg_vs_pos_wide, z_delete = TRUE) [1] &quot;Zeros found&quot; No. adjusted imputations: 70993 Rows (samples) removed after zero replacement: 27 Columns (taxa) removed after zero replacement: 0 plot_data_stats_temp &lt;- plot_data_stats %&gt;% mutate(collection_type_simple = case_when ( type_simple == &quot;N&quot; ~ &quot;Negative Sample&quot;, collection == &quot;Fail&quot; ~ &quot;Microsample: Failed Collection&quot;, collection_attempts == 0 ~ &quot;Microsample: One Collection&quot;, collection_attempts == 1 ~ &quot;Microsample: One Collection&quot;, collection_attempts == 2 ~ &quot;Microsample: Two Collections&quot;)) neg_pos_pca_plot &lt;- plot_pca(neg_pos_PCA$pca_result, samples_color_metadata = &quot;collection_type_simple&quot;, samples_shape_metadata = &quot;filter_status&quot;, samples_color_value = c(&quot;#685d79&quot;,&quot;#fcbb6d&quot;, &quot;#d9727f&quot;, &quot;#3cb2bd&quot;), loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;species&quot;, sample_metadata = plot_data_stats_temp, genome_metadata = genome_metadata, order_colors, custom_ggplot_theme, loadings_number = 20 # nrow(neg_vs_pos_ALDEx2_significant) ) + theme(plot.margin = unit(c(0, 0, 1, 0), &quot;cm&quot;)) neg_pos_pca_plot # Calculate Euclidean distance on CLR data neg_pos_dist_matrix &lt;- vegdist(neg_pos_PCA$df_clr_dist, method = &quot;euclidean&quot;) # Make sure that filtered df and metadata have the same number &amp; order of rows # Get the exact order of rownames from the PCA data pca_rownames &lt;- rownames(neg_pos_PCA$df_clr_dist) # Filter and reorder metadata to match exactly neg_pos_metadata_adonis &lt;- plot_data_stats_temp %&gt;% filter(microsample %in% pca_rownames) %&gt;% # Create a factor with levels in the exact order of pca_rownames, then arrange mutate(microsample_ordered = factor(microsample, levels = pca_rownames)) %&gt;% arrange(microsample_ordered) %&gt;% select(microsample, animal, treatment, age_category, filter_status, collection_type_simple) # Verify the order matches all(neg_pos_metadata_adonis$microsample == pca_rownames) [1] TRUE # Run PERMANOVA adonis2_result &lt;- adonis2( neg_pos_dist_matrix ~ animal + filter_status + collection_type_simple , data = neg_pos_metadata_adonis, permutations = 999, by = &quot;terms&quot; ) knitr::kable(adonis2_result) Df SumOfSqs R2 F Pr(&gt;F) animal 13 1249612.98 0.4935672 111.680032 0.001 filter_status 1 149476.65 0.0590397 173.666766 0.001 collection_type_simple 3 14647.48 0.0057854 5.672637 0.001 Residual 1299 1118061.76 0.4416077 NA NA Total 1316 2531798.87 1.0000000 NA NA plot_data_stats_temp %&gt;% select(microsample, type_simple, filter_status) %&gt;% group_by(type_simple) %&gt;% count(filter_status) %&gt;% mutate(percent = 100 * n / sum(n)) # A tibble: 4 × 4 # Groups: type_simple [2] type_simple filter_status n percent &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 N Excluded from filtering 153 91.1 2 N Retained by filtering 15 8.93 3 P Excluded from filtering 49 4.17 4 P Retained by filtering 1127 95.8 plot_data_stats_temp %&gt;% select(microsample, type_simple, collection, filter_status) %&gt;% group_by(type_simple, collection) %&gt;% count(filter_status) %&gt;% mutate(percent = 100 * n / sum(n)) # A tibble: 11 × 5 # Groups: type_simple, collection [6] type_simple collection filter_status n percent &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; 1 N Fail Excluded from filtering 12 75 2 N Fail Retained by filtering 4 25 3 N Success Excluded from filtering 36 90 4 N Success Retained by filtering 4 10 5 N &lt;NA&gt; Excluded from filtering 105 93.8 6 N &lt;NA&gt; Retained by filtering 7 6.25 7 P Fail Excluded from filtering 29 17.0 8 P Fail Retained by filtering 142 83.0 9 P Success Excluded from filtering 20 1.99 10 P Success Retained by filtering 984 98.0 11 P &lt;NA&gt; Retained by filtering 1 100 "],["bacterial-load.html", "13 Bacterial Load 13.1 Macro-samples 13.2 Micro-samples", " 13 Bacterial Load load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/macro/seq_stats.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/seq_stats.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 13.1 Macro-samples var &lt;- &quot;bacteria_over_turkey&quot; summary_stats &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% group_by(treatment_expl, age_category) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 2)) knitr::kable(summary_stats) treatment_expl age_category median IQR Q1 Q3 label_txt ControlGroup a 5.7473492 11.0850644 0.7148612 11.7999256 5.75 ControlGroup b 1.8912451 78.5331746 0.5213194 79.0544940 1.89 ControlGroup c 8.1873234 26.5122028 5.8685884 32.3807912 8.19 ControlGroup d 3.7814958 4.0717890 3.5822751 7.6540641 3.78 OnlyHistomonas a 2.4124964 18.1485893 0.6893635 18.8379528 2.41 OnlyHistomonas b 0.0301109 0.0350869 0.0171992 0.0522861 0.03 OnlyHistomonas c 0.2325433 0.6159796 0.1112350 0.7272146 0.23 VaccinatedCloacal&amp;Histomonas a 24.8459738 14.5859665 18.5128959 33.0988624 24.85 VaccinatedCloacal&amp;Histomonas b 0.0721774 0.0723341 0.0336796 0.1060137 0.07 VaccinatedCloacal&amp;Histomonas c 0.4610444 6.0564843 0.1613420 6.2178262 0.46 VaccinatedCloacal&amp;Histomonas d 16.2542842 26.5992858 4.5857692 31.1850550 16.25 VaccinatedOral&amp;Histomonas a 28.4852724 30.2036219 13.5387787 43.7424007 28.49 VaccinatedOral&amp;Histomonas b 0.0664999 0.1712118 0.0486245 0.2198364 0.07 VaccinatedOral&amp;Histomonas c 5.0136431 13.8623042 0.3665152 14.2288194 5.01 VaccinatedOral&amp;Histomonas d 1.0409784 5.2712878 0.8418797 6.1131675 1.04 bacterial_load_macro_plot_log &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = age_category, y = bacteria_over_turkey, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl , scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;Bacterial-to-host read ratio (log scale)&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + scale_y_log10(labels = scales::comma) + annotation_logticks(sides = &quot;l&quot;) + # adds log ticks on y-axis theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + # scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = age_category, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ bacterial_load_macro_plot_log bacterial_load_macro_plot &lt;- plot_data_stats_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = age_category, y = bacteria_over_turkey, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl , scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;bacteria/host reads&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + scale_y_log10() + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = age_category, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ bacterial_load_macro_plot 13.2 Micro-samples var &lt;- &quot;bacteria_over_turkey&quot; summary_stats &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% group_by(treatment_expl, age) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 2)) knitr::kable(summary_stats) treatment_expl age median IQR Q1 Q3 label_txt ControlGroup 0 2152.39500 3514.4705 401.906755 3916.3772 2152.40 ControlGroup 21 3252.42804 6107.4893 279.577827 6387.0671 3252.43 OnlyHistomonas 0 382.72757 4081.5403 10.725914 4092.2662 382.73 VaccinatedCloacal&amp;Histomonas 0 744.55294 5288.8319 32.601802 5321.4338 744.55 VaccinatedCloacal&amp;Histomonas 21 297.57231 2514.0012 10.890785 2524.8920 297.57 VaccinatedOral&amp;Histomonas 0 49.62122 395.5746 1.736523 397.3111 49.62 VaccinatedOral&amp;Histomonas 21 116.31067 1170.2565 12.370369 1182.6269 116.31 bacterial_load_plot_log &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = age, y = bacteria_over_turkey, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl , scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;Bacterial-to-host read ratio (log scale)&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + scale_y_log10(labels = scales::comma) + annotation_logticks(sides = &quot;l&quot;) + # adds log ticks on y-axis theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + # scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = age, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ #ggtitle(&quot;Layers&quot;) bacterial_load_plot_log bacterial_load_plot &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = age, y = bacteria_over_turkey, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl , scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;bacteria/host reads&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + scale_y_log10() + theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = age, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ #ggtitle(&quot;Layers&quot;) bacterial_load_plot var &lt;- &quot;bacteria_over_turkey&quot; summary_stats &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% group_by(treatment_expl, animal, age, section) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 2)) knitr::kable(summary_stats) treatment_expl animal age section median IQR Q1 Q3 label_txt ControlGroup M061a 0 Caecum right 1232.461010 2659.1002 165.7165136 2824.8167 1232.46 ControlGroup M065a 0 Caecum right 2349.540365 2292.2271 1867.6655620 4159.8927 2349.54 ControlGroup M078d 21 Caecum right 5265.028520 8109.5958 1291.2844977 9400.8803 5265.03 ControlGroup M080d 21 Caecum right 1645.332817 3562.0022 110.4828677 3672.4850 1645.33 OnlyHistomonas M041a 0 Caecum right 19.885748 118.3556 1.1190290 119.4746 19.89 OnlyHistomonas M042a 0 Caecum right 4105.214523 5095.0308 999.2916919 6094.3225 4105.21 VaccinatedCloacal&amp;Histomonas M002a 0 Caecum right 60.852846 545.5267 9.7662442 555.2929 60.85 VaccinatedCloacal&amp;Histomonas M003a 0 Caecum right 5485.634057 11722.0986 1325.1362404 13047.2349 5485.63 VaccinatedCloacal&amp;Histomonas M017d 21 Caecum right 26.092771 207.6554 2.8509702 210.5064 26.09 VaccinatedCloacal&amp;Histomonas M018d 21 Caecum right 2269.858746 3683.4998 594.3299752 4277.8298 2269.86 VaccinatedOral&amp;Histomonas M021a 0 Caecum right 92.250702 411.4121 6.2387842 417.6509 92.25 VaccinatedOral&amp;Histomonas M022a 0 Caecum right 7.511314 296.3594 0.8502298 297.2097 7.51 VaccinatedOral&amp;Histomonas M038d 21 Caecum right 41.495329 349.2195 5.5225025 354.7420 41.50 VaccinatedOral&amp;Histomonas M039d 21 Caecum right 472.148744 2479.8437 24.5894334 2504.4332 472.15 bacterial_load_plot_log_animal &lt;- plot_data_stats %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = section, y = bacteria_over_turkey, color = treatment)) + geom_boxplot(outlier.shape = NA, color = &quot;black&quot;) + geom_jitter(width = 0.05, alpha = 0.5) + scale_color_manual(values = treatment_colours_bright) + facet_nested( . ~ treatment_expl + age + animal, scales = &quot;fixed&quot;, space = &quot;fixed&quot;, switch = &quot;y&quot;) + labs(x = &quot;Days post infection&quot;, y = &quot;Bacterial-to-host read ratio (log scale)&quot;) + guides(color = &quot;none&quot;) + # Remove legend theme_minimal() + custom_ggplot_theme + scale_y_log10(labels = scales::comma) + annotation_logticks(sides = &quot;l&quot;) + # adds log ticks on y-axis theme(panel.spacing = unit(0.3, &quot;lines&quot;), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + # scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + # median + IQR text (placed a bit above the median line) geom_text( data = summary_stats, aes(x = section, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) #+ #ggtitle(&quot;Layers&quot;) bacterial_load_plot_log_animal "],["alpha-diversity.html", "14 Alpha Diversity 14.1 Prepare tidy tables for plotting 14.2 Macro-samples 14.3 Micro-samples", " 14 Alpha Diversity load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/macro/counts.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/counts.Rdata&quot;) load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 14.1 Prepare tidy tables for plotting 14.1.1 Alpha diversity tidy tables Create tidy table for alpha diversity (micro) tidy_plot_alpha_diversity_genomes &lt;- plot_data_stats %&gt;% pivot_longer( cols = c(richness, neutral, phylogenetic), names_to = &quot;metric&quot;, values_to = &quot;value&quot; ) %&gt;% mutate(metric = factor(metric, levels = c(&quot;richness&quot;, &quot;neutral&quot;, &quot;phylogenetic&quot;))) Create tidy table for alpha diversity (macro) tidy_plot_alpha_diversity_genomes_macro &lt;- plot_data_stats_macro %&gt;% pivot_longer( cols = c(richness, neutral, phylogenetic), names_to = &quot;metric&quot;, values_to = &quot;value&quot; ) %&gt;% mutate(metric = factor(metric, levels = c(&quot;richness&quot;, &quot;neutral&quot;, &quot;phylogenetic&quot;))) 14.1.2 Genome counts tidy tables Create tidy tables for filtered genome counts (micro) tidy_plot_genome_counts_filt_30_closed &lt;- genome_counts_filt_30 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) Create tidy tables for filtered genome counts (macro) tidy_plot_genome_counts_filt_30_macro_closed &lt;- genome_counts_macro_filt_30 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) 14.2 Macro-samples 14.2.1 Alpha-div var &lt;- &quot;value&quot; summary_stats &lt;- tidy_plot_alpha_diversity_genomes_macro %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% # filter(filter_level == &#39;filtered_30&#39;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% # to remove empty samples group_by(treatment_expl, age_category, metric) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 1)) #format(median, scientific = TRUE, digits = 5)) knitr::kable(summary_stats) treatment_expl age_category metric median IQR Q1 Q3 label_txt ControlGroup a richness 210.000000 98.0000000 138.000000 236.000000 210.0 ControlGroup a neutral 83.811909 32.8752555 59.397392 92.272648 83.8 ControlGroup a phylogenetic 6.696391 0.7547965 6.258387 7.013183 6.7 ControlGroup b richness 262.000000 103.0000000 175.000000 278.000000 262.0 ControlGroup b neutral 85.913403 17.7706682 76.580196 94.350864 85.9 ControlGroup b phylogenetic 7.801862 1.6404552 7.433081 9.073536 7.8 ControlGroup c richness 225.000000 42.7500000 210.750000 253.500000 225.0 ControlGroup c neutral 79.011578 11.0493141 74.089534 85.138848 79.0 ControlGroup c phylogenetic 7.686419 0.5045590 7.324135 7.828694 7.7 ControlGroup d richness 212.000000 18.0000000 205.250000 223.250000 212.0 ControlGroup d neutral 77.070687 20.1219134 67.456909 87.578822 77.1 ControlGroup d phylogenetic 7.630725 0.5222967 7.222578 7.744874 7.6 OnlyHistomonas a richness 213.000000 29.0000000 198.000000 227.000000 213.0 OnlyHistomonas a neutral 92.572615 12.2730843 86.960644 99.233728 92.6 OnlyHistomonas a phylogenetic 6.284060 0.6118000 5.889814 6.501614 6.3 OnlyHistomonas b richness 10.000000 8.0000000 4.000000 12.000000 10.0 OnlyHistomonas b neutral 6.828946 6.1434774 3.533646 9.677124 6.8 OnlyHistomonas b phylogenetic 4.036856 0.7414506 3.582019 4.323469 4.0 OnlyHistomonas c richness 25.000000 15.5000000 17.500000 33.000000 25.0 OnlyHistomonas c neutral 9.820644 5.0179333 7.941182 12.959115 9.8 OnlyHistomonas c phylogenetic 4.084129 1.1346151 3.609400 4.744015 4.1 VaccinatedCloacal&amp;Histomonas a richness 178.500000 84.0000000 143.500000 227.500000 178.5 VaccinatedCloacal&amp;Histomonas a neutral 73.283154 9.7468985 66.995456 76.742355 73.3 VaccinatedCloacal&amp;Histomonas a phylogenetic 5.584873 0.7026976 5.141251 5.843949 5.6 VaccinatedCloacal&amp;Histomonas b richness 9.000000 11.0000000 6.000000 17.000000 9.0 VaccinatedCloacal&amp;Histomonas b neutral 4.805473 8.9287820 2.829573 11.758355 4.8 VaccinatedCloacal&amp;Histomonas b phylogenetic 3.877432 1.7102515 2.580326 4.290578 3.9 VaccinatedCloacal&amp;Histomonas c richness 61.000000 93.0000000 37.000000 130.000000 61.0 VaccinatedCloacal&amp;Histomonas c neutral 19.031655 16.5854099 15.355569 31.940978 19.0 VaccinatedCloacal&amp;Histomonas c phylogenetic 4.742644 1.1812226 4.708435 5.889657 4.7 VaccinatedCloacal&amp;Histomonas d richness 203.000000 107.0000000 134.250000 241.250000 203.0 VaccinatedCloacal&amp;Histomonas d neutral 72.419728 38.9935100 48.231406 87.224916 72.4 VaccinatedCloacal&amp;Histomonas d phylogenetic 6.672006 1.3006379 5.902491 7.203129 6.7 VaccinatedOral&amp;Histomonas a richness 229.500000 93.0000000 182.250000 275.250000 229.5 VaccinatedOral&amp;Histomonas a neutral 97.656057 45.8913381 74.102555 119.993893 97.7 VaccinatedOral&amp;Histomonas a phylogenetic 6.598823 0.3352976 6.366943 6.702240 6.6 VaccinatedOral&amp;Histomonas b richness 24.000000 43.5000000 11.500000 55.000000 24.0 VaccinatedOral&amp;Histomonas b neutral 15.375341 21.4031885 6.951692 28.354880 15.4 VaccinatedOral&amp;Histomonas b phylogenetic 4.971620 1.3565209 4.374426 5.730947 5.0 VaccinatedOral&amp;Histomonas c richness 107.000000 77.0000000 50.000000 127.000000 107.0 VaccinatedOral&amp;Histomonas c neutral 25.883164 4.3196914 22.355050 26.674741 25.9 VaccinatedOral&amp;Histomonas c phylogenetic 5.519981 0.8902031 4.972761 5.862964 5.5 VaccinatedOral&amp;Histomonas d richness 147.000000 125.0000000 61.000000 186.000000 147.0 VaccinatedOral&amp;Histomonas d neutral 47.675856 38.8252638 9.642039 48.467303 47.7 VaccinatedOral&amp;Histomonas d phylogenetic 6.695277 4.1891537 2.902256 7.091409 6.7 plot_alpha_div_macro &lt;- tidy_plot_alpha_diversity_genomes_macro %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_level == &#39;filtered_30&#39;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% # to remove empty samples ggplot(aes(x = age_category, y = value, fill = treatment)) + geom_boxplot(outlier.shape = NA, alpha = 0.9) + scale_fill_manual(name = &quot;Treatment&quot;, breaks = names(treatment_colours_bright), values = treatment_colours_bright) + geom_jitter(width = 0.1, alpha = 0.6) + facet_nested(metric ~ treatment_expl, scales = &quot;free&quot;, space = &quot;fixed&quot;) + # geom_text(aes(label = animal), # position = position_jitter(width = 0.2, height = 0), # size = 3.0, alpha = 0.7, check_overlap = TRUE, color=&quot;#8c1c47&quot;) + labs(x = &quot;Days Post Infection&quot;, y = &quot;a-div value&quot;) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + geom_text( data = summary_stats, aes(x = age_category, y = median, label = label_txt), inherit.aes = FALSE, vjust = -3.0, size = 3, alpha = 1, color = &quot;black&quot;) + expand_limits(y = 0) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + ggtitle(&quot;Alpha diversity - 30% coverage filter&quot;) plot_alpha_div_macro 14.2.2 Alpha-div vs genome size tidy_plot_genome_counts_filt_30_macro_closed_zerosrem &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(count &gt; 0) median_lengths &lt;- tidy_plot_genome_counts_filt_30_macro_closed_zerosrem %&gt;% group_by(microsample) %&gt;% summarise(median_genome_length = median(length, na.rm = TRUE), .groups = &quot;drop&quot;) alpha_div_macro_filtered_30_gen_length &lt;- alpha_div_macro_filtered_30 %&gt;% left_join(median_lengths, by = join_by(microsample == microsample)) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) %&gt;% filter(treatment != &quot;TM0&quot;) alpha_div_macro_filtered_30_gen_length &lt;- plot_data_stats_macro %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_level == &quot;filtered_30&quot;) %&gt;% left_join(median_lengths, by = join_by(microsample == microsample)) %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) # alpha_div_macro_filtered_30_gen_length %&gt;% # ggplot(aes(x = median_genome_length, y = richness, color = treatment, shape = factor(age_category))) + # geom_point(size = 3, alpha = 0.8) + # geom_smooth(method = &quot;lm&quot;, se = TRUE, aes(group = 1), color = &quot;black&quot;, linewidth = 1) + # scale_color_manual(values = treatment_colours_bright, name = &quot;Treatment&quot;) + # scale_shape_manual( # name = &quot;DPI&quot;, # values = c(&quot;a&quot; = 16, &quot;b&quot; = 17, &quot;c&quot; = 15, &quot;d&quot; = 4) # Example shapes # ) + # labs(x = &quot;Median genome length (bp) per sample&quot;, y = &quot;Richness&quot;) + # ylim(c(-5,300)) + # theme_minimal() + # custom_ggplot_theme # Fit model model_nb &lt;- glm.nb(richness ~ median_genome_length, data = alpha_div_macro_filtered_30_gen_length) # Fit null model (intercept only) model_null &lt;- glm.nb(richness ~ 1, data = alpha_div_macro_filtered_30_gen_length) # Manual McFadden pseudo-R² pseudo_r2 &lt;- 1 - (logLik(model_nb) / logLik(model_null)) pseudo_r2 &#39;log Lik.&#39; 0.1045218 (df=3) # Spearman correlation cor_test &lt;- cor.test( ~ richness + median_genome_length, data = alpha_div_macro_filtered_30_gen_length, method = &quot;spearman&quot; ) rho &lt;- cor_test$estimate pval &lt;- cor_test$p.value # Create new data for prediction newdata &lt;- data.frame( median_genome_length = seq( min(alpha_div_macro_filtered_30_gen_length$median_genome_length, na.rm = TRUE), max(alpha_div_macro_filtered_30_gen_length$median_genome_length, na.rm = TRUE), length.out = 200 ) ) # Get predictions + SE on link scale pred &lt;- predict(model_nb, newdata, type = &quot;link&quot;, se.fit = TRUE) # Add predicted values to newdata (back-transform with exp) newdata$fit &lt;- exp(pred$fit) newdata$lwr &lt;- exp(pred$fit - 1.96 * pred$se.fit) # 95% CI lower newdata$upr &lt;- exp(pred$fit + 1.96 * pred$se.fit) # 95% CI upper x_pos &lt;- max(alpha_div_macro_filtered_30_gen_length$median_genome_length, na.rm = TRUE) * 0.98 y_pos &lt;- max(alpha_div_macro_filtered_30_gen_length$richness, na.rm = TRUE) * 0.95 # Plot with fitted NB curve ggplot(alpha_div_macro_filtered_30_gen_length, aes(x = median_genome_length, y = richness)) + # NB fit + CI geom_ribbon(data = newdata, aes(x = median_genome_length, ymin = lwr, ymax = upr), fill = &quot;grey70&quot;, alpha = 0.4, inherit.aes = FALSE) + geom_line(data = newdata, aes(x = median_genome_length, y = fit), color = &quot;black&quot;, linewidth = 1.2, inherit.aes = FALSE) + geom_point(aes(color = treatment, shape = factor(age_category)), size = 3, alpha = 0.8) + # ➊ Spearman rho + p-value annotate(&quot;text&quot;, x = x_pos, y = y_pos, label = paste0(&quot;Spearman ρ = &quot;, round(rho, 2), &quot;\\np = &quot;, signif(pval, 2)), hjust = 1, vjust = 1, size = 3) + # ➋ Pseudo-R² annotate(&quot;text&quot;, x = x_pos, y = y_pos * 0.85, label = paste0(&quot;\\nPseudo–R² = &quot;, round(pseudo_r2, 3)), hjust = 1, vjust = 1, size = 3) + scale_color_manual(values = treatment_colours_bright, name = &quot;Treatment&quot;) + scale_shape_manual(name = &quot;DPI&quot;, values = c(&quot;a&quot; = 16, &quot;b&quot; = 17, &quot;c&quot; = 15, &quot;d&quot; = 4)) + labs(x = &quot;Median genome length (bp) per sample&quot;, y = &quot;Richness&quot;) + theme_minimal() + custom_ggplot_theme 14.3 Micro-samples 14.3.1 Alpha diversity var &lt;- &quot;value&quot; summary_stats &lt;- tidy_plot_alpha_diversity_genomes %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% # filter(filter_level == &#39;filtered_30&#39;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% # to remove empty samples group_by(treatment_expl, age_category, metric, animal) %&gt;% summarise( median = median(.data[[var]], na.rm = TRUE), IQR = IQR(.data[[var]], na.rm = TRUE), Q1 = quantile(.data[[var]], 0.25, na.rm = TRUE), Q3 = quantile(.data[[var]], 0.75, na.rm = TRUE) ) %&gt;% mutate(label_txt = formatC(median, format = &quot;f&quot;, digits = 1)) #format(median, scientific = TRUE, digits = 5)) knitr::kable(summary_stats) treatment_expl age_category metric animal median IQR Q1 Q3 label_txt ControlGroup a richness M061a 130.500000 34.0000000 109.250000 143.250000 130.5 ControlGroup a richness M065a 157.500000 53.0000000 134.000000 187.000000 157.5 ControlGroup a neutral M061a 65.845900 11.6891430 58.483977 70.173120 65.8 ControlGroup a neutral M065a 73.967935 17.5288031 64.139521 81.668324 74.0 ControlGroup a phylogenetic M061a 5.525477 0.2984958 5.320437 5.618932 5.5 ControlGroup a phylogenetic M065a 5.127197 0.6600657 4.771212 5.431278 5.1 ControlGroup d richness M078d 139.000000 62.0000000 99.000000 161.000000 139.0 ControlGroup d richness M080d 130.000000 71.5000000 95.500000 167.000000 130.0 ControlGroup d neutral M078d 50.816185 18.3957608 38.670258 57.066019 50.8 ControlGroup d neutral M080d 65.907097 23.7889916 52.513692 76.302684 65.9 ControlGroup d phylogenetic M078d 4.148053 0.4284805 3.983931 4.412412 4.1 ControlGroup d phylogenetic M080d 4.507315 0.5140530 4.223553 4.737606 4.5 OnlyHistomonas a richness M041a 55.500000 56.2500000 20.750000 77.000000 55.5 OnlyHistomonas a richness M042a 177.000000 39.0000000 155.000000 194.000000 177.0 OnlyHistomonas a neutral M041a 38.101501 31.3992176 15.789598 47.188815 38.1 OnlyHistomonas a neutral M042a 96.412950 20.5186346 83.608790 104.127425 96.4 OnlyHistomonas a phylogenetic M041a 3.736384 0.5362499 3.456220 3.992470 3.7 OnlyHistomonas a phylogenetic M042a 4.631626 0.4538228 4.365442 4.819264 4.6 VaccinatedCloacal&amp;Histomonas a richness M002a 56.000000 62.2500000 26.500000 88.750000 56.0 VaccinatedCloacal&amp;Histomonas a richness M003a 77.000000 19.0000000 69.000000 88.000000 77.0 VaccinatedCloacal&amp;Histomonas a neutral M002a 32.958140 25.2620550 17.536660 42.798715 33.0 VaccinatedCloacal&amp;Histomonas a neutral M003a 42.785067 9.5763010 37.868745 47.445046 42.8 VaccinatedCloacal&amp;Histomonas a phylogenetic M002a 4.136386 0.8227032 3.607391 4.430094 4.1 VaccinatedCloacal&amp;Histomonas a phylogenetic M003a 3.586387 0.4317854 3.295357 3.727143 3.6 VaccinatedCloacal&amp;Histomonas d richness M017d 31.500000 39.7500000 13.500000 53.250000 31.5 VaccinatedCloacal&amp;Histomonas d richness M018d 98.000000 37.0000000 79.000000 116.000000 98.0 VaccinatedCloacal&amp;Histomonas d neutral M017d 22.539126 22.8242044 10.113384 32.937588 22.5 VaccinatedCloacal&amp;Histomonas d neutral M018d 52.806886 13.5884550 44.781267 58.369722 52.8 VaccinatedCloacal&amp;Histomonas d phylogenetic M017d 4.559298 1.2170197 3.757188 4.974207 4.6 VaccinatedCloacal&amp;Histomonas d phylogenetic M018d 5.312937 0.6620478 4.867675 5.529723 5.3 VaccinatedOral&amp;Histomonas a richness M021a 55.500000 49.7500000 26.500000 76.250000 55.5 VaccinatedOral&amp;Histomonas a richness M022a 66.000000 51.2500000 40.750000 92.000000 66.0 VaccinatedOral&amp;Histomonas a neutral M021a 29.763472 22.6535874 17.093991 39.747579 29.8 VaccinatedOral&amp;Histomonas a neutral M022a 38.110138 19.6758541 27.710731 47.386586 38.1 VaccinatedOral&amp;Histomonas a phylogenetic M021a 4.377165 0.5961356 4.108973 4.705109 4.4 VaccinatedOral&amp;Histomonas a phylogenetic M022a 3.921068 0.6018992 3.668648 4.270547 3.9 VaccinatedOral&amp;Histomonas d richness M038d 80.000000 28.5000000 66.000000 94.500000 80.0 VaccinatedOral&amp;Histomonas d richness M039d 104.000000 25.5000000 88.250000 113.750000 104.0 VaccinatedOral&amp;Histomonas d neutral M038d 49.006582 13.0411587 41.853412 54.894570 49.0 VaccinatedOral&amp;Histomonas d neutral M039d 57.961846 9.0889236 52.534251 61.623175 58.0 VaccinatedOral&amp;Histomonas d phylogenetic M038d 6.008672 0.9258856 5.516224 6.442110 6.0 VaccinatedOral&amp;Histomonas d phylogenetic M039d 5.421190 0.3200240 5.303203 5.623227 5.4 plot_alpha_div_micro &lt;- tidy_plot_alpha_diversity_genomes %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_level == &#39;filtered_30&#39;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) %&gt;% # to remove empty samples ggplot(aes(x = animal, y = value, fill = treatment)) + geom_boxplot(outlier.shape = NA, alpha = 0.9) + scale_fill_manual(name = &quot;Treatment&quot;, breaks = names(treatment_colours_bright), values = treatment_colours_bright) + geom_jitter(width = 0.1, alpha = 0.4) + facet_nested(metric ~ treatment_expl + age_category, scales = &quot;free&quot;, space = &quot;fixed&quot;) + # geom_text(aes(label = animal), # position = position_jitter(width = 0.2, height = 0), # size = 3.0, alpha = 0.7, check_overlap = TRUE, color=&quot;#8c1c47&quot;) + labs(x = &quot;Days Post Infection&quot;, y = &quot;a-div value&quot;) + scale_y_continuous(expand = expansion(mult = c(0.05, 0.15))) + geom_text( data = summary_stats, aes(x = animal, y = median, label = label_txt), inherit.aes = FALSE, vjust = -5.0, size = 3, alpha = 1, color = &quot;black&quot;) + expand_limits(y = 0) + theme_minimal() + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1), plot.margin = margin(0.2, 0.2, 0.2, 0.2)) + ggtitle(&quot;Alpha diversity - 30% coverage filter&quot;) plot_alpha_div_micro 14.3.2 Alpha-div vs genome size tidy_plot_genome_counts_filt_30_closed_zerosrem &lt;- tidy_plot_genome_counts_filt_30_closed %&gt;% filter(count &gt; 0) median_lengths &lt;- tidy_plot_genome_counts_filt_30_closed_zerosrem %&gt;% group_by(microsample) %&gt;% summarise(median_genome_length = median(length, na.rm = TRUE), .groups = &quot;drop&quot;) alpha_div_filtered_30_gen_length &lt;- plot_data_stats %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(filter_level == &quot;filtered_30&quot;) %&gt;% left_join(median_lengths, by = join_by(microsample == microsample)) %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(filter_status == &quot;Retained by filtering&quot;) #%&gt;% #filter(richness &gt;10) alpha_div_filtered_30_gen_length %&gt;% ggplot(aes(x = median_genome_length, y = richness, color = treatment, shape = factor(age_category))) + geom_point(size = 3, alpha = 0.8) + # geom_smooth(method = &quot;lm&quot;, se = TRUE, aes(group = 1), color = &quot;black&quot;, linewidth = 1) + scale_color_manual(values = treatment_colours_bright, name = &quot;Treatment&quot;) + scale_shape_manual( name = &quot;DPI&quot;, values = c(&quot;a&quot; = 16, &quot;b&quot; = 17, &quot;c&quot; = 15, &quot;d&quot; = 4) # Example shapes ) + labs(x = &quot;Median genome length (bp) per sample&quot;, y = &quot;Richness&quot;) + # ylim(c(-5,300)) + theme_minimal() + custom_ggplot_theme # # # Fit model # model_nb &lt;- glm.nb(richness ~ median_genome_length, # data = alpha_div_filtered_30_gen_length) # # # Fit null model (intercept only) # model_null &lt;- glm.nb(richness ~ 1, # data = alpha_div_filtered_30_gen_length) # # # Manual McFadden pseudo-R² # pseudo_r2 &lt;- 1 - (logLik(model_nb) / logLik(model_null)) # pseudo_r2 # # # # Spearman correlation # cor_test &lt;- cor.test( # ~ richness + median_genome_length, # data = alpha_div_filtered_30_gen_length, # method = &quot;spearman&quot; # ) # # rho &lt;- cor_test$estimate # pval &lt;- cor_test$p.value # # # # Create new data for prediction # newdata &lt;- data.frame( # median_genome_length = seq( # min(alpha_div_filtered_30_gen_length$median_genome_length, na.rm = TRUE), # max(alpha_div_filtered_30_gen_length$median_genome_length, na.rm = TRUE), # length.out = 200 # ) # ) # # Get predictions + SE on link scale # pred &lt;- predict(model_nb, newdata, type = &quot;link&quot;, se.fit = TRUE) # # # Add predicted values to newdata (back-transform with exp) # newdata$fit &lt;- exp(pred$fit) # newdata$lwr &lt;- exp(pred$fit - 1.96 * pred$se.fit) # 95% CI lower # newdata$upr &lt;- exp(pred$fit + 1.96 * pred$se.fit) # 95% CI upper # # x_pos &lt;- max(alpha_div_filtered_30_gen_length$median_genome_length, na.rm = TRUE) * 0.98 # y_pos &lt;- max(alpha_div_filtered_30_gen_length$richness, na.rm = TRUE) * 0.95 # # # # Plot with fitted NB curve # ggplot(alpha_div_filtered_30_gen_length, # aes(x = median_genome_length, y = richness)) + # # NB fit + CI # geom_ribbon(data = newdata, # aes(x = median_genome_length, ymin = lwr, ymax = upr), # fill = &quot;grey70&quot;, alpha = 0.4, inherit.aes = FALSE) + # geom_line(data = newdata, # aes(x = median_genome_length, y = fit), # color = &quot;black&quot;, linewidth = 1.2, inherit.aes = FALSE) + # geom_point(aes(color = treatment, shape = factor(age_category)), # size = 3, alpha = 0.8) + # # ➊ Spearman rho + p-value # annotate(&quot;text&quot;, # x = x_pos, y = y_pos, # label = paste0(&quot;Spearman ρ = &quot;, round(rho, 2), # &quot;\\np = &quot;, signif(pval, 2)), # hjust = 1, vjust = 1, size = 3) + # # # ➋ Pseudo-R² # annotate(&quot;text&quot;, # x = x_pos, y = y_pos * 0.85, # label = paste0(&quot;\\nPseudo–R² = &quot;, round(pseudo_r2, 3)), # hjust = 1, vjust = 1, size = 3) + # # scale_color_manual(values = treatment_colours_bright, name = &quot;Treatment&quot;) + # scale_shape_manual(name = &quot;DPI&quot;, # values = c(&quot;a&quot; = 16, &quot;b&quot; = 17, &quot;c&quot; = 15, &quot;d&quot; = 4)) + # labs(x = &quot;Median genome length (bp) per sample&quot;, y = &quot;Richness&quot;) + # theme_minimal() + # custom_ggplot_theme "],["beta-diversity---macro-samples.html", "15 Beta Diversity - Macro Samples 15.1 Prepare tidy tables for plotting 15.2 Species level 15.3 Genus level", " 15 Beta Diversity - Macro Samples load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/macro/counts.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 15.1 Prepare tidy tables for plotting Create tidy tables for filtered genome counts (macro) tidy_plot_genome_counts_filt_30_macro &lt;- genome_counts_macro_filt_30 %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) tidy_plot_genome_counts_filt_30_macro_closed &lt;- genome_counts_macro_filt_30 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata_macro, by = join_by(microsample == sample)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) tidy_plot_genome_counts_filt_30_macro %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = animal , y = count, fill = order)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values = order_colors[-4], drop = FALSE) + labs(x = &quot;Metagenomic Samples&quot;, y = &quot;Order composition&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category, scales = &quot;free&quot;, space = &quot;free&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 6), axis.text.y = element_blank(), legend.position = &quot;none&quot;) + ggtitle(&quot;Composition of bacterial orders at 30% coverage filtered data&quot;) tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% ggplot(aes(x = animal , y = count, fill = order)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values = order_colors[-4], drop = FALSE) + labs(x = &quot;Metagenomic Samples&quot;, y = &quot;Order composition&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category, scales = &quot;free&quot;, space = &quot;free&quot;) + custom_ggplot_theme + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 6), axis.text.y = element_blank(), legend.position = &quot;none&quot;) + ggtitle(&quot;Composition of bacterial orders at 30% coverage filtered data&quot;) 15.2 Species level The problem here is that at species level there are too many zeros and then we need to drop almost all samples from Histomonas treatment after day a. df_wide &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # Remove metadata select(genome, microsample, count) %&gt;% # Make tidy df into wide df pivot_wider( names_from = genome, values_from = count, # Fill missing values with 0 values_fill = 0) %&gt;% # Remove taxa (columns) that are zero for all leftover samples (rows) select(where(~ any(. != 0))) %&gt;% # scale each sample to 100 (= closure to 100, not required, but common) mutate(across(-microsample, ~ . / rowSums(across(where(is.numeric))) * 100 )) %&gt;% # turn the column &#39;microsample&#39;into the name of the rows of the df column_to_rownames(var = &quot;microsample&quot;) # Remove taxa in few samples, and samples with few taxa df_wide &lt;- remove_samples_or_taxa(df = df_wide, min_samples_per_taxon = 15, min_taxa_per_sample = 20) Initial df: Rows (samples): 74 , Columns (taxa): 523 Removed: Rows (samples): 16 , Columns (taxa): 265 Resulting df: Rows (samples): 58 , Columns (taxa): 258 MACRO_sample_metadata &lt;- sample_metadata_macro %&gt;% mutate(microsample = sample) %&gt;% select(microsample, animal, age_category, treatment, treatment_expl) %&gt;% mutate(sample_type = &quot;MACRO&quot;) pca_result &lt;- perform_pca(df_wide, z_delete = TRUE) [1] &quot;Zeros found&quot; No. adjusted imputations: 4109 Rows (samples) removed after zero replacement: 11 Columns (taxa) removed after zero replacement: 0 p &lt;- plot_pca(pca_result$pca_result, samples_color_metadata = &quot;treatment&quot; , samples_shape_metadata = &quot;age_category&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;species&quot;, MACRO_sample_metadata, genome_metadata, order_colors, custom_ggplot_theme) p2 = p + ggtitle(&quot;XX&quot;) p2 p &lt;- plot_pca(pca_result$pca_result, samples_color_metadata = &quot;treatment&quot; , samples_shape_metadata = &quot;age_category&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;species&quot;, scaling_factor_value = 1.0, loadings_number = 10, MACRO_sample_metadata, genome_metadata, order_colors, custom_ggplot_theme, add_centroids = TRUE) p2 = p + ggtitle(&quot;XX&quot;) p2 15.3 Genus level Even here, the zero replacement needs to drop the samples with too few taxa. genus_metadata &lt;- genome_metadata %&gt;% select(domain, phylum, class, order, family, genus) %&gt;% distinct(genus, .keep_all = TRUE) %&gt;% mutate(genome = genus) df_wide &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # Remove metadata select(domain, phylum, class, order, family, genus, genome, microsample, count) %&gt;% group_by(microsample, genus) %&gt;% summarise(genus_count = sum(count, na.rm = TRUE))%&gt;% filter(genus != &quot;&quot;) %&gt;% mutate(count=genus_count) %&gt;% select(-genus_count) %&gt;% pivot_wider(names_from = genus,values_from = count,values_fill = 0) %&gt;% select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) %&gt;% column_to_rownames(var = &quot;microsample&quot;) %&gt;% mutate(across(where(is.numeric), ~ . / rowSums(across(where(is.numeric))) * 100)) # Remove taxa in few samples, and samples with few taxa df_wide &lt;- remove_samples_or_taxa(df = df_wide, min_samples_per_taxon = 5, min_taxa_per_sample = 5) Initial df: Rows (samples): 74 , Columns (taxa): 219 Removed: Rows (samples): 7 , Columns (taxa): 18 Resulting df: Rows (samples): 67 , Columns (taxa): 201 MACRO_sample_metadata &lt;- sample_metadata_macro %&gt;% mutate(microsample = sample) %&gt;% select(microsample, animal, age_category, treatment, treatment_expl) %&gt;% mutate(sample_type = &quot;MACRO&quot;) pca_result &lt;- perform_pca(df_wide, z_delete = TRUE) [1] &quot;Zeros found&quot; No. adjusted imputations: 2183 Rows (samples) removed after zero replacement: 16 Columns (taxa) removed after zero replacement: 49 p &lt;- plot_pca(pca_result$pca_result, samples_color_metadata = &quot;treatment&quot; , samples_shape_metadata = &quot;age_category&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;genus&quot;, sample_metadata = MACRO_sample_metadata, genome_metadata = genus_metadata, order_colors = order_colors, custom_ggplot_theme) p2 = p + ggtitle(&quot;XX&quot;) p2 p &lt;- plot_pca(pca_result$pca_result, samples_color_metadata = &quot;treatment&quot; , samples_shape_metadata = &quot;age_category&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;genus&quot;, sample_metadata = MACRO_sample_metadata, genome_metadata = genus_metadata, order_colors = order_colors, scaling_factor_value = 1.5, loadings_number = 10, custom_ggplot_theme, add_centroids = TRUE) p2 = p + ggtitle(&quot;PCA at genus level&quot;) p2 15.3.1 PERMANOVA # Calculate Euclidean distance on CLR data pca_animals_dist_matrix &lt;- vegdist(pca_result$df_clr_dist, method = &quot;euclidean&quot;) # Make sure that filtered df and metadata have the same number &amp; order of rows pca_animals_metadata_adonis &lt;- plot_data_stats_macro %&gt;% filter(microsample %in% rownames(pca_result$df_clr_dist)) %&gt;% arrange(match(microsample, rownames(pca_result$df_clr_dist))) %&gt;% select(microsample, animal, treatment, age_category) all(pca_animals_metadata_adonis$microsample == rownames(pca_result$df_clr_dist)) [1] TRUE # Run PERMANOVA adonis2_result &lt;- adonis2( pca_animals_dist_matrix ~ treatment + age_category, data = pca_animals_metadata_adonis, permutations = 999, by = &quot;terms&quot; ) knitr::kable(adonis2_result) Df SumOfSqs R2 F Pr(&gt;F) treatment 3 1386.531 0.1605485 3.672666 0.001 age_category 3 1712.619 0.1983067 4.536414 0.001 Residual 44 5537.063 0.6411448 NA NA Total 50 8636.212 1.0000000 NA NA # LOOP treatments &lt;- unique(pca_animals_metadata_adonis$treatment) results_age &lt;- map_dfr(treatments, function(trt) { # Subset metadata and restore proper sample IDs subset_meta &lt;- pca_animals_metadata_adonis[ pca_animals_metadata_adonis$treatment == trt, , drop = FALSE ] rownames(subset_meta) &lt;- subset_meta$microsample # Subset the distance matrix to those samples subset_dist &lt;- as.dist(as.matrix(pca_animals_dist_matrix)[ rownames(subset_meta), rownames(subset_meta) ]) # Run PERMANOVA for age within this treatment adonis_res &lt;- adonis2(subset_dist ~ age_category, data = subset_meta, permutations = 999) # Extract R² and p-value data.frame( Treatment = trt, R2 = adonis_res$R2[1], p_value = adonis_res$`Pr(&gt;F)`[1] ) }) results_age Treatment R2 p_value 1 TM1 0.5374383 0.00100000 2 TM2 0.4986288 0.00100000 3 TM3 0.5858182 0.06666667 4 TM4 0.2827991 0.00100000 15.3.2 Species representative genomes overlap group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, treatment == &quot;TM1&quot;) %&gt;% pull(genome) %&gt;% unique() group2 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, treatment == &quot;TM2&quot;) %&gt;% pull(genome) %&gt;% unique() group3 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, treatment == &quot;TM3&quot;) %&gt;% pull(genome) %&gt;% unique() group4 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, treatment == &quot;TM4&quot;) %&gt;% pull(genome) %&gt;% unique() venn_data &lt;- list( TM1 = group1, TM2 = group2, TM3 = group3, TM4 = group4 ) # # Taxa unique to group1 only # unique_group1 &lt;- setdiff(group1, group2) # layer # # Taxa unique to group2 only # unique_group2 &lt;- setdiff(group2, group1) # broiler # # # # Filter once (layer/broiler + genomes of interest) # filtered_group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # filter(type_simple == &quot;P&quot;, animal_breed == &quot;layer&quot;, genome %in% unique_group1) # # filtered_group2 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # filter(type_simple == &quot;P&quot;, animal_breed == &quot;broiler&quot;, genome %in% unique_group2) ggVennDiagram( venn_data, label = &quot;count&quot;, set_color = c(TM1 = &quot;#4059AE&quot;, TM2 = &quot;#6A9AC3&quot;, TM3 = &quot;#97D8C4&quot;, TM4 = &quot;#F3B942&quot;) ) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;grey&quot;) #+ #ggtitle(&quot;Samples:&quot;) + #coord_flip() group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, age_category == &quot;a&quot;) %&gt;% pull(genome) %&gt;% unique() group2 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, age_category == &quot;b&quot;) %&gt;% pull(genome) %&gt;% unique() group3 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, age_category == &quot;c&quot;) %&gt;% pull(genome) %&gt;% unique() group4 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;, age_category == &quot;d&quot;) %&gt;% pull(genome) %&gt;% unique() venn_data &lt;- list( day_a = group1, day_b = group2, day_c = group3, day_d = group4 ) # # Taxa unique to group1 only # unique_group1 &lt;- setdiff(group1, group2) # layer # # Taxa unique to group2 only # unique_group2 &lt;- setdiff(group2, group1) # broiler # # # # Filter once (layer/broiler + genomes of interest) # filtered_group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # filter(type_simple == &quot;P&quot;, animal_breed == &quot;layer&quot;, genome %in% unique_group1) # # filtered_group2 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% # filter(type_simple == &quot;P&quot;, animal_breed == &quot;broiler&quot;, genome %in% unique_group2) ggVennDiagram( venn_data, label = &quot;count&quot;, set_color = c(day_a = &quot;#498a77&quot;, day_b = &quot;#cc0100&quot;, day_c = &quot;#cf4a82&quot;, day_d = &quot;#b4a7d6&quot;) ) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;grey&quot;) #+ #ggtitle(&quot;Samples:&quot;) + #coord_flip() "],["beta-diversity---micro-samples.html", "16 Beta Diversity - Micro Samples 16.1 Prepare tidy tables for plotting 16.2 Species level", " 16 Beta Diversity - Micro Samples load(&quot;data/macro/sample_metadata.Rdata&quot;) load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/counts.Rdata&quot;) load(&quot;data/micro/seq_stats.Rdata&quot;) load(&quot;data/MAG_catalogue/data.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) 16.1 Prepare tidy tables for plotting Create tidy tables for filtered genome counts (micro) tidy_plot_genome_counts_filt_30 &lt;- genome_counts_filt_30 %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) tidy_plot_genome_counts_filt_30_closed &lt;- genome_counts_filt_30 %&gt;% mutate_at(vars(-genome), ~ . / sum(.)) %&gt;% pivot_longer(-genome, names_to = &quot;microsample&quot;, values_to = &quot;count&quot;) %&gt;% left_join(genome_metadata, by = join_by(genome == genome)) %&gt;% left_join(sample_metadata, by = join_by(microsample == microsample)) %&gt;% left_join(final_combined_stats, by = join_by(microsample == microsample)) %&gt;% mutate(section = unlist(section)) %&gt;% filter(count &gt; 0) %&gt;% mutate(phylum = factor(phylum, levels = phylum_level_vector), order = factor(order, levels = order_level_vector)) tidy_plot_genome_counts_filt_30 %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% ggplot(aes(x = microsample , y = count, fill = order)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values = order_colors[-4], drop = FALSE) + labs(x = &quot;Metagenomic Samples&quot;, y = &quot;Order composition&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category + animal, scales = &quot;free&quot;, space = &quot;free&quot;) + custom_ggplot_theme + theme(axis.text.x = element_blank(), axis.text.y = element_text(angle = 0, hjust = 1, size = 6), legend.position = &quot;none&quot;) + ggtitle(&quot;Composition of bacterial orders at 30% coverage filtered data&quot;) tidy_plot_genome_counts_filt_30_closed %&gt;% filter(treatment != &quot;TM0&quot;) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% ggplot(aes(x = microsample , y = count, fill = order)) + geom_bar(stat=&quot;identity&quot;, colour=&quot;white&quot;, linewidth=0.1) + #plot stacked bars with white borders scale_fill_manual(values = order_colors[-4], drop = FALSE) + labs(x = &quot;Metagenomic microsamples&quot;, y = &quot;Order composition&quot;,fill = &quot;Read type&quot;) + facet_nested(. ~ treatment_expl + age_category + animal, scales = &quot;free&quot;, space = &quot;free&quot;) + custom_ggplot_theme + theme(axis.text.x = element_blank(), axis.text.y = element_text(angle = 0, hjust = 1, size = 6), legend.position = &quot;none&quot;) + ggtitle(&quot;Composition of bacterial orders at 30% coverage filtered data&quot;) 16.2 Species level df_wide &lt;- tidy_plot_genome_counts_filt_30_closed %&gt;% # Remove metadata select(genome, microsample, count) %&gt;% # Make tidy df into wide df pivot_wider( names_from = genome, values_from = count, # Fill missing values with 0 values_fill = 0) %&gt;% # Remove taxa (columns) that are zero for all leftover samples (rows) select(where(~ any(. != 0))) %&gt;% # scale each sample to 100 (= closure to 100, not required, but common) mutate(across(-microsample, ~ . / rowSums(across(where(is.numeric))) * 100 )) %&gt;% # turn the column &#39;microsample&#39;into the name of the rows of the df column_to_rownames(var = &quot;microsample&quot;) # Remove taxa in few samples, and samples with few taxa df_wide &lt;- remove_samples_or_taxa(df = df_wide, min_samples_per_taxon = 15, min_taxa_per_sample = 20) Initial df: Rows (samples): 1142 , Columns (taxa): 456 Removed: Rows (samples): 140 , Columns (taxa): 77 Resulting df: Rows (samples): 1002 , Columns (taxa): 379 # MICRO_sample_metadata &lt;- sample_metadata %&gt;% # mutate(microsample = sample) %&gt;% # select(microsample, animal, age_category, treatment, treatment_expl) %&gt;% # mutate(sample_type = &quot;MACRO&quot;) pca_result &lt;- perform_pca(df_wide, z_delete = TRUE) [1] &quot;Zeros found&quot; No. adjusted imputations: 68532 Rows (samples) removed after zero replacement: 84 Columns (taxa) removed after zero replacement: 197 p &lt;- plot_pca(pca_result$pca_result, samples_color_metadata = &quot;treatment&quot; , samples_shape_metadata = &quot;age_category&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;species&quot;, sample_metadata = sample_metadata, genome_metadata = genome_metadata, order_colors = order_colors, custom_ggplot_theme) p2 = p + ggtitle(&quot;PCA, Microsamples, Species Level&quot;) p2 16.2.1 PERMANOVA # Calculate Euclidean distance on CLR data pca_animals_dist_matrix &lt;- vegdist(pca_result$df_clr_dist, method = &quot;euclidean&quot;) # Make sure that filtered df and metadata have the same number &amp; order of rows pca_animals_metadata_adonis &lt;- plot_data_stats %&gt;% filter(microsample %in% rownames(pca_result$df_clr_dist)) %&gt;% arrange(match(microsample, rownames(pca_result$df_clr_dist))) %&gt;% select(microsample, animal, treatment, age_category) all(pca_animals_metadata_adonis$microsample == rownames(pca_result$df_clr_dist)) [1] TRUE # Run PERMANOVA adonis2_result &lt;- adonis2( pca_animals_dist_matrix ~ treatment + age_category + animal, data = pca_animals_metadata_adonis, permutations = 999, by = &quot;terms&quot; ) knitr::kable(adonis2_result) Df SumOfSqs R2 F Pr(&gt;F) treatment 3 48035.79 0.2112380 245.4447 0.001 age_category 1 29749.58 0.1308242 456.0273 0.001 animal 9 90642.17 0.3986001 154.3824 0.001 Residual 904 58973.71 0.2593377 NA NA Total 917 227401.25 1.0000000 NA NA "],["beta-diversity---macro-vs-micro-comparison.html", "17 Beta Diversity - Macro vs Micro Comparison 17.1 Genomes overlap 17.2 Micro vs Macro Genus level", " 17 Beta Diversity - Macro vs Micro Comparison 17.1 Genomes overlap group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% pull(genome) %&gt;% unique() group2 &lt;- tidy_plot_genome_counts_filt_30_closed %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% pull(genome) %&gt;% unique() venn_data &lt;- list( macro = group1, micro = group2 ) # Taxa unique to group1 only unique_group1 &lt;- setdiff(group1, group2) # macro # Taxa unique to group2 only unique_group2 &lt;- setdiff(group2, group1) # micro # Filter once (macro/micro + genomes of interest) filtered_group1 &lt;- tidy_plot_genome_counts_filt_30_macro_closed %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% filter(genome %in% unique_group1) filtered_group2 &lt;- tidy_plot_genome_counts_filt_30_closed %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% filter(genome %in% unique_group2) ggVennDiagram( venn_data, set_color = c(macro = &quot;#ffcc62&quot;, micro = &quot;#cf4a82&quot;)) + scale_fill_gradient(low = &quot;white&quot;, high = &quot;grey&quot;) + ggtitle(&quot;Day a&amp;d&quot;) + coord_flip() # 2) Summaries per species + prevalence (denominator from the SAME filtered data) denom &lt;- n_distinct(filtered_group1$microsample) unique_group1_df &lt;- filtered_group1 %&gt;% group_by(species) %&gt;% summarise( median = median(count, na.rm = TRUE), n_samples = n_distinct(microsample), prevalence = n_samples / denom, .groups = &quot;drop&quot; ) #%&gt;% #filter(prevalence &gt; 0.05) # 3) Plotting data: keep only species above cutoff and bring in prevalence for ordering/labels plot_df &lt;- filtered_group1 %&gt;% inner_join(unique_group1_df %&gt;% select(species, prevalence), by = &quot;species&quot;) %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) # 4) Jitter plot (counts) + prevalence mini bar side-by-side p1 &lt;- ggplot(plot_df, aes(x = count, y = species, color = order)) + geom_jitter(alpha = 0.7, size = 0.9) + scale_color_manual(values = order_colors) + theme_minimal() + custom_ggplot_theme + scale_x_continuous(limits = c(0, 0.05)) + ggtitle(&quot;Macro: Relative abundance&quot;) p2 &lt;- unique_group1_df %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) %&gt;% ggplot(aes(x = prevalence, y = species)) + geom_col() + theme_minimal() + theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()) + scale_x_continuous(limits = c(0, 1)) + ggtitle(&quot;Prevalence Macro&quot;) p3 &lt;- unique_group1_df %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) %&gt;% ggplot(aes(x = median, y = species)) + geom_col() + theme_minimal() + theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank(), panel.grid.minor.x = element_blank()) + scale_x_continuous(limits = c(0, 0.01), breaks = c(0, 0.005, 0.01)) + ggtitle(&quot;Median&quot;) (p1 + p3 + p2) + plot_layout(widths = c(3, 1, 1), guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) # 2) Summaries per species + prevalence (denominator from the SAME filtered data) denom &lt;- n_distinct(filtered_group2$microsample) unique_group2_df &lt;- filtered_group2 %&gt;% group_by(species) %&gt;% summarise( median = median(count, na.rm = TRUE), n_samples = n_distinct(microsample), prevalence = n_samples / denom, .groups = &quot;drop&quot; ) #%&gt;% #filter(prevalence &gt; 0.05) # 3) Plotting data: keep only species above cutoff and bring in prevalence for ordering/labels plot_df &lt;- filtered_group2 %&gt;% inner_join(unique_group2_df %&gt;% select(species, prevalence), by = &quot;species&quot;) %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) # 4) Jitter plot (counts) + prevalence mini bar side-by-side p1 &lt;- ggplot(plot_df, aes(x = count, y = species, color = order)) + geom_jitter(alpha = 0.7, size = 0.9) + scale_color_manual(values = order_colors) + theme_minimal() + custom_ggplot_theme + scale_x_continuous(limits = c(0, 0.1)) + ggtitle(&quot;Micro: Relative abundance&quot;) p2 &lt;- unique_group2_df %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) %&gt;% ggplot(aes(x = prevalence, y = species)) + geom_col() + theme_minimal() + theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank()) + scale_x_continuous(limits = c(0, 1)) + ggtitle(&quot;Prevalence Micro&quot;) p3 &lt;- unique_group2_df %&gt;% mutate(species = fct_reorder(species, prevalence, .desc = FALSE)) %&gt;% ggplot(aes(x = median, y = species)) + geom_col() + theme_minimal() + theme(axis.title.y = element_blank(), axis.text.y = element_blank(), axis.ticks.y = element_blank(), panel.grid.minor.x = element_blank()) + scale_x_continuous(limits = c(0, 0.015), breaks = c(0, 0.005, 0.01)) + ggtitle(&quot;Median&quot;) (p1 + p3 + p2) + plot_layout(widths = c(3, 1, 1), guides = &quot;collect&quot;) &amp; theme(legend.position = &quot;bottom&quot;, legend.box = &quot;vertical&quot;) 17.2 Micro vs Macro Genus level genus_metadata &lt;- genome_metadata %&gt;% select(domain, phylum, class, order, family, genus) %&gt;% distinct(genus, .keep_all = TRUE) %&gt;% mutate(genome = genus) PCA_df_macro &lt;- tidy_plot_genome_counts_filt_30_macro %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% filter(tissue == &quot;Digesta&quot;) %&gt;% select(domain, phylum, class, order, family, genus, genome, microsample, count) %&gt;% group_by(microsample, genus) %&gt;% summarise(genus_count = sum(count, na.rm = TRUE))%&gt;% filter(genus != &quot;&quot;) %&gt;% mutate(count=genus_count) %&gt;% select(-genus_count) %&gt;% pivot_wider(names_from = genus,values_from = count,values_fill = 0) %&gt;% select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) %&gt;% column_to_rownames(var = &quot;microsample&quot;) %&gt;% mutate(across(where(is.numeric), ~ . / rowSums(across(where(is.numeric))) * 100)) PCA_df_micro &lt;- tidy_plot_genome_counts_filt_30 %&gt;% filter(type == &quot;Positive&quot;) %&gt;% filter(age_category %in% c(&quot;a&quot;, &quot;d&quot;)) %&gt;% select(domain, phylum, class, order, family, genus, genome, microsample, count) %&gt;% group_by(microsample, genus) %&gt;% summarise(genus_count = sum(count, na.rm = TRUE))%&gt;% filter(genus != &quot;&quot;) %&gt;% mutate(count=genus_count) %&gt;% select(-genus_count) %&gt;% pivot_wider(names_from = genus,values_from = count,values_fill = 0) %&gt;% select(where(~ any(. != 0)) | where(is.character) | where(is.factor)) %&gt;% column_to_rownames(var = &quot;microsample&quot;) %&gt;% mutate(across(where(is.numeric), ~ . / rowSums(across(where(is.numeric))) * 100)) # ---------------------------------------- # Find columns present in df1 but missing in df2 extra_in_PCA_df_macro &lt;- setdiff(names(PCA_df_macro), names(PCA_df_micro)) print(&quot;Columns in PCA_df_macro but not in PCA_df_micro:&quot;) print(extra_in_PCA_df_macro) # Find columns present in df2 but missing in df1 extra_in_PCA_df_micro &lt;- setdiff(names(PCA_df_micro), names(PCA_df_macro)) print(&quot;Columns in PCA_df_micro but not in PCA_df_macro:&quot;) print(extra_in_PCA_df_micro) # Find common columns common_cols &lt;- intersect(names(PCA_df_macro), names(PCA_df_micro)) # Keep only the common columns in both dataframes PCA_df_macro_sub &lt;- PCA_df_macro[, common_cols] PCA_df_micro_sub &lt;- PCA_df_micro[, common_cols] # Verify dimensions print(dim(PCA_df_macro_sub)) # Should match df2 print(dim(PCA_df_micro_sub)) # -------------------------------------------- MICRO_sample_metadata &lt;- sample_metadata %&gt;% filter(type == &quot;Positive&quot;) %&gt;% select(microsample, animal, cryosection, treatment) %&gt;% mutate(method = &quot;Micro&quot;) MACRO_sample_metadata &lt;- sample_metadata_macro %&gt;% filter(type_simple == &quot;P&quot;) %&gt;% filter(tissue == &quot;Digesta&quot;) %&gt;% mutate(microsample = sample) %&gt;% select(microsample, animal, treatment) %&gt;% mutate(method = &quot;Macro&quot;) # -------------------------------------------- PCA_MICRO_MACRO &lt;- bind_rows(PCA_df_micro_sub, PCA_df_macro_sub) sample_metadata_MICRO_MACRO &lt;- bind_rows(MICRO_sample_metadata, MACRO_sample_metadata) # -------------------------------------------- # Store original dimensions original_rows &lt;- nrow(PCA_MICRO_MACRO) original_cols &lt;- ncol(PCA_MICRO_MACRO) PCA_MICRO_MACRO &lt;- PCA_MICRO_MACRO %&gt;% select(where(~ sum(. != 0) &gt; 110)) # Remove taxa that are in less than x samples PCA_MICRO_MACRO &lt;- PCA_MICRO_MACRO %&gt;% filter(rowSums(. != 0) &gt; 25) # Remove samples that contain less than x taxa PCA_MICRO_MACRO &lt;- PCA_MICRO_MACRO %&gt;% mutate(across(where(is.numeric), ~ . / rowSums(across(where(is.numeric))) * 100)) # outlier samples in the PCA disappear when we filter better # Print removed rows and columns removed_rows &lt;- original_rows - nrow(PCA_MICRO_MACRO) removed_cols &lt;- original_cols - ncol(PCA_MICRO_MACRO) cat(&quot;Rows (samples) removed:&quot;, removed_rows, &quot;\\n&quot;) cat(&quot;Columns (taxa) removed:&quot;, removed_cols, &quot;\\n&quot;) # -------------------------------------------- pca_result &lt;- perform_pca(PCA_MICRO_MACRO, z_delete = TRUE) pca_animals_species &lt;- plot_pca(df = pca_result$pca_result, samples_shape_metadata = &quot;method&quot;, # pen samples_color_metadata = &quot;treatment&quot;, samples_color_value = treatment_colours_bright, loadings_color_metadata = &quot;order&quot;, loadings_color_value = order_colors, loadings_taxon_level = &quot;genus&quot;, sample_metadata = sample_metadata_MICRO_MACRO, genome_metadata = genus_metadata, order_colors = order_colors, loadings_number = 20, custom_ggplot_theme = custom_ggplot_theme, scaling_factor = 1) knitr::kable(pca_animals_species) "],["spatial-analysis---micro-samples.html", "18 Spatial Analysis - Micro Samples 18.1 Functions 18.2 Load data 18.3 Extended RLQ analysis", " 18 Spatial Analysis - Micro Samples load(&quot;data/micro/sample_metadata.Rdata&quot;) load(&quot;data/micro/counts.Rdata&quot;) load(&quot;data/micro/seq_stats.Rdata&quot;) load(&quot;data/data_colors.Rdata&quot;) Amalia’s comment: Code from Inaki, adapted by Antton and Carlotta. I tried to adapt it for Deliverable 6.3, not everything works yet. 18.1 Functions 18.1.1 spatial_cryosections spatial_cryosections &lt;- function(cryosection_list, metadata_df, comm_clr) { cryosection_dfs &lt;- list() mantel_results &lt;- list() mantelcor_results &lt;- list() decay_dfs &lt;- list() distance_decay_plots &lt;- list() structure_results &lt;- list() for (cryosection in cryosection_list) { # Filter metadata for this section metadata_data &lt;- metadata_df %&gt;% filter(cryosection == !!cryosection, !is.na(.data$Xcoord), !is.na(.data$Ycoord)) # Filter community data comm_data &lt;- comm_clr %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;microsample&quot;) %&gt;% filter(microsample %in% metadata_data$microsample) %&gt;% column_to_rownames(var = &quot;microsample&quot;) cryosection_dfs[[cryosection]] &lt;- list( comm_clr = comm_data, metadata = metadata_data ) # Mantel correlogram mantel &lt;- vegan::mantel( dist(comm_data), dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), permutations = 999 ) mantel_results[[cryosection]] &lt;- mantel # Mantel correlogram correlog &lt;- vegan::mantel.correlog( D.eco = dist(comm_data), D.geo = dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), nperm = 999 ) mantelcor_results[[cryosection]] &lt;- correlog # Distance decay toplot &lt;- data.frame( spat_dist = as.numeric(dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)])), comm_dist = as.numeric(dist(comm_data)) ) decay_dfs[[cryosection]] &lt;- toplot # Plot p &lt;- ggplot(toplot, aes(x = spat_dist, y = comm_dist)) + # geom_point() + geom_smooth() + xlab(&quot;Spatial distance (μm)&quot;) + ylab(&quot;Aitchison \\ndistance&quot;) + theme_minimal() + custom_ggplot_theme + # ggtitle(paste(&quot;Distance Decay -&quot;, cryosection)) ggtitle(paste(cryosection)) distance_decay_plots[[cryosection]] &lt;- p # Print summary # print(paste(&quot;Summary for&quot;, cryosection)) # print(summary(lm(comm_dist ~ spat_dist, data = toplot))) #### Complex spatial structures # set.seed(111) # spat_SWNs&lt;-listw.candidates(data.frame(metadata_data[,c(&quot;Xcoord&quot;,&quot;Ycoord&quot;)]), # nb = c(&quot;gab&quot;), # weights = c(&quot;fdown&quot;, &quot;fup&quot;), # y_fdown = c(2,5), y_fup = c(0.1,0.5)) # W_sel &lt;- listw.select(comm_data, spat_SWNs, MEM.autocor = &quot;positive&quot;, # p.adjust = T, method=&quot;FWD&quot;) # structure_results[[cryosection]] &lt;- W_sel } return(list( cryosection_dfs = cryosection_dfs, mantel_results = mantel_results, mantelcor_results = mantelcor_results, decay_dfs = decay_dfs, distance_decay_plots = distance_decay_plots, structure_results = structure_results )) } 18.1.2 Additive diversity partitioning # Function to calculate hierarchical additive partitioning hier_adipart &lt;- function(comm, hier, nsim = 999) { comm_bin &lt;- (as.matrix(comm) &gt; 0) * 1 alpha_obs &lt;- mean(rowSums(comm_bin)) get_level_richness &lt;- function(fac) { tapply(seq_len(nrow(comm_bin)), fac, function(idx) { sum(colSums(comm_bin[idx, , drop = FALSE]) &gt; 0) }) |&gt; mean() } level_names &lt;- names(hier) level_rich &lt;- sapply(hier, get_level_richness) gamma_obs &lt;- sum(colSums(comm_bin) &gt; 0) # exactly L betas betas &lt;- c(level_rich[1] - alpha_obs, diff(level_rich)) names(betas) &lt;- paste0(&quot;beta (&quot;, level_names, &quot;)&quot;) observed &lt;- c(alpha = alpha_obs, betas, gamma = gamma_obs) stat_fun &lt;- function(x) { x &lt;- (x &gt; 0) * 1 alpha &lt;- mean(rowSums(x)) lvl &lt;- sapply(hier, function(fac) { tapply(seq_len(nrow(x)), fac, function(idx) sum(colSums(x[idx, , drop = FALSE]) &gt; 0)) |&gt; mean() }) gamma &lt;- sum(colSums(x) &gt; 0) betas &lt;- c(lvl[1] - alpha, diff(lvl)) # ✅ no gamma - last_level names(betas) &lt;- paste0(&quot;beta (&quot;, level_names, &quot;)&quot;) c(alpha = alpha, betas, gamma = gamma) } sim &lt;- oecosimu(comm_bin, stat_fun, method = &quot;r2dtable&quot;, nsimul = nsim) tibble::tibble( component = names(observed), observed = as.numeric(observed), expected = as.numeric(sim$oecosimu$mean), pval = as.numeric(sim$oecosimu$pval) ) } plot_hier_adipart &lt;- function(res, title = NULL) { p_to_stars &lt;- function(p) case_when( p &lt;= 0.001 ~ &quot;***&quot;, p &lt;= 0.01 ~ &quot;**&quot;, p &lt;= 0.05 ~ &quot;*&quot;, TRUE ~ &quot;&quot; ) res_long &lt;- res %&gt;% pivot_longer(c(observed, expected), names_to = &quot;type&quot;, values_to = &quot;value&quot;) %&gt;% mutate( component = factor( component, levels = c(&quot;alpha&quot;, &quot;beta (cryosection)&quot;, &quot;beta (animal)&quot;, &quot;beta (treatment)&quot;, &quot;gamma&quot;) ) ) ggplot(res_long, aes(x = component, y = value, fill = type)) + geom_col(position = position_dodge(width = 0.7), width = 0.6, color = &quot;black&quot;) + geom_text(data = res, aes(x = component, y = pmax(observed, expected) * 1.05, label = p_to_stars(pval)), inherit.aes = FALSE, vjust = 0) + labs(x = NULL, y = &quot;Richness&quot;, fill = NULL, title = title) + theme_minimal(base_size = 11) + theme(axis.text.x = element_text(angle = 15, hjust = 1), legend.position = &quot;top&quot;) } 18.2 Load data metadata &lt;- plot_data_stats %&gt;% filter( treatment == &quot;TM3&quot;, age_category == &quot;a&quot;, type_simple %in% c(&quot;P&quot;), filter_status %in% c(&quot;Retained by filtering&quot;), !is.na(Xcoord)) comm_data &lt;- genome_counts_filt_30_zerosrem %&gt;% select(genome, metadata$microsample) %&gt;% t() %&gt;% data.frame() %&gt;% row_to_names(row_number = 1) %&gt;% mutate(across(everything(), as.numeric)) # table(rowSums(comm_data) &gt; 0) # all(metadata$microsample == rownames(comm_data)) # table(is.na(comm_data)) # table(metadata$section, metadata$cryosection) comm_ca &lt;- comm_data[, colSums(comm_data) &gt; 0] metadata_ca &lt;- metadata table(metadata$section, metadata$cryosection) M041aI101A M042aI101A Caecum right 76 83 table(metadata$section, metadata$animal) M041a M042a Caecum right 76 83 18.2.0.1 Transform the data for posterior multivariate analyses # Store original dimensions original_rows &lt;- nrow(comm_ca) original_cols &lt;- ncol(comm_ca) comm_ca_zeroRepl &lt;- cmultRepl(comm_ca, method = &quot;GBM&quot;, output = &quot;prop&quot;, z.warning = 0.95, z.delete = TRUE) No. adjusted imputations: 4931 # Print removed rows and columns removed_rows &lt;- original_rows - nrow(comm_ca_zeroRepl) removed_cols &lt;- original_cols - ncol(comm_ca_zeroRepl) cat(&quot;Rows (samples) removed:&quot;, removed_rows, &quot;\\n&quot;) Rows (samples) removed: 16 cat(&quot;Columns (taxa) removed:&quot;, removed_cols, &quot;\\n&quot;) Columns (taxa) removed: 59 metadata_ca_clr &lt;- metadata_ca[metadata_ca$microsample %in% rownames(comm_ca_zeroRepl), ] clr_transform &lt;- function(x) { log(x) - mean(log(x), na.rm = TRUE) } comm_ca_clr &lt;- data.frame(t(apply(comm_ca_zeroRepl, 1, clr_transform))) # Ensure hierarchy variables are factors, in order: cryosection (lowest), animal, treatment (highest) hier_ca &lt;- metadata_ca %&gt;% transmute( cryosection = factor(cryosection), animal = factor(animal), treatment = factor(treatment) ) # Suppose comm_ca is your samples x genomes matrix # and hier_ca is your data frame with cryosection, animal, treatment (in order lowest → highest) res_ca &lt;- hier_adipart(comm_ca, hier_ca, nsim = 999) print(res_ca) # A tibble: 5 × 4 component observed expected pval &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; 1 alpha 113. 79.5 0.001 2 beta (cryosection) 131. 215. 0.001 3 beta (animal) 0 0 1 4 beta (treatment) 72.5 21.3 0.001 5 gamma 316 316 1 plot_hier_adipart(res_ca, title = &quot;Caecum&quot;) + custom_ggplot_theme 18.2.0.1.1 Ceacum Cryosection cryosections = metadata %&gt;% distinct(cryosection) %&gt;% pull(cryosection) results_ca &lt;- spatial_cryosections( cryosection_list = cryosections, metadata_df = metadata_ca_clr, comm_clr = comm_ca_clr ) 18.2.0.1.1.1 Mantel test results_ca$mantel_results $M042aI101A Mantel statistic based on Pearson&#39;s product-moment correlation Call: vegan::mantel(xdis = dist(comm_data), ydis = dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), permutations = 999) Mantel statistic r: 0.07512 Significance: 0.097 Upper quantiles of permutations (null model): 90% 95% 97.5% 99% 0.0740 0.0965 0.1138 0.1450 Permutation: free Number of permutations: 999 $M041aI101A Mantel statistic based on Pearson&#39;s product-moment correlation Call: vegan::mantel(xdis = dist(comm_data), ydis = dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), permutations = 999) Mantel statistic r: 0.1785 Significance: 0.007 Upper quantiles of permutations (null model): 90% 95% 97.5% 99% 0.0803 0.1108 0.1293 0.1627 Permutation: free Number of permutations: 999 # results_ca$mantel_results$G121eI104C$statistic # results_ca$mantel_results$G121eI104C$signif # p &lt; 0.05 → Statistically significant correlation between two distance matrices # p &gt; 0.05 → No significant correlation between two distance matrices 18.2.0.1.1.2 Mantel Correlogram Stat results_ca$mantelcor_results $M042aI101A Mantel Correlogram Analysis Call: vegan::mantel.correlog(D.eco = dist(comm_data), D.geo = dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), nperm = 999) class.index n.dist Mantel.cor Pr(Mantel) Pr(corrected) D.cl.1 3.8591e+02 2.1200e+02 3.2274e-02 0.020 0.020 * D.cl.2 1.1068e+03 7.2800e+02 5.3378e-02 0.010 0.020 * D.cl.3 1.8277e+03 8.8200e+02 2.2039e-02 0.201 0.201 D.cl.4 2.5485e+03 1.0420e+03 1.8137e-02 0.237 0.402 D.cl.5 3.2694e+03 9.9600e+02 -5.4002e-03 0.411 0.603 D.cl.6 3.9903e+03 8.2400e+02 -3.7989e-02 0.030 0.120 D.cl.7 4.7112e+03 6.9200e+02 -4.9872e-02 0.018 0.108 D.cl.8 5.4320e+03 5.2000e+02 NA NA NA D.cl.9 6.1529e+03 2.8200e+02 NA NA NA D.cl.10 6.8738e+03 1.9600e+02 NA NA NA D.cl.11 7.5947e+03 7.6000e+01 NA NA NA D.cl.12 8.3156e+03 2.2000e+01 NA NA NA D.cl.13 9.0364e+03 6.0000e+00 NA NA NA --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 $M041aI101A Mantel Correlogram Analysis Call: vegan::mantel.correlog(D.eco = dist(comm_data), D.geo = dist(metadata_data[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)]), nperm = 999) class.index n.dist Mantel.cor Pr(Mantel) Pr(corrected) D.cl.1 8.6026e+02 6.3200e+02 8.0461e-02 0.007 0.007 ** D.cl.2 2.4044e+03 9.0600e+02 8.2752e-02 0.012 0.014 * D.cl.3 3.9485e+03 6.6400e+02 5.1263e-02 0.013 0.024 * D.cl.4 5.4926e+03 5.8000e+02 -4.3210e-02 0.035 0.036 * D.cl.5 7.0367e+03 3.9400e+02 -5.8352e-02 0.017 0.048 * D.cl.6 8.5808e+03 2.2800e+02 -5.5414e-02 0.035 0.070 . D.cl.7 1.0125e+04 1.7200e+02 NA NA NA D.cl.8 1.1669e+04 1.0600e+02 NA NA NA D.cl.9 1.3213e+04 5.2000e+01 NA NA NA D.cl.10 1.4757e+04 2.0000e+01 NA NA NA D.cl.11 1.6301e+04 2.0000e+01 NA NA NA D.cl.12 1.7845e+04 6.0000e+00 NA NA NA --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 18.2.0.1.1.3 Mantel Correlogram Plot mantel_ca_grob &lt;- ggplot( data.frame(results_ca$mantelcor_results$M041aI101A$mantel.res) %&gt;% mutate(sign_label = ifelse(`Pr.Mantel.` &lt;= 0.05, &quot;Significant&quot;, &quot;Not significant&quot;)) %&gt;% filter(!is.na(Mantel.cor)), aes(x = class.index, y = Mantel.cor) ) + geom_point(aes(fill = sign_label), shape = 23, size = 3) + geom_line() + scale_fill_manual(values = c(&quot;Significant&quot; = &quot;black&quot;, &quot;Not significant&quot; = &quot;white&quot;)) + labs( title = &quot;M041aI101A&quot;, x = &quot;Distance Class Index&quot;, y = &quot;Mantel Correlation&quot;, color = &quot;Significance&quot; ) + geom_hline(yintercept = 0, color = &quot;red&quot;) + theme_minimal() custom_ggplot_theme + theme(legend.position = &quot;none&quot;) List of 13 $ axis.title :List of 11 ..$ family : NULL ..$ face : chr &quot;bold&quot; ..$ colour : NULL ..$ size : num 12 ..$ hjust : NULL ..$ vjust : NULL ..$ angle : NULL ..$ lineheight : NULL ..$ margin : NULL ..$ debug : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; $ axis.text :List of 11 ..$ family : NULL ..$ face : NULL ..$ colour : NULL ..$ size : num 10 ..$ hjust : NULL ..$ vjust : NULL ..$ angle : NULL ..$ lineheight : NULL ..$ margin : NULL ..$ debug : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; $ panel.background :List of 5 ..$ fill : chr &quot;white&quot; ..$ colour : NULL ..$ linewidth : NULL ..$ linetype : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; $ panel.spacing : &#39;simpleUnit&#39; num 0.1lines ..- attr(*, &quot;unit&quot;)= int 3 $ panel.grid.major :List of 6 ..$ colour : chr &quot;#dde3e9&quot; ..$ linewidth : NULL ..$ linetype : NULL ..$ lineend : NULL ..$ arrow : logi FALSE ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_line&quot; &quot;element&quot; $ panel.grid.minor : list() ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_blank&quot; &quot;element&quot; $ plot.margin : &#39;simpleUnit&#39; num [1:4] 1cm 1cm 1cm 1cm ..- attr(*, &quot;unit&quot;)= int 1 $ strip.background :List of 5 ..$ fill : chr &quot;#dde3e9&quot; ..$ colour : chr &quot;white&quot; ..$ linewidth : num 0.8 ..$ linetype : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_rect&quot; &quot;element&quot; $ strip.placement : chr &quot;outside&quot; $ strip.text :List of 11 ..$ family : NULL ..$ face : chr &quot;bold&quot; ..$ colour : chr &quot;black&quot; ..$ size : num 8 ..$ hjust : NULL ..$ vjust : NULL ..$ angle : NULL ..$ lineheight : NULL ..$ margin : NULL ..$ debug : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; $ strip.text.y.left :List of 11 ..$ family : NULL ..$ face : NULL ..$ colour : NULL ..$ size : NULL ..$ hjust : NULL ..$ vjust : NULL ..$ angle : num 0 ..$ lineheight : NULL ..$ margin : NULL ..$ debug : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; $ strip.text.y.right:List of 11 ..$ family : NULL ..$ face : NULL ..$ colour : NULL ..$ size : NULL ..$ hjust : NULL ..$ vjust : NULL ..$ angle : num 0 ..$ lineheight : NULL ..$ margin : NULL ..$ debug : NULL ..$ inherit.blank: logi FALSE ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;element_text&quot; &quot;element&quot; $ legend.position : chr &quot;none&quot; - attr(*, &quot;class&quot;)= chr [1:2] &quot;theme&quot; &quot;gg&quot; - attr(*, &quot;complete&quot;)= logi FALSE - attr(*, &quot;validate&quot;)= logi TRUE mantel_ca_grob 18.2.0.1.1.4 Distance Decay Stat aovperm(lmperm(comm_dist ~ spat_dist, data = results_ca$decay_dfs$M041aI101A), np = 10000) Anova Table Resampling test using freedman_lane to handle nuisance variables and 10000 permutations. SS df F parametric P(&gt;F) resampled P(&gt;F) spat_dist 334.2 1 62.18 5.329e-15 1e-04 Residuals 10153.0 1889 # p &lt; 0.05 → Significant correlation: Spatial distance influences microbial composition. # p &gt; 0.05 → No significant relationship: Microbial communities do not change with distance. 18.2.0.1.1.5 Distance Decay Plot results_ca$distance_decay_plots $M042aI101A $M041aI101A results_ca$distance_decay_plots$M041aI101A + mantel_ca_grob 18.3 Extended RLQ analysis On cryosections with a signal source(&quot;data/JEC_1743_sm_apps5.txt&quot;) # comm_co_G121eO301A &lt;- results_co$cryosection_dfs[[cryosection]]$comm_clr # metadata_co_G121eO301A &lt;- results_co$cryosection_dfs[[cryosection]]$metadata selected_cryosection = &quot;M041aI101A&quot; comm_ca_cryosection &lt;- comm_data[metadata$cryosection == selected_cryosection, ] comm_ca_cryosection &lt;- comm_ca_cryosection[, colSums(comm_ca_cryosection) &gt; 0] metadata_ca_cryosection &lt;- metadata[metadata$cryosection == selected_cryosection, ] comm_ca_cryosection &lt;- comm_ca_cryosection %&gt;% as.data.frame() %&gt;% rownames_to_column(var = &quot;microsample&quot;) %&gt;% bind_cols(metadata_ca_cryosection) %&gt;% select(contains(&quot;bin_&quot;)) comp &lt;- decostand(comm_ca_cryosection, MARGIN = 1, method = &quot;hellinger&quot;) # Standardize composition by rows colnames(comp) &lt;- gsub(&quot;\\\\.&quot;, &quot;:&quot;, names(comp)) env &lt;- data.frame( log_seq_counts = log(metadata_ca_cryosection$total_sequences_after_trim), div = rowSums(comp &gt; 0) ) # Environmental matrix genome_gifts &lt;- genome_gifts[rownames(genome_gifts) %in% colnames(comp), ] genome_funct &lt;- genome_gifts %&gt;% data.frame() %&gt;% rownames_to_column(var = &quot;id&quot;) %&gt;% # Preserve row names as a column pivot_longer(-id, names_to = &quot;column&quot;, values_to = &quot;value&quot;) %&gt;% # Reshape to long format mutate(group = substr(column, 1, 3)) %&gt;% # Extract the first 3 characters of column names group_by(id, group) %&gt;% # Group by row (id) and prefix summarise(mean_value = mean(value, na.rm = TRUE), .groups = &quot;drop&quot;) %&gt;% # Calculate rowMeans for each group pivot_wider(names_from = group, values_from = mean_value) %&gt;% # Reshape back to wide format column_to_rownames(var = &quot;id&quot;) genome_funct &lt;- genome_funct[, -c(19:21)] phy &lt;- genome_tree # Phylogenetic tree constructed with Phylomatic V3 + Phylocom phy &lt;- drop.tip(phy, setdiff(phy$tip.label, rownames(genome_funct))) spa &lt;- metadata_ca_cryosection[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)] # Matrix of X Y spatial coordinates comp &lt;- comp[, match(phy$tip.label, colnames(comp))] genome_funct &lt;- genome_funct[match(phy$tip.label, rownames(genome_funct)), ] mean(phy$tip.label == colnames(comp)) [1] 1 # Change the phylogenetic tree (an object of the class &quot;phylo&quot;) into an object of the class &quot;phylog&quot;, used by ade4 phylog &lt;- newick2phylog(write.tree(phy)) # =&gt; &quot;phylog&quot; class colnames(comp) &lt;- gsub(&quot;:&quot;, &quot;_&quot;, colnames(comp)) rownames(genome_funct) &lt;- gsub(&quot;:&quot;, &quot;_&quot;, rownames(genome_funct)) 18.3.0.0.0.0.1 Correspondence analysis of the composition matrix coacomp &lt;- dudi.coa(comp, scan = FALSE, nf = 108) summary(coacomp) Class: coa dudi Call: dudi.coa(df = comp, scannf = FALSE, nf = 108) Total inertia: 1.728 Eigenvalues: Ax1 Ax2 Ax3 Ax4 Ax5 0.22286 0.19236 0.11452 0.08660 0.07086 Projected inertia (%): Ax1 Ax2 Ax3 Ax4 Ax5 12.897 11.132 6.627 5.011 4.100 Cumulative projected inertia (%): Ax1 Ax1:2 Ax1:3 Ax1:4 Ax1:5 12.90 24.03 30.66 35.67 39.77 (Only 5 dimensions (out of 74) are shown) 18.3.0.0.0.1 Spatial analysis 18.3.0.0.0.2 Gabriel graph # Create the Gabriel graph nb1 &lt;- graph2nb(gabrielneigh(as.matrix(spa)), sym = T) nb1 Neighbour list object: Number of regions: 76 Number of nonzero links: 250 Percentage nonzero weights: 4.328255 Average number of links: 3.289474 # Spatial autocorrelation in diversity and sequence count distribution sp.correlogram(nb1, log(env$div), order = 8, method = &quot;I&quot;) Spatial correlogram for log(env$div) method: Moran&#39;s I estimate expectation variance standard deviate Pr(I) two sided 1 (76) -0.0418637 -0.0133333 0.0081748 -0.3156 0.752343 2 (76) -0.0409739 -0.0133333 0.0047575 -0.4007 0.688614 3 (76) 0.0893327 -0.0133333 0.0037074 1.6861 0.091772 . 4 (76) 0.1660184 -0.0133333 0.0035245 3.0210 0.002519 ** 5 (76) -0.0545644 -0.0133333 0.0037651 -0.6720 0.501615 6 (76) -0.0538944 -0.0133333 0.0041481 -0.6298 0.528840 7 (76) -0.0106319 -0.0133333 0.0045015 0.0403 0.967882 8 (76) -0.1052143 -0.0133333 0.0048664 -1.3171 0.187802 --- Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 sp.correlogram(nb1, env$log_seq_counts, order = 8, method = &quot;I&quot;) Spatial correlogram for env$log_seq_counts method: Moran&#39;s I estimate expectation variance standard deviate Pr(I) two sided 1 (76) -0.01329967 -0.01333333 0.00835172 0.0004 0.9997 2 (76) 0.05096863 -0.01333333 0.00486022 0.9224 0.3563 3 (76) 0.02002293 -0.01333333 0.00378753 0.5420 0.5878 4 (76) -0.03582229 -0.01333333 0.00360057 -0.3748 0.7078 5 (76) -0.07307632 -0.01333333 0.00384606 -0.9633 0.3354 6 (76) 0.00052658 -0.01333333 0.00423725 0.2129 0.8314 7 (76) -0.08211439 -0.01333333 0.00459816 -1.0143 0.3104 8 (76) -0.10034643 -0.01333333 0.00497085 -1.2342 0.2171 lw1 &lt;- nb2listw(nb1) # gives a neighbours list with spatial weights (i.e. matrix W) lw1 Characteristics of weights list object: Neighbour list object: Number of regions: 76 Number of nonzero links: 250 Percentage nonzero weights: 4.328255 Average number of links: 3.289474 Weights style: W Weights constants summary: n nn S0 S1 S2 W 76 5776 76 50.48611 311.9639 par(mfrow = c(1, 1)) plot(nb1, spa, pch = 21, bg = &quot;red&quot;) title(main = &quot;Gabriel Graph&quot;) class(nb1) [1] &quot;nb&quot; # [1] &quot;nb&quot; # This is the Gabriel graph -the graph that in this case defines which points # are connected # The matrix of spatial variables is obtained as the eigenvectors of a # neighbour matrix. This matrix is analysed by principal component analysis. nb1.neigh &lt;- nb2neig(nb1) vecspa &lt;- scores.neig(nb1.neigh) pcaspa &lt;- dudi.pca(vecspa, coacomp$lw, scan = FALSE, nf = ncol(vecspa)) summary(pcaspa) Class: pca dudi Call: dudi.pca(df = vecspa, row.w = coacomp$lw, scannf = FALSE, nf = ncol(vecspa)) Total inertia: 75 Eigenvalues: Ax1 Ax2 Ax3 Ax4 Ax5 1.614 1.600 1.565 1.508 1.479 Projected inertia (%): Ax1 Ax2 Ax3 Ax4 Ax5 2.152 2.133 2.086 2.010 1.971 Cumulative projected inertia (%): Ax1 Ax1:2 Ax1:3 Ax1:4 Ax1:5 2.152 4.285 6.371 8.382 10.353 (Only 5 dimensions (out of 75) are shown) 18.3.0.0.0.3 PCA analysis of the env matrix pcaenv &lt;- dudi.pca(env, row.w = coacomp$lw, scannf = FALSE, nf = 2) summary(pcaenv) Class: pca dudi Call: dudi.pca(df = env, row.w = coacomp$lw, scannf = FALSE, nf = 2) Total inertia: 2 Eigenvalues: Ax1 Ax2 1.6984 0.3016 Projected inertia (%): Ax1 Ax2 84.92 15.08 Cumulative projected inertia (%): Ax1 Ax1:2 84.92 100.00 18.3.0.0.0.4 The distances between species based on their biological traits, analyzed by PCoA. I will set these eval=FALSE as I get an error and I do not have time to troubleshoot yet. # Distance matrices for traits separately listdis &lt;- ldist.ktab(ktab.list.df(list(genome_funct)), c(&quot;Q&quot;), scan = FALSE) # choose 1 # Distance matrix for traits together disT &lt;- dist.ktab(ktab.list.df(list(genome_funct)), c(&quot;Q&quot;), scan = FALSE) # choose 1 pcotraits &lt;- dudi.pco(disT, coacomp$cw, full = TRUE) summary(pcotraits) # n_dis &lt;- attr(disT, &quot;Size&quot;) %||% nrow(as.matrix(disT)) # length(coacomp$cw); length(coacomp$lw); n_dis # summary(coacomp$cw); summary(coacomp$lw) 18.3.0.0.0.5 The distances between species based on their phylogenetic relatedness, analysed by PCoA. # Trying to make the genome names match # Clean tree names rownames(phylog$Wdist) &lt;- sub(&quot;^X&quot;, &quot;&quot;, rownames(phylog$Wdist)) colnames(phylog$Wdist) &lt;- sub(&quot;^X&quot;, &quot;&quot;, colnames(phylog$Wdist)) # Filter comp to taxa that are in the tree comp &lt;- comp[names(comp) %in% rownames(phylog$Wdist)] # Ensure comp is ordered to match tree comp &lt;- comp[rownames(phylog$Wdist)] length(comp) nrow(phylog$Wdist) # Check alignment setdiff(names(comp), rownames(phylog$Wdist)) setdiff(rownames(phylog$Wdist), names(comp)) length(comp) # number of taxa used nrow(phylog$Wdist) # same number of taxa length(coacomp$cw) # weight vector length ## Actual code pcophy &lt;- dudi.pco(as.dist(as.matrix(phylog$Wdist)[names(comp), names(comp)]), coacomp$cw, full = TRUE) summary(pcophy) ## 11. Tests for phylogenetic signals in traits ## ******************************************* # Function rtest.decdiv() in appendix S5, Pavoine et al., 2011. [1] # All traits together phystot &lt;- rtest.decdiv(phylog, rep(1, 108), as.dist(as.matrix(disT)[names(phylog$leaves), names(phylog$leaves)]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) phystot # All traits independently rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D01)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D02)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D03)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D05)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D06)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D07)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D08)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$D09)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B01)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B02)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B03)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B06)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B07)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B08)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B09)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) rtest.decdiv(phylog, rep(1, ncol(comp)), as.dist(as.matrix(listdis$B10)[ names(phylog$leaves), names(phylog$leaves) ]), nrep = 99, vranking = &quot;droot&quot;, optiontest = &quot;less&quot;, ties.method = &quot;average&quot;, option = 3 ) ## Update the PCOA of traits to remove traits without phylogenetic signal # Distance matrix for traits together disT &lt;- dist.ktab(ktab.list.df(list(genome_funct[, -c(4, 8, 13)])), c(&quot;Q&quot;), scan = FALSE) # choose 1 pcotraits &lt;- dudi.pco(disT, coacomp$cw, full = TRUE) summary(pcotraits) 18.3.0.0.0.6 Extended RLQ analysis rlqmix &lt;- rlqESLTP(pcaenv, pcaspa, coacomp, pcotraits, pcophy, scan = F, nf = 2) barplot(rlqmix$eig) rlqmix$eig[1] / sum(rlqmix$eig) # [1] 0.73 rlqmix$eig[2] / sum(rlqmix$eig) # [1] 0.12 1st axis plot(rlqmix, xy = spa, ax = 1, wh = &quot;S&quot;) plot(rlqmix, phy = phylog, ax = 1, wh = &quot;P&quot;) plot(rlqmix, traits = genome_funct[, -c(4, 8, 13)], ax = 1, type = &quot;Q&quot;, wh = &quot;T&quot;) GIFT_db %&gt;% distinct(Code_function, Function)%&gt;% filter(Code_function %in% c(&quot;D02&quot;, &quot;B07&quot;, &quot;D03&quot;, &quot;D09&quot;, &quot;D07&quot;, &quot;D08&quot;)) plot(rlqmix, env = pcaenv$tab, ax = 1, type = &quot;Q&quot;, wh = &quot;E&quot;) s.value(metadata_ca_cryosection[, c(&quot;Xcoord&quot;, &quot;Ycoord&quot;)], rlqmix$lR[, 1], sub = &quot;Patterns in S and E&quot;, csub = 1.5, include.origin = F, csize = 0.8 ) plot(rlqmix, env = pcaenv$tab, ax = 1, type = &quot;Q&quot;, wh = &quot;E&quot;) dotchart.phylog(phylog, rlqmix$lQ[names(phylog$leaves), 1], cleav = 0, cdot = 1, scaling = F, yjoi = 0, cex.axis = 1.5, sub = &quot;patterns in T and P&quot;, csub = 0 ) "],["export-data-for-microbetag.html", "19 Export Data for MicrobeTag 19.1 Load required data 19.2 Export sample metadata (macro samples) 19.3 Export metabolites data (MM samples) 19.4 Export genome metadata 19.5 Export genome counts (macro samples, filtered) 19.6 Summary", " 19 Export Data for MicrobeTag This file exports data for collaboration with MicrobeTag partners. 19.1 Load required data Load all necessary data objects # Load macro sample metadata load(&quot;data/macro/sample_metadata.Rdata&quot;) # Load macro sample counts (includes genome_counts_macro_filt_30_zerosrem) load(&quot;data/macro/counts.Rdata&quot;) # Load genome metadata load(&quot;data/MAG_catalogue/data.Rdata&quot;) # Load metabolites data (MM samples - Histomonas Turkey, digesta) load(&quot;data/Afekta_Histomonas_Metabolites/metabolites_data.Rdata&quot;) 19.2 Export sample metadata (macro samples) This file contains metadata for macro samples (digesta samples from the Histomonas Turkey experiment). Description: - Contains sample information including animal IDs, treatment groups, age categories, tissue types, and other experimental metadata - Each row represents one macro sample - Sample names start with “D” (e.g., D001, D002) Columns include: - sample: Sample identifier (e.g., D001) - animal: Animal identifier - treatment: Treatment group - age_category: Age category (e.g., dpi - days post infection) - tissue: Tissue type - Additional metadata columns as relevant Export macro sample metadata write_csv(sample_metadata_macro, &quot;export/sample_metadata_macro.csv&quot;) cat(&quot;Exported sample_metadata_macro to export/sample_metadata_macro.csv\\n&quot;) cat(&quot;Dimensions:&quot;, nrow(sample_metadata_macro), &quot;rows,&quot;, ncol(sample_metadata_macro), &quot;columns\\n&quot;) 19.3 Export metabolites data (MM samples) This file contains metabolomics abundance data for MM samples (Histomonas Turkey experiment, digesta samples). Description: - Contains metabolite abundance values for each sample - Each row represents one metabolite (identified by Curated ID) - Each column (after Curated ID) represents one sample (animal ID, e.g., M001, M002) - Only includes metabolites with ID level 1 (high confidence identifications) - Only includes samples from the MM group (Histomonas Turkey, digesta) Data structure: - First column: Curated ID - Metabolite name - Subsequent columns: Animal IDs (e.g., M001, M002, etc.) with abundance values Export metabolites MM data write_csv(metabolites_mm, &quot;export/metabolites_mm.csv&quot;) cat(&quot;Exported metabolites_mm to export/metabolites_mm.csv\\n&quot;) cat(&quot;Dimensions:&quot;, nrow(metabolites_mm), &quot;rows (metabolites),&quot;, ncol(metabolites_mm), &quot;columns (Curated ID + samples)\\n&quot;) cat(&quot;Number of samples:&quot;, ncol(metabolites_mm) - 1, &quot;\\n&quot;) 19.4 Export genome metadata This file contains metadata for all Metagenome-Assembled Genomes (MAGs) used in the analysis. Description: - Contains taxonomic and functional information for each MAG - Each row represents one MAG (genome) - Includes taxonomic classifications (phylum, order, family, genus, species) - Includes genome characteristics (length, GC content, completeness, contamination) - Includes database identifiers (GTDB, NCBI, etc.) Columns include: - genome: Genome identifier (e.g., MPB:bin_000001) - phylum, order, family, genus, species: Taxonomic classifications - length: Genome length in base pairs - gc_content: GC content percentage - completeness: Genome completeness estimate - contamination: Estimated contamination level - Additional metadata columns as relevant Export genome metadata write_csv(genome_metadata, &quot;export/genome_metadata.csv&quot;) cat(&quot;Exported genome_metadata to export/genome_metadata.csv\\n&quot;) cat(&quot;Dimensions:&quot;, nrow(genome_metadata), &quot;rows (genomes),&quot;, ncol(genome_metadata), &quot;columns\\n&quot;) 19.5 Export genome counts (macro samples, filtered) This file contains genome abundance counts for macro samples after filtering. Description: - Contains genome copy counts (normalized for genome length) for each sample - Each row represents one MAG (genome) - Each column (after genome) represents one sample - Only includes samples that passed the 30% coverage filtering threshold - Only includes genomes that have non-zero counts in at least one sample - Samples with all-zero counts have been removed Filtering criteria: - Genomes with &lt;30% coverage in a sample were set to zero - Samples with all-zero counts were removed - Genomes with all-zero counts across all samples were removed Data structure: - First column: genome - Genome identifier (e.g., MPB:bin_000001) - Subsequent columns: Sample identifiers (e.g., D001, D002) with genome count values Note: These are genome counts (normalized for genome length), not raw read counts. They represent estimated genome copy numbers per sample. Export genome counts (macro samples, filtered) write_csv(genome_counts_macro_filt_30_zerosrem, &quot;export/genome_counts_macro_filt_30_zerosrem.csv&quot;) cat(&quot;Exported genome_counts_macro_filt_30_zerosrem to export/genome_counts_macro_filt_30_zerosrem.csv\\n&quot;) cat(&quot;Dimensions:&quot;, nrow(genome_counts_macro_filt_30_zerosrem), &quot;rows (genomes),&quot;, ncol(genome_counts_macro_filt_30_zerosrem), &quot;columns (genome + samples)\\n&quot;) cat(&quot;Number of samples:&quot;, ncol(genome_counts_macro_filt_30_zerosrem) - 1, &quot;\\n&quot;) cat(&quot;Number of genomes:&quot;, nrow(genome_counts_macro_filt_30_zerosrem), &quot;\\n&quot;) 19.6 Summary All data files have been exported to the export/ directory: sample_metadata_macro.csv: Macro sample metadata metabolites_mm.csv: Metabolite abundances for MM samples (Histomonas Turkey, digesta) genome_metadata.csv: MAG metadata and taxonomy genome_counts_macro_filt_30_zerosrem.csv: Filtered genome counts for macro samples These files are ready for sharing with MicrobeTag collaborators. "],["package-versions.html", "20 Package Versions", " 20 Package Versions pkgs_all &lt;- installed.packages() get_install_date &lt;- function(pkg) { desc_file &lt;- system.file(&quot;DESCRIPTION&quot;, package = pkg) if (file.exists(desc_file)) { file.info(desc_file)$mtime } else { NA } } R_packages &lt;- data.frame( Package = pkgs_all[, &quot;Package&quot;], Version = pkgs_all[, &quot;Version&quot;], InstallDate = as.POSIXct(sapply(pkgs_all[, &quot;Package&quot;], get_install_date), origin = &quot;1970-01-01&quot;) ) R_packages &lt;- R_packages[order(R_packages$InstallDate, decreasing = TRUE), ] knitr::kable(head(R_packages, 20)) Package Version InstallDate httpgd httpgd 2.0.4 2025-11-02 15:41:43 ggplot2 ggplot2 3.5.2 2025-10-15 18:07:49 ggh4x ggh4x 0.3.0 2025-10-15 18:03:53 doRNG doRNG 1.8.6.2 2025-10-14 20:44:53 TMB TMB 1.9.18 2025-10-13 19:25:37 igraph igraph 2.2.0 2025-10-13 16:15:02 styler styler 1.11.0 2025-10-13 09:31:19 datawizard datawizard 1.3.0 2025-10-11 15:01:39 Rfast Rfast 2.1.5.2 2025-10-10 19:24:54 textshaping textshaping 1.0.4 2025-10-10 12:26:15 glmmTMB glmmTMB 1.1.13 2025-10-09 20:08:27 rversions rversions 3.0.0 2025-10-09 19:29:50 units units 1.0-0 2025-10-09 16:07:45 statmod statmod 1.5.1 2025-10-09 11:59:18 vegan vegan 2.7-2 2025-10-08 19:23:49 Hmisc Hmisc 5.2-4 2025-10-07 22:28:11 ggiraph ggiraph 0.9.2 2025-10-07 22:02:52 devtools devtools 2.4.6 2025-10-07 22:01:32 bookdown bookdown 0.45 2025-10-07 21:46:29 performance performance 0.15.2 2025-10-07 21:32:03 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
