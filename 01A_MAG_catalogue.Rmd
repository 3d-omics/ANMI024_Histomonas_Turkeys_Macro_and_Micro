# MAG Catalogue

Relevant metadata of genomes are fetched and merged into one genome metadata object for downstream analyses.

Location on ERDA:
ID: glS5qQbDc2
Path: 3D-omics/references/REF0029-m_mg_hybrid/
Access: read
genome_taxonomy: https://sid.erda.dk/share_redirect/glS5qQbDc2/gtdbtk.summary.tsv
genome_quality: https://sid.erda.dk/share_redirect/glS5qQbDc2/checkm2.quality_report.tsv
genome_tree: https://sid.erda.dk/share_redirect/glS5qQbDc2/gtdbtk.backbone.bac120.classify.tree
genome_annotations: https://sid.erda.dk/share_redirect/glS5qQbDc2/dram.annotations.tsv.gz

The number of genomes in these files should match the number of genomes in the count tables, after accounting for the appropriate dereplication at species level. 


## Dereplicated genomes

Bins were initially dereplicated at 99%, and annotations generated for all resulting MAGs. 
A second dereplication was performed at 95% to yield species-representative genomes. This analysis is performed on the 95% subset. 
This is how to extract the names of the genomes that remain in the 95% dereplication:
1. Download the file from ERDA: 3D-omics/references/REF0029-m_mg_hybrid/drep.0.95.fa.gz
2. Save it in a directory, and navigate into the directory from the command line.
3. Execute the 3 commands:
gunzip drep.0.95.fa.gz
grep "^>" drep.0.95.fa | sed 's/>//' > genome_names.tsv 
cut -d'@' -f1 genome_names.tsv | sort -u > unique_genome_names.tsv

Load the list of dereplicated genome names
```{r mag_dereplicated_genomes, message=FALSE, eval=FALSE}
selected_genomes <- read_tsv("data/MAG_catalogue/unique_genome_names.tsv", col_names = "genomes") %>%
  pull(genomes)
```

The dereplication yielded 527 species-representative genomes.

## Genome (MAGs) tree
This is the raw tree generated by GTDBtk, which needs to be pruned to obtain the phylogenetic tree of the genomes. 
Note that the archaeal tree is only generated if any archaeans are detected among the genomes.

Load and prune the phylogenetic tree to include only selected genomes
```{r mag_load_tree, message=FALSE, warning=FALSE, eval=FALSE}
genome_tree <- read.tree("data/MAG_catalogue/gtdbtk.backbone.bac120.classify.tree")

# remove single quotes in MAG names
genome_tree$tip.label <- str_replace_all(genome_tree$tip.label, "'", "") 


# There is a genome present in the selected genomes but absent in the tree. This causes the keep.tree to crash.
missing_genomes <- setdiff(selected_genomes, genome_tree$tip.label)
missing_genomes
# The missing genome (from the tree): MPB:bin_000147

# In the selected_genomes list, select only genomes present in the tree
selected_genomes <- selected_genomes[selected_genomes %in% genome_tree$tip.label]

# Then, in the tree, select only the selected_genomes at 95% dereplication
genome_tree <- keep.tip(genome_tree, tip = selected_genomes) 
```

## Genome (MAGs) taxonomy
This is the raw taxonomy table generated by GTDBtk, which is simplified for downstream analyses.

Load and process genome taxonomy data
```{r mag_load_taxonomy, message=FALSE, eval=FALSE}
genome_taxonomy <- read_tsv("data/MAG_catalogue/gtdbtk.summary.tsv", show_col_types = FALSE) %>%
  # rename first column
  rename(genome = user_genome) %>% 
  # remove .fa from the end of each genome name
  mutate(genome = str_replace_all(genome, "\\.fa", "")) %>% 
  # select the species-representative genomes
  filter(genome %in% selected_genomes) %>%
  # separate column 'classification' into columns for the different taxonomic levels
  separate(classification, c("domain", "phylum", "class", "order", "family", 
                             "genus", "species"), sep = ";") %>% 
  # remove redundant letters before taxon names
  mutate(across(domain:species, ~ str_sub(., 4))) %>% 
  # select the relevant taxonomic columns
  select(genome, domain, phylum, class, order, family, genus, species) %>%
  mutate(
    species = if_else(
      is.na(species) | species == "",
      paste0("unclassified_", genus),
      species
    )
  ) %>%
  mutate(
    species = if_else(
      is.na(species) | species == "unclassified_",
      paste0("unclassified_", family),
      species
    )
  ) %>%
  mutate(
    genus = if_else(
      is.na(genus) | genus == "",
      paste0("unclassified_", family),
      genus
    )
  )
```


## Genome (MAGs) quality
Quality properties of the genomes. 

Load and process genome quality metrics
```{r mag_load_quality, message=FALSE, eval=FALSE}
genome_quality <- read_tsv("data/MAG_catalogue/checkm2.quality_report.tsv", show_col_types = FALSE) %>%
  # rename first column
  rename(genome = 1) %>% 
  # remove .fa from the end of each genome name
  mutate(genome = str_replace_all(genome, "\\.fa", "")) %>%
  # select the species-representative genomes
  filter(genome %in% selected_genomes) %>%
  # select relevant columns and rename
  select(genome, Completeness, Contamination, Coding_Density, Genome_Size, Contig_N50) %>% 
  rename(completeness = Completeness, 
         contamination = Contamination, 
         coding_density = Coding_Density, 
         length = Genome_Size,
         N50_length = Contig_N50) %>%
  mutate(circularity = N50_length/length) %>%
  mutate(circularity = ifelse(circularity >= 1, "1", "0")) %>%
  # update completeness and contamination for genomes with circularity of 1
  mutate(completeness = ifelse(circularity == "1", 100, completeness),
         contamination = ifelse(circularity == "1", 0, contamination)) %>%   
# estimate ratio of: genome length / median bacterial genome length
  mutate(length_ratio = length/median(length, na.rm = TRUE))


# How many genomes are circularised?
sum(genome_quality$circularity == 1)
```

## Merged Genome (MAGs) taxonomy & quality

Merge taxonomy, length and quality information.

Combine taxonomy and quality data into a single metadata object
```{r mag_create_genomemetadata, message=FALSE, eval=FALSE}
# combine taxonomy & quality into one df
genome_metadata <- genome_taxonomy %>%
  left_join(genome_quality, by = join_by(genome == genome))
# replace - with _ in the order names
genome_metadata$order <- gsub("-", "_", genome_metadata$order)
# order the genome metadata rows based on the order of the tree
genome_metadata <- genome_metadata[match(genome_tree$tip.label, genome_metadata$genome), ]
```

## Factoring of taxonomic levels
Create metadata summaries for phylum and order levels
```{r mag_genome_phylogeny, message=FALSE, warning=FALSE, eval=FALSE}
phylum_metadata <- genome_metadata %>%
  group_by(phylum) %>%  
  summarize(
    # Count the microsamples
    `number_of_genera` = n_distinct(genus),  
    # Collect unique values separated by commas
    genus = paste(unique(genus), collapse = ", "),
    phylum = paste(unique(phylum), collapse = ", "),
    .groups = "drop") %>%
  select(phylum, number_of_genera, genus) %>%
  # Preserve original order
  arrange(match(phylum, unique(genome_metadata$phylum)))  

order_metadata <- genome_metadata %>%
  group_by(order) %>%  
  summarize(
    # Count the microsamples
    `number_of_genera` = n_distinct(genus),  
    # Collect unique values separated by commas
    genus = paste(unique(genus), collapse = ", "),
    phylum = paste(unique(phylum), collapse = ", "),
    class = paste(unique(class), collapse = ", "),
    # Ensure the dataframe is ungrouped
    .groups = "drop") %>%
  select(phylum, class, order, number_of_genera, genus) %>%
  # Preserve original order
  arrange(match(order, unique(genome_metadata$order)))  

phylum_level_vector <- as.character(unique(phylum_metadata$phylum))

order_level_vector <- as.character(unique(order_metadata$order))
```


## Genome (MAGs) functional annotations
This is the raw annotation table generated by DRAM, which is used to generate GIFT data using distillR.

Load functional annotations from DRAM
```{r mag_load_annotations, message=FALSE, eval=FALSE}
genome_annotations <- read_tsv("data/MAG_catalogue/dram.annotations.tsv.gz", show_col_types = FALSE) %>%
  rename(gene = 1, genome = 2) %>%
  filter(genome %in% selected_genomes)
```


### Distil functional annotations
Raw functional annotations are distilled into genome-inferred functional traits to generate biologically more meaningful functional traits for downstream analyses.

Distill functional annotations into GIFT data
```{r mag_distill_annotations, warning=FALSE, comments="", message=FALSE, results='hide', eval=FALSE}
genome_gifts <- distill(genome_annotations, GIFT_db, genomecol = 2, annotcol = c(9, 10, 19))
```



## Bacterial phyla color scheme data

### Define color schemes for phyla and orders
```{r mag_get_ehi_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
phylum_colors <- c(Actinomycetota = "#346254",
                   Bacillota = "#4a6ab7",
                   Bacillota_A = "#8c1c47",
                   Bacillota_B = "#644ca3",
                   Bacteroidota = "#9c8464",
                   Pseudomonadota = "#c49d4b",
                   Verrucomicrobiota = "#462410",
                   Cyanobacteriota = "#b45f06")

order_colors <- c(Mycobacteriales	= "#79b1a3",
                  Coriobacteriales =	"#498a77",
                  
                  Acholeplasmatales      = "#cfe2f3",
                  CAJFEE01 =	"#a0c5e8",
                  Erysipelotrichales =	"#7acef4",
                  Haloplasmatales        = "#70c2e5",
                  Lactobacillales =	"#6390fb",
                  ML615J_28 =	"#70c9de",
                  RF39 =	"#5c7fba",
                  Staphylococcales        = "#70a8dc",

                  Christensenellales =	"#f58262",
                  Clostridiales =	"#cf4a82",
                  Lachnospirales =	"#e15f7d",
                  Monoglobales = "#e18299",
                  Oscillospirales =	"#ba2760",
                  Peptostreptococcales =	"#e35d51",
                  TANB77 =	"#ef3d26",
                  UBA1381 =	"#be5643",
                  UBA1212      = "#cc0100",
                  
                  Peptococcales       = "#d9d2e9",
                  UBA4068        = "#b4a7d6",

                  Bacteroidales =	"#e3c7a0",
                  
                  Enterobacterales =	"#ffcc62",
                  
                  Verrucomicrobiales = "#823f1d",
                  
                  Gastranaerophilales     = "#bf9001"
                  )
```

### Define plotting settings
Create custom ggplot theme for consistent plotting
```{r mag_custom_ggplot_theme, warning=FALSE, comments="", message=FALSE}
custom_ggplot_theme <- theme(
  strip.text.y.left = element_text(angle = 0),
  strip.text.y.right = element_text(angle = 0),
  axis.text = element_text(size = 10),
  axis.title = element_text(size = 12, face = "bold"),
  strip.background = element_rect(fill = "#dde3e9", color = "white", size = 0.8), # Custom facet strip background
  strip.text = element_text(size = 8, face = "bold", color = "black"), # Custom facet text
  strip.placement = "outside", # Place strip outside the panel grid
  panel.spacing = unit(0.1, "lines"), # Adjust space between panels
  panel.grid.major = element_line(color = "#dde3e9"), # Customize major grid lines
  panel.grid.minor = element_blank(), # Remove minor grid lines
  panel.background = element_rect(fill = "white"), # Change panel background color
  plot.margin = unit(c(1, 1, 1, 1), "cm") # Adjust plot margins to ensure content fits
)
```


### Define treatment color schemes
```{r mag_treatment_colors, warning=FALSE, comments="", message=FALSE, eval=FALSE}
# Bright colors (opaque)
treatment_colours_bright <- c(
  TM1 = "#4059AE",
  TM2 = "#6A9AC3",
  TM3 = "#97D8C4",
  TM4 = "#F3B942",
  TM0 = "grey"
)

# Pastel / transparent (for fill, with ~50% opacity)
treatment_colours_pastel <- paste0(treatment_colours_bright, "50")
```

## Save working objects
In the last step, the objects that are needed for downstream analyses are stored in an R object.

Save MAG catalogue data and color schemes
```{r mag_wrap_objects, eval=FALSE}
save(
  genome_tree,
  genome_metadata,
  phylum_metadata,
  order_metadata,
  genome_gifts,
  file = "data/MAG_catalogue/data.Rdata"
)

save(
  phylum_colors,
  order_colors,
  treatment_colours_bright,
  treatment_colours_pastel,
  custom_ggplot_theme,
  file = "data/data_colors.Rdata"
)
```

## Validation

Validate MAG catalogue data
```{r mag_validation, eval=FALSE}
# Check dimensions of genome_metadata
cat("Genome metadata dimensions:\n")
print(dim(genome_metadata))
cat("\nNumber of genomes:", nrow(genome_metadata), "\n")
cat("Number of columns:", ncol(genome_metadata), "\n\n")

# Check column names
cat("Column names:\n")
print(colnames(genome_metadata))
cat("\n")

# Display top 10 rows
cat("Top 10 rows of genome_metadata:\n")
knitr::kable(head(genome_metadata, 10))
cat("\n")

# Count circularized genomes
circularized_count <- sum(genome_quality$circularity == "1")
cat("Number of circularized genomes:", circularized_count, "\n\n")

# Count phyla and orders
cat("Number of unique phyla:", length(phylum_level_vector), "\n")
cat("Number of unique orders:", length(order_level_vector), "\n\n")

# Summary of phyla
cat("Phyla summary:\n")
knitr::kable(table(genome_metadata$phylum))
cat("\n")

# Summary of orders
cat("Number of genomes per order (top 10):\n")
order_counts <- table(genome_metadata$order)
knitr::kable(head(sort(order_counts, decreasing = TRUE), 10))
```

